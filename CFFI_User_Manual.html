<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><!-- Copyright (C) 2005 James Bielman <jamesjb at jamesjb.com> 

Copyright (C) 2005-2015 Lui's Oliveira
  <loliveira at common-lisp.net> 

Copyright (C) 2005-2006 Dan Knapp <danka at accela.net> 

Copyright (C) 2005-2006 Emily Backes <lucca at accela.net> 

Copyright (C) 2006 Stephen Compall <s11 at member.fsf.org>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. --><!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ --><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>CFFI Руководство пользователя</title>

<meta name="description" content="CFFI User Manual">
<meta name="keywords" content="CFFI User Manual">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Comprehensive-Index" rel="index" title="Comprehensive Index">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="https://common-lisp.net/project/cffi/manual/dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
body {font-family: Georgia, serif;
      line-height: 1.3;
      padding-left: 5em; padding-right: 1em;
      padding-bottom: 1em; max-width: 60em;}
table {border-collapse: collapse}
span.roman { font-family: century schoolbook, serif; font-weight: normal; }
h1, h2, h3, h4, h5, h6 {font-family:  Helvetica, sans-serif}
h4 { margin-top: 2.5em; }
dfn {font-family: inherit; font-variant: italic; font-weight: bolder }
kbd {font-family: monospace; text-decoration: underline}
/*var {font-family: Helvetica, sans-serif; font-variant: slanted}*/
var {font-variant: slanted;}
td  {padding-right: 1em; padding-left: 1em}
sub {font-size: smaller}
.node {padding: 0; margin: 0}

pre.lisp { font-family: monospace;
           background-color: #F4F4F4; border: 1px solid #AAA;
           padding-top: 0.5em; padding-bottom: 0.5em; }

/* coloring */

.lisp-bg { background-color: #F4F4F4 ; color: black; }
.lisp-bg:hover { background-color: #F4F4F4 ; color: black; }

.symbol { font-weight: bold; color: #770055; background-color : transparent; border: 0px; margin: 0px;}
a.symbol:link { font-weight: bold; color : #229955; background-color : transparent; text-decoration: none; border: 0px; margin: 0px; }
a.symbol:active { font-weight: bold; color : #229955; background-color : transparent; text-decoration: none; border: 0px; margin: 0px; }
a.symbol:visited { font-weight: bold; color : #229955; background-color : transparent; text-decoration: none; border: 0px; margin: 0px; }
a.symbol:hover { font-weight: bold; color : #229955; background-color : transparent; text-decoration: none; border: 0px; margin: 0px; }
.special { font-weight: bold; color: #FF5000; background-color: inherit; }
.keyword { font-weight: bold; color: #770000; background-color: inherit; }
.comment { font-weight: normal; color: #007777; background-color: inherit; }
.string  { font-weight: bold; color: #777777; background-color: inherit; }
.character   { font-weight: bold; color: #0055AA; background-color: inherit; }
.syntaxerror { font-weight: bold; color: #FF0000; background-color: inherit; }
span.paren1 { font-weight: bold; color: #777777; }
span.paren1:hover { color: #777777; background-color: #BAFFFF; }
span.paren2 { color: #777777; }
span.paren2:hover { color: #777777; background-color: #FFCACA; }
span.paren3 { color: #777777; }
span.paren3:hover { color: #777777; background-color: #FFFFBA; }
span.paren4 { color: #777777; }
span.paren4:hover { color: #777777; background-color: #CACAFF; }
span.paren5 { color: #777777; }
span.paren5:hover { color: #777777; background-color: #CAFFCA; }
span.paren6 { color: #777777; }
span.paren6:hover { color: #777777; background-color: #FFBAFF; }

-->
</style>

</head><style type="text/css" id="block-image-video"> svg {visibility: hidden !important; opacity: 0 !important}  img {visibility: hidden !important; opacity: 0 !important}  video {visibility: hidden !important; opacity: 0 !important}  canvas {visibility: hidden !important; opacity: 0 !important}  iframe [type="application/x-shockwave-flash"] {visibility: hidden !important; opacity: 0 !important}  .hide {visibility: hidden !important; opacity: 0 !important} </style>

<body lang="en">
<h1 class="settitle" align="center">CFFI Руководство пользователя</h1>

<a name="SEC_Contents"></a>
<h2 class="contents-heading">Содержание</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Introduction-1" href="#Introduction">1 Введение</a></li>
  <li><a name="toc-Installation-1" href="#Installation">2 Установка</a></li>
  <li><a name="toc-Implementation-Support-1" href="#Implementation-Support">3 Поддерживаемая реализация</a>
  <ul class="no-bullet">
    <li><a name="toc-Limitations-1" href="#Limitations-1">3.1 Ограничения</a></li>
  </ul></li>
  <li><a name="toc-An-Introduction-to-Foreign-Interfaces-and-CFFI" href="#Tutorial">4 Введение во внешние
Интерефейсы и <acronym>CFFI</acronym></a>
  <ul class="no-bullet">
    <li><a nam="toc-What-makes-Lisp-different" href="#Tutorial_002dComparison">4.1 Что отличает Lisp</a></li>
    <li><a name="toc-Getting-a-URL" href="#Tutorial_002dGetting-a-URL">4.2 Получение <acronym>URL</acronym></a></li>
    <li><a name="toc-Loading-foreign-libraries" href="#Tutorial_002dLoading">4.3 Загрузка внешних библиотек</a></li>
    <li><a name="toc-Initializing-libcurl" href="#Tutorial_002dInitializing">4.4 Инициализация <code>libcurl</code></a></li>
    <li><a name="toc-Setting-download-options" href="#Tutorial_002deasy_005fsetopt">4.5 Настройка опций(параметров) загрузки</a></li>
    <li><a name="toc-Breaking-the-abstraction" href="#Tutorial_002dAbstraction">4.6 Нарушение абстракции</a></li>
    <li><a name="toc-Option-functions-in-Lisp" href="#Tutorial_002dLisp-easy_005fsetopt">4.7 Опции функций в Lisp</a></li>
    <li><a name="toc-Memory-management" href="#Tutorial_002dMemory">4.8 Управление памятью</a></li>
    <li><a name="toc-Calling-Lisp-from-C" href="#Tutorial_002dCallbacks">4.9 Вызов Lisp из Си</a></li>
    <li><a name="toc-A-complete-FFI_003f" href="#Tutorial_002dCompletion">4.10 Полная <acronym>FFI</acronym>?</a></li>
    <li><a name="toc-Defining-new-types" href="#Tutorial_002dTypes">4.11 Определение новых типов</a></li>
    <li><a name="toc-What_0027s-next_003f" href="#Tutorial_002dConclusion">4.12 Что дальше?</a></li>
  </ul></li>
  <li><a name="toc-Wrapper-generators-1" href="#Wrapper-generators">5 Генератор оберток</a></li>
  <li><a name="toc-Foreign-Types-1" href="#Foreign-Types">6 Внешние типы</a>
  <ul class="no-bullet">
    <li><a name="toc-Built_002dIn-Types-1" href="#Built_002dIn-Types">6.1 Встроенные типы</a></li>
    <li><a name="toc-Other-Types-1" href="#Other-Types">6.2 Другие типы</a></li>
    <li><a name="toc-Defining-Foreign-Types-1" href="#Defining-Foreign-Types">6.3 Определение Внешних типов</a></li>
    <li><a name="toc-Foreign-Type-Translators-1" href="#Foreign-Type-Translators">6.4 Преобразование Внешних типов</a></li>
    <li><a name="toc-Optimizing-Type-Translators-1" href="#Optimizing-Type-Translators">6.5 Оптимизация преобразователей типов</a></li>
    <li><a name="toc-Foreign-Structure-Types-1" href="#Foreign-Structure-Types">6.6 Типы внешних структур</a></li>
    <li><a name="toc-Allocating-Foreign-Objects-1" href="#Allocating-Foreign-Objects">6.7 Размещение(выделение памяти) Внешних Объектов</a></li>
  </ul></li>
  <li><a name="toc-Pointers-1" href="#Pointers">7 Указатели</a>
  <ul class="no-bullet">
    <li><a name="toc-Basic-Pointer-Operations-1" href="#Basic-Pointer-Operations">7.1 Базовые операции с указателями</a></li>
    <li><a name="toc-Allocating-Foreign-Memory-1" href="#Allocating-Foreign-Memory">7.2 Выделение внешней памяти</a></li>
    <li><a name="toc-Accessing-Foreign-Memory-1" href="#Accessing-Foreign-Memory">7.3 Доступ к внешней памяти</a></li>
  </ul></li>
  <li><a name="toc-Strings-1" href="#Strings">8 Стороки</a></li>
  <li><a name="toc-Variables-1" href="#Variables">9 Переменные</a></li>
  <li><a name="toc-Functions-1" href="#Functions">10 Функции</a></li>
  <li><a name="toc-Libraries-1" href="#Libraries">11 Библиотеки</a>
  <ul class="no-bullet">
    <li><a name="toc-Defining-a-library-1" href="#Defining-a-library">11.1 Определение библиотек</a></li>
    <li><a name="toc-Library-definition-style-1" href="#Library-definition-style">11.2 Стиль определения библиотек</a></li>
  </ul></li>
  <li><a name="toc-Callbacks-1" href="#Callbacks">12 Обратные вызовы</a></li>
  <li><a name="toc-The-Groveller-1" href="#The-Groveller">13 Groveller</a>
  <ul class="no-bullet">
    <li><a name="toc-Building-FFIs-with-CFFI_002dGrovel" href="#Building-FFIs-with-CFFI_002dGrovel">13.1 Создание FFI с CFFI-Grovel</a></li>
    <li><a name="toc-Specification-File-Syntax" href="#Groveller-Syntax">13.2 Синтаксис файла спецификации</a></li>
    <li><a name="toc-ASDF-Integration" href="#Groveller-ASDF-Integration">13.3 Интеграция с ASDF</a></li>
    <li><a name="toc-Implementation-Notes" href="#Groveller-Implementation-Notes">13.4 Замечания по реализации</a></li>
    <li><a name="toc-Wrapper-for-Inline_002fStatic-Functions-and-Macros-1" href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros">13.5 Обертки для встраиваемых/Статических (Inline/Static) функций и макросов</a></li>
  </ul></li>
  <li><a name="toc-Static-Linking-1" href="#Static-Linking">14 Статическое связывание</a></li>
  <li><a name="toc-Limitations-2" href="#Limitations">15 Ограничения</a></li>
  <li><a name="toc-Platform_002dspecific-features-1" href="#Platform_002dspecific-features">Приложение А. Особенности платформы</a></li>
  <li><a name="toc-Glossary-1" href="#Glossary">Приложени Б Глосарий</a></li>
  <li><a name="toc-Index" href="#Comprehensive-Index">Указатель</a></li>
</ul>
</div>

<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#Introduction" accesskey="n" rel="next">Introduction</a>, Previous: <a href="https://common-lisp.net/project/cffi/manual/dir.html#Top" accesskey="p" rel="prev">(dir)</a>, Up: <a href="https://common-lisp.net/project/cffi/manual/dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="cffi"></a>
<h1 class="top">cffi</h1>
<p>Copyright Â© 2005 James Bielman &lt;jamesjb at jamesjb.com&gt; <br>
Copyright Â© 2005-2015 LuÃ­s Oliveira
  &lt;loliveira at common-lisp.net&gt; <br>
Copyright Â© 2005-2006 Dan Knapp &lt;danka at accela.net&gt; <br>
Copyright Â© 2005-2006 Emily Backes &lt;lucca at accela.net&gt; <br>
Copyright Â© 2006 Stephen Compall &lt;s11 at member.fsf.org&gt;
</p>
<blockquote>
<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
âSoftwareâ), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</p>
<p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p>
<p><small>THE SOFTWARE IS PROVIDED âAS ISâ, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</small>
</p></blockquote>

<table class="menu" cellspacing="0" border="0">
<tbody><tr><td valign="top" align="left">• <a href="#Introduction" accesskey="1">Introduction</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Что такое CFFI?
</td></tr>
<tr><td valign="top" align="left">• <a href="#Installation" accesskey="2">Installation</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Implementation-Support" accesskey="3">Implementation Support</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial" accesskey="4">Tutorial</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Интерактивное введение в использование CFFI.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Wrapper-generators" accesskey="5">Wrapper generators</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">CFFI фомы из окружения исходного кода на Си.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Foreign-Types" accesskey="6">Foreign Types</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Pointers" accesskey="7">Pointers</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Strings" accesskey="8">Strings</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Variables" accesskey="9">Variables</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Functions">Functions</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Libraries">Libraries</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Callbacks">Callbacks</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#The-Groveller">The Groveller</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Static-Linking">Static Linking</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Limitations">Limitations</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Platform_002dspecific-features">Platform-specific features</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Подробности о базовой системе.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Glossary">Glossary</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Список CFFI-специфичных терминов и значений.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Comprehensive-Index">Comprehensive Index</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
</pre></th></tr><tr><th colspan="3" valign="top" align="left"><pre class="menu-comment"> â Словарь â

Внешние Типы

</pre></th></tr><tr><td valign="top" align="left">• <a href="#convert_002dfrom_002dforeign">convert-from-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Внешний интефрейс для обратного преобразователя типа.
</td></tr>
<tr><td valign="top" align="left">• <a href="#convert_002dto_002dforeign">convert-to-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Внешний интерфес для пряомго преобразователя типа.
</td></tr>
<tr><td valign="top" align="left">• <a href="#defbitfield">defbitfield</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">определяет битовое поле.
</td></tr>
<tr><td valign="top" align="left">• <a href="#defcstruct">defcstruct</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">определяет тип Си структуры.
</td></tr>
<tr><td valign="top" align="left">• <a href="#defcunion">defcunion</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">определяет тип Си объединение.
</td></tr>
<tr><td valign="top" align="left">• <a href="#defctype">defctype</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">определяет внешний typedef.
</td></tr>
<tr><td valign="top" align="left">• <a href="#defcenum">defcenum</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">определяет перечисление Си.
</td></tr>
<tr><td valign="top" align="left">• <a href="#define_002dforeign_002dtype">define-foreign-type</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Определяет спецификатор внешнего типа.
</td></tr>
<tr><td valign="top" align="left">• <a href="#define_002dparse_002dmethod">define-parse-method</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Определяет, как должен анализироваться(parsed) тип.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает список символов для типа битового поля.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Вычисляет значение для типа битового поля.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Находит ключевое слово в тип перечисления.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002denum_002dvalue">foreign-enum-value</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Находит значение в типе перечисления.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dslot_002dnames">foreign-slot-names</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает список имен слотов во внешней структуре.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dslot_002doffset">foreign-slot-offset</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает смещение слота во внешней структуре.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает указатель на слот во внешней структуре.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает значение слота во внешней струтуре.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dtype_002dalignment">foreign-type-alignment</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает выравнивание внешнего типа.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dtype_002dsize">foreign-type-size</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает размер внешнего типа.
</td></tr>
<tr><td valign="top" align="left">• <a href="#free_002dconverted_002dobject">free-converted-object</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Внешний интерфейс для особождения(удаления) типизированных объектов.
</td></tr>
<tr><td valign="top" align="left">• <a href="#free_002dtranslated_002dobject">free-translated-object</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Определяет, как осовбодить внешний объект.
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dfrom_002dforeign">translate-from-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Определяет перобразование внешнего объекта в Лисп.
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dto_002dforeign">translate-to-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Определяет преобразование Лисп во внешний объект.
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dobject">with-foreign-object</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Выделяет внешний объект с динамическим пространством.
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dobjects">with-foreign-objects</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Множественная форма <code>with-foreign-object</code>.
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dslots">with-foreign-slots</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">доступ к слотам внешней структуры.
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Укзатели

</pre></th></tr><tr><td valign="top" align="left">• <a href="#foreign_002dfree">foreign-free</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Освобождает память.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dalloc">foreign-alloc</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Выделяет память.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dsymbol_002dpointer">foreign-symbol-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Взвращает указать на внешний символ.
</td></tr>
<tr><td valign="top" align="left">• <a href="#inc_002dpointer">inc-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">увеличивает адрес указываемый указателем.
</td></tr>
<tr><td valign="top" align="left">• <a href="#incf_002dpointer">incf-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Увеличивает адресс указателя по месту.
</td></tr>
<tr><td valign="top" align="left">• <a href="#make_002dpointer">make-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает указатель на заданный адрес.
</td></tr>
<tr><td valign="top" align="left">• <a href="#mem_002daptr">mem-aptr</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">указатель на элемент массива.
</td></tr>
<tr><td valign="top" align="left">• <a href="#mem_002daref">mem-aref</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">доступ к значению по индексу в массиве.
</td></tr>
<tr><td valign="top" align="left">• <a href="#mem_002dref">mem-ref</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Разименовывает указатель.
</td></tr>
<tr><td valign="top" align="left">• <a href="#null_002dpointer">null-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает нулево указатель.
</td></tr>
<tr><td valign="top" align="left">• <a href="#null_002dpointer_002dp">null-pointer-p</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Проверяет, является ли объект указателем со значением NULL.
</td></tr>
<tr><td valign="top" align="left">• <a href="#pointerp">pointerp</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Проверяет является ли объект указателем или нет.
</td></tr>
<tr><td valign="top" align="left">• <a href="#pointer_002daddress">pointer-address</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает адрес, на который указывает указатель.
</td></tr>
<tr><td valign="top" align="left">• <a href="#pointer_002deq">pointer-eq</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">провряет, указывают ли два укзателя на один и тот же адрес.
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dpointer">with-foreign-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">выделяет память с динамическим пространством.
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Строки

</pre></th></tr><tr><td valign="top" align="left">• <a href="#g_t_002adefault_002dforeign_002dencoding_002a">*default-foreign-encoding*</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Кодировка по умолчанию для строковых типов.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Преобразует Лисп строку во внешнюю строку.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dstring_002dfree">foreign-string-free</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Освобождает память используемую внешней строкой.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Преобразует внешнюю строку в строку Lisp.
</td></tr>
<tr><td valign="top" align="left">• <a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Копирует Lisp строку во внешнюю строку.
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dstring">with-foreign-string</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Выделяет внешнюю строку с динамическим пространством.
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dstrings">with-foreign-strings</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Множественная форма <code>with-foreign-string</code>.
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Аналогичное использование указателя в качестве строки  для CL with-output-to-string.
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Переменные

</pre></th></tr><tr><td valign="top" align="left">• <a href="#defcvar">defcvar</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Определяет глобальную переменную Си.
</td></tr>
<tr><td valign="top" align="left">• <a href="#get_002dvar_002dpointer">get-var-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает указатель на определенную глобальную переменую.
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Functions

</pre></th></tr><tr><td valign="top" align="left">• <a href="#defcfun">defcfun</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Определяет внешнюю функцию.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dfuncall">foreign-funcall</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">выполняет вызов внешней функции.
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">выполняет вызов через внешний указатель.
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">преобразует внешнее имя camelCase из/в имя Lisp.
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">преобразует внешнее имя в имя Lisp.
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">преобразует имя Lisp во внешнее имя.
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">преобразует внешнее имя с разделением подчеркиваниями в/из имя Lisp.
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Библиотеки

</pre></th></tr><tr><td valign="top" align="left">• <a href="#close_002dforeign_002dlibrary">close-foreign-library</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Закрывает внешнюю библиотеку.
</td></tr>
<tr><td valign="top" align="left">• <a href="#g_t_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Путь поиска для Darwin frameworks.
</td></tr>
<tr><td valign="top" align="left">• <a href="#define_002dforeign_002dlibrary">define-foreign-library</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Объясняет, как загружать стороннюю библиотеку.
</td></tr>
<tr><td valign="top" align="left">• <a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Путь поиска разделяемых(общих) библиотек.
</td></tr>
<tr><td valign="top" align="left">• <a href="#load_002dforeign_002dlibrary">load-foreign-library</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Загрузка внешней библиотеки.
</td></tr>
<tr><td valign="top" align="left">• <a href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">сообщает о сбое при загрузке библиотеки.
</td></tr>
<tr><td valign="top" align="left">• <a href="#use_002dforeign_002dlibrary">use-foreign-library</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">при необходимости загружает внешнюю библиотеку.
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Обратные вызовы

</pre></th></tr><tr><td valign="top" align="left">• <a href="#callback">callback</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает указатель на определенный обратный вызов.
</td></tr>
<tr><td valign="top" align="left">• <a href="#defcallback">defcallback</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Определяет обратный вызов Lisp.
</td></tr>
<tr><td valign="top" align="left">• <a href="#get_002dcallback">get-callback</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Возвращает укаазтель на определенный обратный вызов.
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
</pre></th></tr></tbody></table>

<hr>
<a name="Introduction"></a>
<div class="header">
<p>
Next: <a href="#Installation" accesskey="n" rel="next">Installation</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Introduction-1"></a>
<h2 class="chapter">1 Введение</h2>

<p><acronym>CFFI</acronym> это общий интерфейс к внешним функциям(Common Foreign Function Interface)
для систем <acronym>ANSI</acronym> Common Lisp.  Под внешней функцией(<em>foreign function</em>)
мы подразумеваем функцию, написанную на другом языке программирования и 
имеющую другие данные и соглашения о вызыовах, чем Common Lisp, а именно Си  
<acronym>CFFI</acronym> позволяет вам вызывать внешние функции и получать доступ к 
внешним переменным и все это, не выходя из образа Lisp.
</p>
<p>Мы считаем, что это руководство находится в стадии разработки. Если у вас возникли
трудности с чем либо  <acronym>CFFI</acronym>-специфичным, представленным в
этом руководстве, пожалуйста свяжитесь с разработчиками <a href="mailto:cffi-devel@common-lisp.net"></a> 
для получения подробной информации.
</p>

<a name="Motivation"></a>
<h3 class="heading">Мотивация</h3>

<p>См. <a href="#Tutorial_002dComparison">Что делает Lisp особенным</a>, для
аргументации в пользу <acronym>FFI</acronym> в целом.
</p>
<p>Основная роль <acronym>CFFI</acronym> в любом образе - это посредничество между
разработчиками Lisp и широко варьирующимися <acronym>FFI</acronym>, присутствующими
в различных реализациях Lisp, которые он поддерживает.  С <acronym>CFFI</acronym>, вы
можете определять интерфейсы сторонних функций, сохраняя при этом переносимость между
реализациями. Это не первый пакет Common Lisp разработанный с этой целью, тем не менее,
он должен быть более гибким, чем подобные пакеты.
</p>

<a name="Design-Philosophy"></a>
<h3 class="heading">Философия Разработки</h3>

<ul>
<li> Указатели не несут информацию о типе. Вместо этого информация о типе
предоставляется, когда указатели разименовываются.

</li><li> Интерфейс безопасного типизированного указателя может быть разработан поверх
нетипизированного.  Трудно сделать наоборот.

</li><li> Функции лучше чем маркосы.  Когда макрос может использоваться для
производительности, используйте вместо этого макрос компилятора.
</li></ul>

<hr>
<a name="Installation"></a>
<div class="header">
<p>
Next: <a href="#Implementation-Support" accesskey="n" rel="next">Implementation Support</a>, Previous: <a href="#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Installation-1"></a>
<h2 class="chapter">2 Инсталяция</h2>

<p><acronym>CFFI</acronym> можно получить одним из следующих способов доступных
на его  <a href="http://common-lisp.net/project/cffi/">website</a>:
</p>
<ul>
<li> <a href="http://common-lisp.net/project/cffi/releases/?M=D">архив официального релиза</a>

</li><li> <a href="http://common-lisp.net/gitweb?p=projects/cffi/cffi.git">git репозиторий</a>

</li></ul>

<p>Кроме того, вам необходимо получить и усатновить следующие зависимости:
</p>
<ul>
<li> <a href="http://common-lisp.net/project/babel/">Babel</a>, библиотека
кодирования/декодирования наборов символов.

</li><li> <a href="http://common-lisp.net/project/alexandria/">Alexandria</a>, 
коллекция переносимых утилит общего достояния.

</li><li> <a href="http://www.cliki.net/trivial-features">trivial-features</a>, 
уровень преносимомсти, для обеспечениия согласованности <code>*features*</code> 
множества нескольких реализаций Common Lisp.

</li></ul>

<p>Кроме того, если вы хотите запустить набор тестов(testsuite), требуется,
<a href="http://www.cliki.net/rt">RT</a>.
</p>
<p>Вы можете найти механизмы, такие как
<a href="https://www.quicklisp.org/beta/">Quicklisp</a> (рекомендуем)
или <a href="http://common-lisp.net/project/clbuild/">clbuild</a> (для продвинутых
пользователей), полезные для получения и управления <acronym>CFFI</acronym> и его
зависимостями.
</p>

<hr>
<a name="Implementation-Support"></a>
<div class="header">
<p>
Next: <a href="#Tutorial" accesskey="n" rel="next">Tutorial</a>, Previous: <a href="#Installation" accesskey="p" rel="prev">Installation</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Implementation-Support-1"></a>
<h2 class="chapter">3 Поддерживаемые реализации</h2>

<p><acronym>CFFI</acronym> поддерживает различные бесплатные и комерческие реализации:
<acronym>ABCL</acronym>, Allegro CL, Clasp, <small>CLISP</small>, Clozure CL,
<acronym>CMUCL</acronym>, Corman CL, <acronym>ECL</acronym>, <acronym>GCL</acronym>, LispWorks,
<acronym>MCL</acronym>, <acronym>SBCL</acronym> и  Scieneer CL.
</p>
<p>В общем, вам следует работать с последними версиями каждой реализации,
поскольку они обычно будут чаще тестироваться на последних версиях CFFI 
и могут включать необходимые функции или исправления ошибок. Разумные патчи
для совместимости с более ранними версиями - приветствуются.
</p>
<a name="Limitations-1"></a>
<h3 class="section">3.1 Ограничения</h3>

<p>Некоторые функции поддерживаются не во всех реализациях.
</p>
<a name="Allegro-CL"></a>
<h4 class="subheading">Allegro CL</h4>

<ul>
<li> Не поддерживается родной тип <code>:long-long</code>.
</li><li> Поддержка юникода ограничена базовым многоязычным уровнем (16-bit
кодовые точки).
</li></ul>

<a name="Clasp"></a>
<h4 class="subheading">Clasp</h4>

<ul>
<li> Поддерживает только плоское пространство имен.
</li></ul>

<a name="CMUCL"></a>
<h4 class="subheading">CMUCL</h4>

<ul>
<li> Нет поддержки юникода. (8-bit кодовые точки)
</li></ul>

<a name="Corman-CL"></a>
<h4 class="subheading">Corman CL</h4>

<ul>
<li> Не поддерживает <code>foreign-funcall</code>.
</li></ul>

<a name="ECL"></a>
<h4 class="subheading"><acronym>ECL</acronym></h4>

<ul>
<li> На платформах, где  ECL динамическая FFI не поддерживается (например, когда
<code>:dffi</code> отсутствует в <code>*features*</code>),
<code>cffi:load-foreign-library</code> не работает и вы должны использовать ECL
<code>ffi:load-foreign-library</code> с константным строковым аргументом.
</li></ul>

<a name="Lispworks"></a>
<h4 class="subheading">Lispworks</h4>

<ul>
<li> Не полностью поддерживает родной тип <code>:long-long</code> на 
32-bit платформах.
</li><li> Поддержка юникода ограничена базовым многоязычным уровнем (16-bit
кодовые точки).
</li></ul>

<a name="SBCL"></a>
<h4 class="subheading"><acronym>SBCL</acronym></h4>

<ul>
<li> Не все платформы поддерживают обратные вызовы.

</li></ul>

<hr>
<a name="Tutorial"></a>
<div class="header">
<p>
Next: <a href="#Wrapper-generators" accesskey="n" rel="next">Wrapper generators</a>, Previous: <a href="#Implementation-Support" accesskey="p" rel="prev">Implementation Support</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="An-Introduction-to-Foreign-Interfaces-and-CFFI"></a>
<h2 class="chapter">4 Введение во внешние интерфейсы и <acronym>CFFI</acronym></h2>

<a name="index-tutorial_002c-CFFI"></a>
<p>Пользователи многих популярных языков, имеющих семантическое сходство с Lisp,
таких как Perl и Python, привыкли иметь доступ к популярным Си библиотекам, 
таким как <acronym>GTK</acronym>, посредством âпривязок(биндингов)â.  В Lisp, 
мы делаем нечто подобное, но применяем принципиально другой подход. Это руководство
сначала объясняет эту разницу, а затем объясняет, как вы можете использовать
<acronym>CFFI</acronym>, мощную систему для вызова C и C++ и доступа к данным
Си из многих реализаций Common Lisp.
</p>
<a name="index-foreign-functions-and-data"></a>
<p>Концепция может быть обобщена на другие языки; на момент написания,
завершена только  <acronym>CFFI</acronym>âs поддерживающая Си. Поэтому
мы будем взаимозаменяемо ссылаться на внешние функции( <em>foreign functions</em>) 
и внешние данные(<em>foreign data</em>), как на си функции и си данные.  Слово
âвнешнийâ никогда не будет иметь своего обычного, не программного смысла.
</p>
<p>В этом руководстве пердполагается, что вы хорошо разбираетесь в
Common Lisp и Си, включая макросистему Common Lisp.
</p>
<table class="menu" cellspacing="0" border="0">
<tbody><tr><td valign="top" align="left">• <a href="#Tutorial_002dComparison" accesskey="1">Tutorial-Comparison</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Почему FFI?
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dGetting-a-URL" accesskey="2">Tutorial-Getting a URL</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Варианты использования FFI.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dLoading" accesskey="3">Tutorial-Loading</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Загрузка libcurl.so.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dInitializing" accesskey="4">Tutorial-Initializing</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Вызов функции из libcurl.so.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002deasy_005fsetopt" accesskey="5">Tutorial-easy_setopt</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">расширенная функция libcurl.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dAbstraction" accesskey="6">Tutorial-Abstraction</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">зачем его ломать.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dLisp-easy_005fsetopt" accesskey="7">Tutorial-Lisp easy_setopt</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">интерфейс полу-Lisp(ийских) опций.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dMemory" accesskey="8">Tutorial-Memory</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">в Си вы убираете мусор.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dCallbacks" accesskey="9">Tutorial-Callbacks</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Создание полезных указателей на функции Си.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dCompletion">Tutorial-Completion</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Минимальная функциональность get-url.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dTypes">Tutorial-Types</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Определенение новых внешних типов.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Tutorial_002dConclusion">Tutorial-Conclusion</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Что дальше?
</td></tr>
</tbody></table>

<hr>
<a name="Tutorial_002dComparison"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dGetting-a-URL" accesskey="n" rel="next">Tutorial-Getting a URL</a>, Previous: <a href="#Tutorial" accesskey="p" rel="prev">Tutorial</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="What-makes-Lisp-different"></a>
<h3 class="section">4.1 Что делает Lisp особенным</h3>

<p>Ниже показано, как привязки к внешним библиотекам обычно реализуются на других языках,
а затем как в Common Lisp:
</p>
<dl compact="compact">
<dt>Perl, Python, Java, и другие языки с одной реализацией</dt>
<dd><a name="index-SWIG"></a>
<a name="index-Perl"></a>
<a name="index-Python"></a>
<p>Привязки реализуются как общие объекты, написанные на Си.  В некоторых
случаях, код Си генерируется инструментом, таким как <acronym>SWIG</acronym>, но
результат тот же: новая Си библиотека которая вручную переводит между объектами
языковой реализации, такими как <code>PyObject</code>
на  Python, и независимо от того, к какому объекту Си обращаются, часто используя
функции Си предоставляемые реализацией.  Она также проводит преобразование между
соглашениями о вызовах между языком и Си
</p>
</dd>
<dt>Common Lisp</dt>
<dd><a name="index-SLIME"></a>
<p>Привязки написанные на Lisp.  Они могут быть созданы по желанию 
программ Lisp. Программисты Lisp могут писать новые привязки и добавлять их в
образ, используя "слушателя", такого как <acronym>SLIME</acronym>, так же легко,
как и с обычными определениями Lisp.  Только внешняя библиотека, загружается
без обертки, т.е только та которая имеет исходный Си интерфейс, не требуется 
компиляция Си или других не-Lisp программ-оберток.
</p></dd>
</dl>

<a name="index-advantages-of-FFI"></a>
<a name="index-benefits-of-FFI"></a>
<p>Мы считаем, что преимущества подхода Common Lisp намного перевешивают любые
недостатки.  Инкрементальная разработка со "слушателем" может быть столь же
продуктивной и для разработки Си биндингов, как и с другими разработками на
Lisp.  Сохранение его(биндинга) âв семействе [Lisp]â, как бы облегчает
вам и другим программистам Lisp загрузку и использование биндингов.  
Таким образом, обычные реализации Common Lisp, такие как <acronym>CMUCL</acronym>, 
особождаются от необходимости предоставлять Си интефрейс для своих собственных
объектов, и могут быть реализованы на другом языке (как в <acronym>CMUCL</acronym>)
в то же время позволяя программистам вызывать внешние функции.
</p>
<a name="index-minimal-bindings"></a>
<p>Возможно, самое большое преимущество заключается в том, что использование
 <acronym>FFI</acronym> не обязывает вас становиться профессиональным
разработчиком биндингов.  Создатели привязок для других языков обычно заканчивают
тем, что поддерживают или не поддерживают полные привязки к внешней библиотеке.  
Использование <acronym>FFI</acronym>, однако, означает, что если вам нужна только
одна или две функции, вы можете, написать привязки только для этих функций и быть
уверенными, что вы можете так же легко добавлять привязки, если это необходимо.
</p>
<a name="index-C-abstractions"></a>
<a name="index-abstractions-in-C"></a>
<p>Удаление Си компилятора или любой дргуой Си интерпретации создает главный недостаток,
некоторые Си из âабстракцииâ становятся недоступными, что нарушает инкапсуляцию 
информации.  Например, <code>struct</code> которые должны быть переданы в стек, или
использованы в качестве возвращаемых значений без соответствующих функциональных абстракций
для создания и управления структурами(<code>struct</code>), должны быть явно объявлены в Lisp.
Это хорошо для структур(struct) содержимое которых является âпубличнымâ, но не очень
приятно, когда структура считается по соглашению не прозрачной(âopaqueâ),
даже если она так не определена.<a name="DOCF1" href="#FOOT1"><sup>1</sup></a>
</p>
<p>Без абстракции для создания структуры Lisp должен иметь возможность размещать структуру в
памяти, поэтому должен знать ее внутренние детали.
</p>
<a name="index-workaround-for-C"></a>
<p>В этих случаях, вы можете создать минимальную Си библиотеку для предоставления
отсутствующих абстракций, не разрушая все преимущства подхода
Common Lisp, рассмотренного выше.  В случае структур(<code>struct</code>),
вы можете написать простые, чистые функции C, которые сообщат вам, сколько байтов требуется
структуре, или выделять новые структуры, читать и записывать поля структуры или любые
другие операции, которые должны быть общедоступными.
<a name="DOCF2" href="#FOOT2"><sup>2</sup></a>
<a href="#The-Groveller">The Groveller</a> автоматизирует этот процесс.
</p>
<p>Другой недостаток возникает, когда вы предпочитаете испольозвать
внешний язык, а не Lisp.  Однако, тот, кто предпочитает Си Лиспу, не 
является вероятным кандидатом на разработку интерфейса Lisp для Си библиотеки.
</p>

<hr>
<a name="Tutorial_002dGetting-a-URL"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dLoading" accesskey="n" rel="next">Tutorial-Loading</a>, Previous: <a href="#Tutorial_002dComparison" accesskey="p" rel="prev">Tutorial-Comparison</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Getting-a-URL"></a>
<h3 class="section">4.2 Получение <acronym>URL</acronym></h3>

<a name="index-cURL"></a>
<p>Широко доступная библиотека <code>libcurl</code> i - это библиотека для загрузки файлов
по протоколам, таким как <acronym>HTTP</acronym>.  Мы будем использовать <code>libcurl</code> с
<acronym>CFFI</acronym> для загрузки веб страницы.
</p>
<p>Обратите внимание, что существует множество других способов загрузки файлов из
интернета, не в последнюю очередь проект <small>CL-CURL</small> предоставляющий привязки
для <code>libcurl</code> через аналогичный <acronym>FFI</acronym>.<a name="DOCF3" href="#FOOT3"><sup>3</sup></a>
</p>
<p><a href="http://curl.haxx.se/libcurl/c/libcurl-tutorial.html">libcurl-tutorial(3)</a>
это учебник по программированию в <code>libcurl</code> на Си.  Мы также будем следовать ему,
чтобы разработать биндинг для скачивания файла.  Мы также будем использовать
<samp>curl.h</samp>, <samp>easy.h</samp>, и справочник <code>man</code> для функций
<code>libcurl</code>, которые доступны в пакете â<samp>curl-dev</samp>â или
эквивалентном для вашей системе, или в пакете исходного кода <acronym>URL</acronym>.  
Если у вас  есть пакет разработки, заголовчные файлы должны быть установлены в 
<samp>/usr/include/curl/</samp>, а страницы <code>man</code> могут быть
доступны через ваш любимый иструмент <code>man</code>.
</p>

<hr>
<a name="Tutorial_002dLoading"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dInitializing" accesskey="n" rel="next">Tutorial-Initializing</a>, Previous: <a href="#Tutorial_002dGetting-a-URL" accesskey="p" rel="prev">Tutorial-Getting a URL</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Loading-foreign-libraries"></a>
<h3 class="section">4.3 Загрузка внешних библиотек</h3>

<a name="index-loading-CFFI"></a>
<a name="index-requiring-CFFI"></a>
<p>Прежде всего, мы создадим пакет для работы. Вы можете сохранить эти файлы или просто
отправить их "слушателю", как есть.  Если вы создаете привязки для вашего пакета 
<acronym>ASDF</acronym>, вам нужно добавить <code>:cffi</code> в список зависимостей 
<code>:depends-on</code> в ваш файл <samp>.asd</samp>.  В противном случае просто
используйте функцию <code>asdf:load-system</code> для загрузки  <acronym>CFFI</acronym>.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">asdf:load-system <span class="keyword">:cffi</span></span>)</span>

  <span class="comment">;;; Nothing special about the "CFFI-USER" package.  We're just
  </span><span class="comment">;;; using it as a substitute for your own CL package.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defpackage</span></i> <span class="keyword">:cffi-user</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:use</span> <span class="keyword">:common-lisp</span> <span class="keyword">:cffi</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg">in-package <span class="keyword">:cffi-user</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-library</span></i> libcurl
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:darwin</span> <span class="paren3">(<span class="lisp-bg"><span class="keyword">:or</span> <span class="string">"libcurl.3.dylib"</span> <span class="string">"libcurl.dylib"</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:unix</span> <span class="paren3">(<span class="lisp-bg"><span class="keyword">:or</span> <span class="string">"libcurl.so.3"</span> <span class="string">"libcurl.so"</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">t <span class="paren3">(<span class="lisp-bg"><span class="keyword">:default</span> <span class="string">"libcurl"</span></span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg">use-foreign-library libcurl</span>)</span>
</pre></div>

<a name="index-foreign-library-load"></a>
<a name="index-library_002c-foreign"></a>
<p>Используя <code>define-foreign-library</code> и <code>use-foreign-library</code>, мы
загрузили <code>libcurl</code> в Lisp, так же как это делает компоновщик(linker), когда
вы запускаете программу написанную на Си, или как это делает <code>common-lisp:load</code>
с исходным файлом Lisp или файлом <acronym>FASL</acronym>.  Мы специально выделили
случай, чтобы для <small>UNIX</small> машин, всегда загружалась определенная версия, та
с которой этот учебник был протестирован; для тех кого это не волнует, предложение в
<code>define-foreign-library</code> <code>(t (:default "libcurl"))</code> 
удовлетворительно адаптировано к различным опреационным системам.
</p>

<hr>
<a name="Tutorial_002dInitializing"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002deasy_005fsetopt" accesskey="n" rel="next">Tutorial-easy_setopt</a>, Previous: <a href="#Tutorial_002dLoading" accesskey="p" rel="prev">Tutorial-Loading</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Initializing-libcurl"></a>
<h3 class="section">4.4 Инициализация <code>libcurl</code></h3>

<a name="index-function-definition"></a>
<p>После вступительного материала, учебное пособие представляет первую функцию,
которую вы должны использовать.
</p>
<div class="example">
<pre class="example">CURLcode curl_global_init(long flags);
</pre></div>

<p>Давайте разберем её в соответствующем коде на Lisp:
</p>
<div class="lisp">
<pre class="lisp">  <span class="comment">;;; A CURLcode is the universal error code.  curl/curl.h says
  </span><span class="comment">;;; no return code will ever be removed, and new ones will be
  </span><span class="comment">;;; added to the end.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> curl-code <span class="keyword">:int</span></span>)</span>

  <span class="comment">;;; Initialize libcurl with FLAGS.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"curl_global_init"</span> curl-code
    <span class="paren2">(<span class="lisp-bg">flags <span class="keyword">:long</span></span>)</span></span>)</span>
</pre></div>

<blockquote>
<p><strong>Примечание разработчика:</strong> <em>По умолчанию, CFFI предполагает
точку зрения UNIX, что существует одно пространство имен символов Си, содержащее
все символы во всех загруженных объектах.
Это не так в Windows и Darwin, но там мы подражаем поведению UNIX.  
См. <a href="#defcfun">defcfun</a> для более подробной информации.</em>
</p></blockquote>

<p>Обратите внимание на параллели с исходной декларацией на языке Си.  Мы определели
<code>curl-code</code> как тип оболочку  для <code>:int</code>; Здесь это только
специальная метка, но в дальнейшем мы следаем кое-что боле интересное с этим.  Дело
в том, что нам пока не нужно это делать.
</p>
<a name="index-calling-foreign-functions"></a>
<p>Взглянув на <samp>curl.h</samp>, <code>CURL_GLOBAL_NOTHING</code>, возможное значение
для <code>flags</code>, определяется как â<samp>0</samp>â.  Итак, теперь мы можем
вызвать функцию:
</p>
<div class="example">
<pre class="example">CFFI-USER&gt; (curl-global-init 0)
â 0
</pre></div>

<a name="index-looks-like-it-worked"></a>
<p>Снова взглянув на <samp>curl.h</samp>, видим, что <code>0</code> означает <code>CURLE_OK</code>, 
поэтому, похоже что вызов прошел успешно.  Обратите внимание, что <acronym>CFFI</acronym> 
преобразовал имя функции в понятное для Lisp имя.  Вы можете указать свое имя, если хотите,
используйте <code>("curl_global_init" <var>your-name-here</var>)</code> как
 <var>name</var> в качестве аргумента для <code>defcfun</code>.
</p>
<p>Продолжаем. Теперь нам надо выделить хендл("ручку для управления чем либо").
Хорошей манерой будет также включить сюда деалокатор(функцию особождающую хендл).
Давайте посмотрим на эти функции:
</p>
<div class="example">
<pre class="example">CURL *curl_easy_init( );
void curl_easy_cleanup(CURL *handle);
</pre></div>

<p>Опытные пользователи могут захотеть определить специальные типы указателей,
мы рассмотрим эту возможность позже.  А пока, просто обрабатываем каждый указатель
одинаково:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"curl_easy_init"</span> <span class="keyword">:pointer</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"curl_easy_cleanup"</span> <span class="keyword">:void</span>
    <span class="paren2">(<span class="lisp-bg">easy-handle <span class="keyword">:pointer</span></span>)</span></span>)</span>
</pre></div>

<p>Теперь мы можем продолжить обучение:
</p>
<div class="example">
<pre class="example">CFFI-USER&gt; (defparameter *easy-handle* (curl-easy-init))
⇒ *EASY-HANDLE*
CFFI-USER&gt; *easy-handle*
⇒ #&lt;FOREIGN-ADDRESS #x09844EE0&gt;
</pre></div>

<a name="index-pointers-in-Lisp"></a>
<p>Обратите внимание на печатное представление указателя.  Оно меняется в
зависимости от того, какой Lisp вы используете, но это неимеет никакого
значения для <acronym>CFFI</acronym>.
</p>

<hr>
<a name="Tutorial_002deasy_005fsetopt"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dAbstraction" accesskey="n" rel="next">Tutorial-Abstraction</a>, Previous: <a href="#Tutorial_002dInitializing" accesskey="p" rel="prev">Tutorial-Initializing</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Setting-download-options"></a>
<h3 class="section">4.5 Устновка опций скачивания</h3>

<p>В учебнике к <code>libcurl</code> говориться, что можно установить множество
параметров перед выполнением каких-либо действий по загрузке.  Это делается через
<code>curl_easy_setopt</code>:
</p>
<div class="example">
<pre class="example">CURLcode curl_easy_setopt(CURL *curl, CURLoption option, ...);
</pre></div>

<a name="index-varargs"></a>
<a name="index-foreign-arguments"></a>
<p>Мы входим в новую область: переменные аргументы(variable arguments).  Нет
очевидного перевода формы <code>defcfun</code>, в частности, постокольку
существует четыре возможных типа аргументов.  Благодаря тому, как работает
Си, мы можем определить четыре обертки вокруг <code>curl_easy_setopt</code>, 
по одной для каждого типа; однако, в этом случае, мы будем использовать
универсальный макрос <code>foreign-funcall</code> для вызова этой функции.
</p>
<a name="index-enumeration_002c-C"></a>
<p>Чтобы упростить себе задачу, мы создадим перечисление(перечень вариантов),
которые мы хотим установить.  Перечисление <code>enum CURLoption</code> не 
является самым простым, но чтение макроопределения <code>CINIT</code> Си
должно быть поучительным.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">define-curl-options</span></i> <span class="paren2">(<span class="lisp-bg">name type-offsets &amp;rest enum-args</span>)</span>
    <span class="string">"As with CFFI:DEFCENUM, except each of ENUM-ARGS is as follows:

      (NAME TYPE NUMBER)

  Where the arguments are as they are with the CINIT macro defined
  in curl.h, except NAME is a keyword.

  TYPE-OFFSETS is a plist of TYPEs to their integer offsets, as
  defined by the CURLOPTTYPE_LONG et al constants in curl.h."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">flet</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">enumerated-value <span class="paren5">(<span class="lisp-bg">type offset</span>)</span>
             <span class="paren5">(<span class="lisp-bg">+ <span class="paren6">(<span class="lisp-bg">getf type-offsets type</span>)</span> offset</span>)</span></span>)</span></span>)</span>
      `<span class="paren3">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
         <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> ,name
           ,@<span class="paren5">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for <span class="paren6">(<span class="lisp-bg">name type number</span>)</span> in enum-args
                collect <span class="paren6">(<span class="lisp-bg">list name <span class="paren1">(<span class="lisp-bg">enumerated-value type number</span>)</span></span>)</span></span>)</span></span>)</span>
         ',name</span>)</span></span>)</span></span>)</span>                ;for REPL users' sanity

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-curl-options</span></i> curl-option
      <span class="paren2">(<span class="lisp-bg">long 0 objectpoint 10000 functionpoint 20000 off-t 30000</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:noprogress</span> long 43</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:nosignal</span> long 99</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:errorbuffer</span> objectpoint 10</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:url</span> objectpoint 2</span>)</span></span>)</span>
</pre></div>

<p>С некоторыми Emacs командами: <code>query-replace-regexp</code>, вы вероятно,
могли бы аналогичным образом определить все перечисления <code>CURLoption</code>.
Я выбрал для написания учебника некоторые из них, которые мы будем испольовать
на этом уроке.
</p>
<p>Если у вас возникли проблемы с прочтением макроса, просто разверните 
определение макроса  <code>curl-option</code>, или смотрите следующее
макрорасширенияе, удобно переоформатированное и приведенное в нижний регистр:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> curl-option
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:noprogress</span> 43</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:nosignal</span> 99</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:errorbuffer</span> 10010</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:url</span> 10002</span>)</span></span>)</span>
    'curl-option</span>)</span>
</pre></div>

<p>Это кажется более разумным.  Вы можете заметить, что мы используем тип
(<var>type</var>) только для того чтобы вычислить реальное смещение перечисления;
нам также понадобиться информация о типе позже.
</p>
<p>Однако сначала давайте убедимся, что простой вызов внешней функии
работает:
</p>
<div class="example">
<pre class="example">CFFI-USER&gt; (foreign-funcall "curl_easy_setopt"
               :pointer *easy-handle*
               curl-option :nosignal :long 1 curl-code)
⇒ 0
</pre></div>

<p><code>foreign-funcall</code>, не смотря на свою простоту, может быть
использован для вызова любой Си функции. Его первый аргумент это строка,
в которой указывается имя вызываемой функции. Далее для каждого аргумента
мы передаем имя типа Си, которое совпадает с <code>defcfun</code>, за которым
следует объект Lisp представляющий данные для передачи в качестве аргумента.
Последний аргумент, это тип возвращаемого значения, для которого мы используем
тип <code>curl-code</code>, определенный ранее.
</p>
<p><code>defcfun</code> просто помещает в удобный фасад вызов
<code>foreign-funcall</code>.<a name="DOCF4" href="#FOOT4"><sup>4</sup></a>  
Наш предыдущий вызов <code>curl-global-init</code> мог быть написан следующим
образом:
</p>
<div class="example">
<pre class="example">CFFI-USER&gt; (foreign-funcall "curl_global_init" :long 0
                            curl-code)
⇒ 0
</pre></div>

<p>Прежде, чем мы продолжим, мы посмотрим что  <acronym>CFFI</acronym> может и что не может
сделать, и почему это так.
</p>

<hr>
<a name="Tutorial_002dAbstraction"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dLisp-easy_005fsetopt" accesskey="n" rel="next">Tutorial-Lisp easy_setopt</a>, Previous: <a href="#Tutorial_002deasy_005fsetopt" accesskey="p" rel="prev">Tutorial-easy_setopt</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Breaking-the-abstraction"></a>
<h3 class="section">4.6 Разрушение абстракции</h3>

<a name="index-breaking-the-abstraction"></a>
<a name="index-abstraction-breaking"></a>
<p>В разделе <a href="#Tutorial_002dComparison">Что делает Lisp особенным</a>, 
мы упомянули, что написание <acronym>FFI</acronym> иногда требует зависимости
от инофрмации, не предоставляемой как часть интерфейса.  Простая опция
<code>CURLOPT_WRITEDATA</code>, которую мы не будем предоставлять как часть
интерфейса Lisp, иллюстрирует эту проблему.
</p>
<p>Строго говоря, перечисление <code>curl-option</code> не обязательно; 
мы могли бы использовать <code>:int 99</code> вместо <code>curl-option :nosignal</code> 
в нашем вызове <code>curl_easy_setopt</code> выше.  Мы все равно определели его,
чтобы частично скрыть тот факт, что мы нарушаем абстракцию, которую представляет
собой Си перечисление(<code>enum</code>).  Ели разаработчики
<acronym>URL</acronym> решат изменить эти числа позже, мы должны изменить перечисление
Lisp, потому что значения перечисления не предоставлены в скомпилированной библиотеке Си, 
<code>libcurl.so.3</code>.
</p>
<p><acronym>CFFI</acronym> работает, потому что наиболее полезные вещи в библиотеках Си
нестатические функции и нестатические переменные - доступны в  <code>libcurl.so.3</code>.  
Компилятор Си, который нарушит это, будет считаться бесполезным компилятором.
</p>
<p>Другая цель, которой служит <code>define-curl-options</code> это дать тип
третьему аргументу, передаваемого в <code>curl_easy_setopt</code>.  Используя эту
информацию, мы можем сказать, что опция <code>:nosignal</code> должна принимать длинный
целочисленный аргумент(long integer). Мы можем неявно предполагать, что <code>t</code>
â¡ 1 и <code>nil</code> â¡ 0, как это делает Си. что учитывает тот факт, что
<code>CURLOPT_NOSIGNAL</code> действительно запрашивает логическое значение.
</p>
<p> âТипâ <code>CURLOPT_WRITEDATA</code> является <code>objectpoint</code>.
Тем не менее, он на самом деле указывает на файл <code>FILE*</code>.
<code>CURLOPT_ERRORBUFFER</code> или указывает на символ <code>char*</code>, поэтому нет
очевидного типа <acronym>CFFI</acronym>, кроме указателя<code>:pointer</code>.
</p>
<p>Первое, что нужно отметить, это то, что нигде в интерфейсе Си эта информация
не содержиться; это можно найти только в руководстве. Мы могли бы разделить эти
явно разные типы сами, разделив <code>objectpoint</code> на <code>filepoint</code> и 
<code>charpoint</code>, но мы все равно нарушаем абстркцию, потому что мы должны
дополнить всю форму перечисления этой дополнительной информацией.<a name="DOCF5" href="#FOOT5"><sup>5</sup></a>
</p>
<a name="index-streams-and-C"></a>
<a name="index-FILE_002a-and-streams"></a>
<p>Во вторых, аргумент <code>CURLOPT_WRITEDATA</code> полностью несовместим с требуемыми
Lisp данными, это поток.<a name="DOCF6" href="#FOOT6"><sup>6</sup></a>  Вероятно, это приемлемо, если мы
контролируем каждый файл, который мы можем использовать в качестве этого аргумента, и вэтом случае
мы можем просто вызвать внешнюю функцию <code>fopen</code>.  Тем не менее, несмотря на это,
мы не можем писать в произвольные потоки, что мы хотим сделать для этого приложения.
</p>
<p>Наконец, обратите внимание, что сам интерфейс <code>curl_easy_setopt</code> является хаком,
предназначенным для обхода некоторых недостатков языка Си.  Определение
<code>Curl_setopt</code>, хотя и long, гораздо меньше загромождено, чем эквивалентный набор
дизъюнктивных функци; Кроме того, установка новой опции в старом <code>libcurl</code> 
может генерировать ошибку во время выполнения, а не прерывать компиляцию.  Lispможет так же
кратко генерировать функции, как сравнивать значения и ошибка  âundefined functionâ
так же полезна, как и любая явная ошибка, которую мы здесь можем определить.
</p>

<hr>
<a name="Tutorial_002dLisp-easy_005fsetopt"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dMemory" accesskey="n" rel="next">Tutorial-Memory</a>, Previous: <a href="#Tutorial_002dAbstraction" accesskey="p" rel="prev">Tutorial-Abstraction</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Option-functions-in-Lisp"></a>
<h3 class="section">4.7 Опции функций в Lisp</h3>

<p>Мы можем использовать <code>foreign-funcall</code> напрямую, каждый раз, когда хотим
вызывать <code>curl_easy_setopt</code>.  Однако, мы можем инкапсулировать некоторую необходимую
информацию информацию следующим образом.
</p>
<div class="lisp">
<pre class="lisp">  <span class="comment">;;; We will use this type later in a more creative way.  For
  </span><span class="comment">;;; now, just consider it a marker that this isn't just any
  </span><span class="comment">;;; pointer.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> easy-handle <span class="keyword">:pointer</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmacro</span></i> curl-easy-setopt <span class="paren2">(<span class="lisp-bg">easy-handle enumerated-name
                              value-type new-value</span>)</span>
    <span class="string">"Call `curl_easy_setopt' on EASY-HANDLE, using ENUMERATED-NAME
  as the OPTION.  VALUE-TYPE is the CFFI foreign type of the third
  argument, and NEW-VALUE is the Lisp data to be translated to the
  third argument.  VALUE-TYPE is not evaluated."</span>
    `<span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"curl_easy_setopt"</span> easy-handle ,easy-handle
                      curl-option ,enumerated-name
                      ,value-type ,new-value curl-code</span>)</span></span>)</span>
</pre></div>

<p>Теперь мы определили функцию для каждого типа аргумента, которая кодирует
правильный тип значения(<code>value-type</code>).  Разумнее это сделать с помощью
макроопределения в <code>define-curl-options</code>; В конце концов, именно здесь
перечислены различные опции!
</p>
<a name="index-Lispy-C-functions"></a>
<p>Мы можем создать форму <code>cl:defun</code> в расширении просто вызвав
<code>curl-easy-setopt</code>; Однако, вероятно, проще и понятнее спользовать
<code>defcfun</code>.  <code>define-curl-options</code> становиться громоздким,
поэтому я определил несколько помощников в этом новом определении.
</p>
<div class="smalllisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> curry-curl-option-setter <span class="paren2">(<span class="lisp-bg">function-name option-keyword</span>)</span>
    <span class="string">"Wrap the function named by FUNCTION-NAME with a version that
  curries the second argument as OPTION-KEYWORD.

  This function is intended for use in DEFINE-CURL-OPTION-SETTER."</span>
    <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">symbol-function function-name</span>)</span>
            <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren4">(<span class="lisp-bg"><span class="paren5">(<span class="lisp-bg">c-function <span class="paren6">(<span class="lisp-bg">symbol-function function-name</span>)</span></span>)</span></span>)</span>
              <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="lisp-bg">easy-handle new-value</span>)</span>
                <span class="paren5">(<span class="lisp-bg">funcall c-function easy-handle option-keyword
                         new-value</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">define-curl-option-setter</span></i> <span class="paren2">(<span class="lisp-bg">name option-type
                                       option-value foreign-type</span>)</span>
    <span class="string">"Define (with DEFCFUN) a function NAME that calls
  curl_easy_setopt.  OPTION-TYPE and OPTION-VALUE are the CFFI
  foreign type and value to be passed as the second argument to
  easy_setopt, and FOREIGN-TYPE is the CFFI foreign type to be used
  for the resultant function's third argument.

  This macro is intended for use in DEFINE-CURL-OPTIONS."</span>
    `<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
       <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="paren4">(<span class="lisp-bg"><span class="string">"curl_easy_setopt"</span> ,name</span>)</span> curl-code
         <span class="paren4">(<span class="lisp-bg">easy-handle easy-handle</span>)</span>
         <span class="paren4">(<span class="lisp-bg">option ,option-type</span>)</span>
         <span class="paren4">(<span class="lisp-bg">new-value ,foreign-type</span>)</span></span>)</span>
       <span class="paren3">(<span class="lisp-bg">curry-curl-option-setter ',name ',option-value</span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">define-curl-options</span></i> <span class="paren2">(<span class="lisp-bg">type-name type-offsets &amp;rest enum-args</span>)</span>
    <span class="string">"As with CFFI:DEFCENUM, except each of ENUM-ARGS is as follows:

      (NAME TYPE NUMBER)

  Where the arguments are as they are with the CINIT macro defined
  in curl.h, except NAME is a keyword.

  TYPE-OFFSETS is a plist of TYPEs to their integer offsets, as
  defined by the CURLOPTTYPE_LONG et al constants in curl.h.

  Also, define functions for each option named
  set-`TYPE-NAME'-`OPTION-NAME', where OPTION-NAME is the NAME from
  the above destructuring."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">flet</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">enumerated-value <span class="paren5">(<span class="lisp-bg">type offset</span>)</span>
             <span class="paren5">(<span class="lisp-bg">+ <span class="paren6">(<span class="lisp-bg">getf type-offsets type</span>)</span> offset</span>)</span></span>)</span>
           <span class="comment">;; map PROCEDURE, destructuring each of ENUM-ARGS
  </span>         <span class="paren4">(<span class="lisp-bg">map-enum-args <span class="paren5">(<span class="lisp-bg">procedure</span>)</span>
             <span class="paren5">(<span class="lisp-bg">mapcar <span class="paren6">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren1">(<span class="lisp-bg">arg</span>)</span> <span class="paren1">(<span class="lisp-bg">apply procedure arg</span>)</span></span>)</span> enum-args</span>)</span></span>)</span>
           <span class="comment">;; build a name like SET-CURL-OPTION-NOSIGNAL
  </span>         <span class="paren4">(<span class="lisp-bg">make-setter-name <span class="paren5">(<span class="lisp-bg">option-name</span>)</span>
             <span class="paren5">(<span class="lisp-bg">intern <span class="paren6">(<span class="lisp-bg">concatenate
                      'string <span class="string">"SET-"</span> <span class="paren1">(<span class="lisp-bg">symbol-name type-name</span>)</span>
                      <span class="string">"-"</span> <span class="paren1">(<span class="lisp-bg">symbol-name option-name</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
      `<span class="paren3">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
         <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> ,type-name
           ,@<span class="paren5">(<span class="lisp-bg">map-enum-args
              <span class="paren6">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren1">(<span class="lisp-bg">name type number</span>)</span>
                <span class="paren1">(<span class="lisp-bg">list name <span class="paren2">(<span class="lisp-bg">enumerated-value type number</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
         ,@<span class="paren4">(<span class="lisp-bg">map-enum-args
            <span class="paren5">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren6">(<span class="lisp-bg">name type number</span>)</span>
              <span class="paren6">(<span class="lisp-bg">declare <span class="paren1">(<span class="lisp-bg">ignore number</span>)</span></span>)</span>
              `<span class="paren6">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> ,<span class="paren1">(<span class="lisp-bg">make-setter-name name</span>)</span>
                 ,type-name ,name ,<span class="paren1">(<span class="lisp-bg">ecase type
                                     <span class="paren2">(<span class="lisp-bg">long <span class="keyword">:long</span></span>)</span>
                                     <span class="paren2">(<span class="lisp-bg">objectpoint <span class="keyword">:pointer</span></span>)</span>
                                     <span class="paren2">(<span class="lisp-bg">functionpoint <span class="keyword">:pointer</span></span>)</span>
                                     <span class="paren2">(<span class="lisp-bg">off-t <span class="keyword">:long</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
         ',type-name</span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Макрорасширение нашей формы <code>define-curl-options</code> еще раз, мы видим, некоторые
отличия:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> curl-option
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:noprogress</span> 43</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:nosignal</span> 99</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:errorbuffer</span> 10010</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:url</span> 10002</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> set-curl-option-noprogress
      curl-option <span class="keyword">:noprogress</span> <span class="keyword">:long</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> set-curl-option-nosignal
      curl-option <span class="keyword">:nosignal</span> <span class="keyword">:long</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> set-curl-option-errorbuffer
      curl-option <span class="keyword">:errorbuffer</span> <span class="keyword">:pointer</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> set-curl-option-url
      curl-option <span class="keyword">:url</span> <span class="keyword">:pointer</span></span>)</span>
    'curl-option</span>)</span>
</pre></div>

<p>Макрорасширение одной из новых форм <code>define-curl-option-setter</code>
дает следующее:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="paren3">(<span class="lisp-bg"><span class="string">"curl_easy_setopt"</span> set-curl-option-nosignal</span>)</span> curl-code
      <span class="paren3">(<span class="lisp-bg">easy-handle easy-handle</span>)</span>
      <span class="paren3">(<span class="lisp-bg">option curl-option</span>)</span>
      <span class="paren3">(<span class="lisp-bg">new-value <span class="keyword">:long</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">curry-curl-option-setter 'set-curl-option-nosignal '<span class="keyword">:nosignal</span></span>)</span></span>)</span>
</pre></div>

<p>Наконец, давайте просто попробуем это:
</p>
<div class="example">
<pre class="example">CFFI-USER&gt; (set-curl-option-nosignal *easy-handle* 1)
⇒ 0
</pre></div>

<p>Похоже, это работает также хорошо.  Этот интерфейс теперь достаточно высокоуровневый, чтобы
скрыть некоторые недостатки и тонкости <acronym>FFI</acronym> для  
<code>curl_easy_setopt</code> , не скрывая оставшиеся детали Си интерфейса, которые 
мы исследуем.
</p>

<hr>
<a name="Tutorial_002dMemory"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dCallbacks" accesskey="n" rel="next">Tutorial-Callbacks</a>, Previous: <a href="#Tutorial_002dLisp-easy_005fsetopt" accesskey="p" rel="prev">Tutorial-Lisp easy_setopt</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Memory-management"></a>
<h3 class="section">4.8 Управление памятью</h3>

<p>Согласно документации для <code>curl_easy_setopt</code>, тип третьего аргумента,
когда опция(<var>option</var>) имеет  значение <code>CURLOPT_ERRORBUFFER</code>
это <code>char*</code>.  Выше мы определили <code>set-curl-option-errorbuffer</code> 
для принятия указателя <code>:pointer</code> в качестве значения нового параметра.  
Однако, существует <acronym>CFFI</acronym> тип <code>:string</code>,
который переводит строки Lisp в строки C, когда они передаются в качестве аргументов
для вызова внешних функций.  Тогда почему бы не использовать <code>:string</code> в
качестве типа <acronym>CFFI</acronym> для третьего аргумента?  Есть две причины, и обе
связаны с необходиостью нарушения абстракции, описанной в разделе
<a href="#Tutorial_002dAbstraction">Нарушение абстракции</a>.
</p>
<p>Первая причина также относится к <code>CURLOPT_URL</code>, который мы будем
использовать, чтобы проилюстрировать этот момент.  Предположим, что мы изменили тип
третьего аргумента, лежащего в основе <code>set-curl-option-url</code> на 
<code>:string</code>, рассмотрим эти две эквивалентные формы.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">set-curl-option-url <span class="special">*easy-handle*</span> <span class="string">"http://www.cliki.net/CFFI"</span></span>)</span>

  &amp;equiv; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">url <span class="string">"http://www.cliki.net/CFFI"</span></span>)</span>
       <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"curl_easy_setopt"</span> easy-handle <span class="special">*easy-handle*</span>
                        curl-option <span class="keyword">:url</span> <span class="keyword">:pointer</span> url curl-code</span>)</span></span>)</span>
</pre></div>

<p>Последняя, на самом деле, в основном эквивалентно тому, что на самом деле делает
макрорасширение  вызова внешней функции.  Как видите, строка Lisp 
<code>"http://www.cliki.net/CFFI"</code> копируется в массив <code>char</code> и
заканчивается нулевым символом(null-terminated); указатель на начало этого массива, 
теперь это строка Си, передаваемая как <acronym>CFFI</acronym> <code>:pointer</code> во
внешнюю функцию.
</p>
<a name="index-dynamic-extent"></a>
<a name="index-foreign-values-with-dynamic-extent"></a>
<p>К сожалению, Си абстракция подвела нас, и мы должны её нарушить! Хотя 
<code>:string</code> хорошо работает для многих <code>char*</code> аргументов, она
не подходит для случаев, подобных этому.  Как объясняется в документациии по 
<code>curl_easy_setopt</code>, âСтрока должна оставаться в наличии до тех пор, пока
нужен curl, поскольку она не копируется.â  Однако, Си строкаа, созданная с помощью
<code>with-foreign-string</code>, существует только в динамическом пространстве
выполняемого блока кода(dynamic extent): т.е она будет уничтожена (âdeallocatedâ) когда управление
покинет тело формы(выше, содержащее вызов формы <code>foreign-funcall</code>).
</p>
<a name="index-premature-deallocation"></a>
<p>Если мы должны хранить строку Си, а она исчезнет, что произойдет, когда
какая либо функция <code>libcurl</code> попробует получить доступ к строке
<acronym>URL</acronym>?  Мы вернулись в страшный мир Си
â(повдение не определено)undefined behaviorâ.  В некоторых Лиспах, он
вероятно получит кусок стека Lisp/C.  Возможно ошибку сегментации.  Вы можете
получить некоторую слчайную часть других данных из кучи.  Может, быть в мире,
где âдинамическое пространство выполняемого блока(dynamic
extent)â определяется как âбесконечное пространство/бесконечное время жизни
локальных привязок(infinite extent)â, все и будет хорошо.  Несмотря на это,
результаты, вероятно, повсеместно будут неприятными.
<a name="DOCF7" href="#FOOT7"><sup>7</sup></a>
</p>
<p>Вернемся к текущему интерфейсу <code>set-curl-option-url</code>, вот что мы
должны сделать:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg">easy-handle</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">unwind-protect</span></i>
      <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren4">(<span class="lisp-bg">url <span class="string">"http://www.cliki.net/CFFI"</span></span>)</span>
        <span class="paren4">(<span class="lisp-bg">setf easy-handle <span class="paren5">(<span class="lisp-bg">curl-easy-init</span>)</span></span>)</span>
        <span class="paren4">(<span class="lisp-bg">set-curl-option-url easy-handle url</span>)</span>
        <span class="comment">#|do more with the easy-handle, like actually get the URL|#</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">when easy-handle
        <span class="paren4">(<span class="lisp-bg">curl-easy-cleanup easy-handle</span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Это хорошо для единственной строки, определенной здесь, но для каждой
строковой опции, которую мы хотим передать, мы должны окружить тело кода
<code>with-foreign-string</code> другой оберткой <code>with-foreign-string</code>, 
или создать некоторый чрезвычайно подверженный ошибкам указатель с расчетом
размеров заранее.  Мы могли бы облегчить некоторые проблемы с помощью рекурсивно
расширяющегося макроса, но это не избавило бы от необходимости изменять блок
каждый раз, когда мы хотим добавить опцию, анафему, как она есть в модульном
интерфейсе.
</p>
<p>Прежде чем изменять код для учета этого случая, рассмотрим другую причину,
по которой мы не можем просто использовать <code>:string</code> в качестве внешнего
типа.  В Си, <code>char *</code> это <code>char *</code>, не обязательно строка.  
Опция <code>CURLOPT_ERRORBUFFER</code> принимает <code>char *</code>, но ничего не ожидает
от данных из нее.  Тем не менее, она ожидает, что некоторая функция
<code>libcurl</code>, которую мы вызовем позже, может записать туда Си строку длиной до
255 символов.  Ожидается, что мы, вызывающие эту функцию, будем читать Си строку позднее,
что прямо противоположно тому, что подразумевает тип <code>:string</code>.
</p>
<p>Имея в виду семантику входной строки, а именно то, что строка должна храниться до тех пор,
пока мы не закроем дескриптор используя <code>curl_easy_cleanup</code>, мы
готовы к тому, чтобы расширитьт интерфейс Lisp:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defvar</span></i> <span class="special">*easy-handle-cstrings*</span> <span class="paren2">(<span class="lisp-bg">make-hash-table</span>)</span>
    <span class="string">"Hashtable of easy handles to lists of C strings that may be
  safely freed after the handle is freed."</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> make-easy-handle <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="string">"Answer a new CURL easy interface handle, to which the lifetime
  of C strings may be tied.  See `add-curl-handle-cstring'."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">easy-handle <span class="paren5">(<span class="lisp-bg">curl-easy-init</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">gethash easy-handle <span class="special">*easy-handle-cstrings*</span></span>)</span> '<span class="paren4">(<span class="lisp-bg"></span>)</span></span>)</span>
      easy-handle</span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> free-easy-handle <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Free CURL easy interface HANDLE and any C strings created to
  be its options."</span>
    <span class="paren2">(<span class="lisp-bg">curl-easy-cleanup handle</span>)</span>
    <span class="paren2">(<span class="lisp-bg">mapc #'foreign-string-free
          <span class="paren3">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">remhash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> add-curl-handle-cstring <span class="paren2">(<span class="lisp-bg">handle cstring</span>)</span>
    <span class="string">"Add CSTRING to be freed when HANDLE is, answering CSTRING."</span>
    <span class="paren2">(<span class="lisp-bg">car <span class="paren3">(<span class="lisp-bg">push cstring <span class="paren4">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Здесь мы переопределяем интерфейс для создания и освобождения дескрипторов.,
чтобы связать список выделенных Си строк с каждым рабочим дескриптором, до тех
пор пока он существует.  Стратегия использования различных имен функций для
окружения простых внешний функций встречается чаще, чем решение, реализованное
ранее с помощью <code>curry-curl-option-setter</code>, которая должна была изменить
слот функции именем функции.<a name="DOCF8" href="#FOOT8"><sup>8</sup></a>
</p>
<p>Кстати, следующим шагом является переопределение <code>curry-curl-option-setter</code> 
для выделения Си строк на соответствующий отрезок времени, учитывая строку Lisp в
качестве аргумента <code>new-value</code>:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> curry-curl-option-setter <span class="paren2">(<span class="lisp-bg">function-name option-keyword</span>)</span>
    <span class="string">"Wrap the function named by FUNCTION-NAME with a version that
  curries the second argument as OPTION-KEYWORD.

  This function is intended for use in DEFINE-CURL-OPTION-SETTER."</span>
    <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">symbol-function function-name</span>)</span>
            <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren4">(<span class="lisp-bg"><span class="paren5">(<span class="lisp-bg">c-function <span class="paren6">(<span class="lisp-bg">symbol-function function-name</span>)</span></span>)</span></span>)</span>
              <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="lisp-bg">easy-handle new-value</span>)</span>
                <span class="paren5">(<span class="lisp-bg">funcall c-function easy-handle option-keyword
                         <span class="paren6">(<span class="lisp-bg"><i><span class="symbol">if</span></i> <span class="paren1">(<span class="lisp-bg">stringp new-value</span>)</span>
                           <span class="paren1">(<span class="lisp-bg">add-curl-handle-cstring
                            easy-handle
                            <span class="paren2">(<span class="lisp-bg">foreign-string-alloc new-value</span>)</span></span>)</span>
                           new-value</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Быстрый анализ кода показывает, что нам нужно только пересмотреть определение
перечисления <code>curl-option</code>, чтобы воспользоваться преимуществами этой
новой семантики.  Теперь, для хорошей проверки, давайте перераспределим дескриптор
с использованием новых функций, которые мы только что определили, и установим
с их помощью <acronym>URL</acronym>:
</p>
<div class="example">
<pre class="example">CFFI-USER&gt; (curl-easy-cleanup *easy-handle*)
⇒ NIL
CFFI-USER&gt; (setf *easy-handle* (make-easy-handle))
⇒ #&lt;FOREIGN-ADDRESS #x09844EE0&gt;
CFFI-USER&gt; (set-curl-option-nosignal *easy-handle* 1)
⇒ 0
CFFI-USER&gt; (set-curl-option-url *easy-handle*
                                "http://www.cliki.net/CFFI")
⇒ 0
</pre></div>

<a name="index-strings"></a>
<p>Для интереса, давайте проверим значение Lisp строки Си, которая была создана для
хранения <code>"http://www.cliki.net/CFFI"</code>.  Благодаря реализации
<code>add-curl-handle-cstring</code>, оно должно быть доступно через определенную
хеш-таблицу:
</p>
<div class="example">
<pre class="example">CFFI-USER&gt; (foreign-string-to-lisp
            (car (gethash *easy-handle* *easy-handle-cstrings*)))
⇒ "http://www.cliki.net/CFFI"
</pre></div>

<p>Похоже, это работает, и теперь <code>libcurl</code> знает, какой
<acronym>URL</acronym> мы хотим получить.
</p>
<p>Наконец, мы возвращаемся к опции <code>:errorbuffer</code>, упомянутой в начале
этого раздела.  Принимая во внимание, что абстракция добавлена для поддержки
входной строки, отлично работающая для случаев подобных <code>CURLOPT_URL</code>, она
скрывает детали сохранения стороки Си; однако и для <code>:errorbuffer</code>,
нам необходима подобная Си строка.
</p>
<p>Через мгновение, мы определим что-то немного более чистое, но пока помните,
что вы всегда сможете это поменять.  Мы модифицируем создание дескрипторов,
поэтому перед повторным определением <code>free-easy-handle</code>, вы должны
освободить старый дескриптор.
</p>
<div class="smalllisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defvar</span></i> <span class="special">*easy-handle-errorbuffers*</span> <span class="paren2">(<span class="lisp-bg">make-hash-table</span>)</span>
    <span class="string">"Hashtable of easy handles to C strings serving as error
  writeback buffers."</span></span>)</span>

  <span class="comment">;;; An extra byte is very little to pay for peace of mind.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defparameter</span></i> <span class="special">*curl-error-size*</span> 257
    <span class="string">"Minimum char[] size used by cURL to report errors."</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> make-easy-handle <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="string">"Answer a new CURL easy interface handle, to which the lifetime
  of C strings may be tied.  See `add-curl-handle-cstring'."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">easy-handle <span class="paren5">(<span class="lisp-bg">curl-easy-init</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">gethash easy-handle <span class="special">*easy-handle-cstrings*</span></span>)</span> '<span class="paren4">(<span class="lisp-bg"></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">gethash easy-handle <span class="special">*easy-handle-errorbuffers*</span></span>)</span>
              <span class="paren4">(<span class="lisp-bg">foreign-alloc <span class="keyword">:char</span> <span class="keyword">:count</span> <span class="special">*curl-error-size*</span>
                             <span class="keyword">:initial-element</span> 0</span>)</span></span>)</span>
      easy-handle</span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> free-easy-handle <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Free CURL easy interface HANDLE and any C strings created to
  be its options."</span>
    <span class="paren2">(<span class="lisp-bg">curl-easy-cleanup handle</span>)</span>
    <span class="paren2">(<span class="lisp-bg">foreign-free <span class="paren3">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-errorbuffers*</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">remhash handle <span class="special">*easy-handle-errorbuffers*</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">mapc #'foreign-string-free
          <span class="paren3">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">remhash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> get-easy-handle-error <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Answer a string containing HANDLE's current error message."</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-to-lisp
     <span class="paren3">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-errorbuffers*</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Не забудьте еще раз установить параметры, которые мы устанавливали до сих пор.
Вы можете определить еще одну функцию обертку для этого.
</p>

<hr>
<a name="Tutorial_002dCallbacks"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dCompletion" accesskey="n" rel="next">Tutorial-Completion</a>, Previous: <a href="#Tutorial_002dMemory" accesskey="p" rel="prev">Tutorial-Memory</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Calling-Lisp-from-C"></a>
<h3 class="section">4.9 Вызов Lisp из Си</h3>

<p>Если вы читали 
<a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html"><code>curl_easy_setopt(3)</code></a>, 
вы должны были заметить, что некоторые опции принимают указатель на функцию. В частности,
нам нужен один указатель на функцию  <code>CURLOPT_WRITEFUNCTION</code>, который вызывается из
<code>libcurl</code>, а не наоборот, чтобы получать данные по мере их загрузки.
</p>
<p>Автор биндинга без помощи  <acronym>FFI</acronym> обычно подходит к этой проблеме,
написав функцию Си, которая принимает данные Си, конвертирует их во внутренние объекты
языка и вызывает обратный вызов, предоставленный пользователем, опять же в противоположность
обычной практике.
</p>
<p>Подход <acronym>CFFI</acronym> к обратным вызовам точно отражает его различия с
подходом не-<acronym>FFI</acronym> в части âВызовов Си из Lispâ, 
который мы рассматривали до сих пор.  То есть, вы определяете функцию обратного вызова
в Lisp используя <code>defcallback</code>, и <acronym>CFFI</acronym> эффективно создает
функцию Си, которая будет передана как указатель на функцию.
</p>
<blockquote>
<p><strong>Примечание разработчика:</strong> <em>это на много сложнее, чем вызвать
Си функцию из Lisp, так как буквально включает в себя как-то генерацию новой функции
Си, которая так же хороша, как и любая другая, созданная компилятором. Поэтому не все
Lisp-ы их поддерживают.  См. <a href="#Implementation-Support">Поддерживаемые Реализации</a>, 
для получения информации о проблемах поддержки <acronym>CFFI</acronym>
в этой и других областях. Возможно, вы захотите перейти на Lisp который поддерживает обратные
вызовы, чтобы продолжить это обучение.</em>
</p></blockquote>

<a name="index-callback-definition"></a>
<a name="index-defining-callbacks"></a>
<p>Определение обратного вызова очень похоже на определение исходящего
вызова; Основное отличие состоит в том, что мы должны предоставить некоторые
формы Lisp для вычисления, как часть обратного вызова. Вот шаблон для функции,
которую принимает опция <code>:writefunction</code>:
</p>
<div class="example">
<pre class="example">size_t
<var>function</var>(void *ptr, size_t size, size_t nmemb, void *stream);
</pre></div>

<blockquote>
<p><strong>Примечание разработчика:</strong> <em>size_t почти всегда это unsigned int.  Вы можете получить
этот и многие другие типы, используя функциональные тесты для вашей системы, используя 
cffi-grovel.</em>
</p></blockquote>

<p>Приведенный выше шаблон элементарно переводится в <acronym>CFFI</acronym> форму
<code>defcallback</code>, следующим образом.
</p>
<div class="lisp">
<pre class="lisp">  <span class="comment">;;; Alias in case size_t changes.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> size <span class="keyword">:unsigned-int</span></span>)</span>

  <span class="comment">;;; To be set as the CURLOPT_WRITEFUNCTION of every easy handle.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcallback</span></i> easy-write size <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">ptr <span class="keyword">:pointer</span></span>)</span> <span class="paren3">(<span class="lisp-bg">size size</span>)</span>
                                <span class="paren3">(<span class="lisp-bg">nmemb size</span>)</span> <span class="paren3">(<span class="lisp-bg">stream <span class="keyword">:pointer</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">data-size <span class="paren5">(<span class="lisp-bg">* size nmemb</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">handler-case
        <span class="comment">;; We use the dynamically-bound *easy-write-procedure* to
  </span>      <span class="comment">;; call a closure with useful lexical context.
  </span>      <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">progn</span></i> <span class="paren5">(<span class="lisp-bg">funcall <span class="paren6">(<span class="lisp-bg">symbol-value '<span class="special">*easy-write-procedure*</span></span>)</span>
                        <span class="paren6">(<span class="lisp-bg">foreign-string-to-lisp ptr <span class="keyword">:count</span> data-size</span>)</span></span>)</span>
               data-size</span>)</span>         <span class="comment">;indicates success
  </span>      <span class="comment">;; The WRITEFUNCTION should return something other than the
  </span>      <span class="comment">;; #bytes available to signal an error.
  </span>      <span class="paren4">(<span class="lisp-bg">error <span class="paren5">(<span class="lisp-bg"></span>)</span> <span class="paren5">(<span class="lisp-bg"><i><span class="symbol">if</span></i> <span class="paren6">(<span class="lisp-bg">zerop data-size</span>)</span> 1 0</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Во первых, обратите внимание, на корреляцию первых нескольких форм, используемых
для объявления Си функции шаблона, с шаблоном в Си синтаксисе.  Мы предоставляем
имя Lisp для функции, ее возвращаемый тип, а также имя и тип для каждого аргумента.
</p>
<p>В теле мы вызываем динамически связанную  процедуру 
<code>*easy-write-procedure*</code> с âокончательнойâ обработкой, которая
объединяет необработанные данные и их размер в строку Lisp, а не обрабатывает
данные напрямую.  Как часть вызова <code>curl_easy_perform</code> позже, мы свяжем
эту переменную с замыканием с более полезными лексическими привязками, чем
форма верхнего уровня <code>defcallback</code>.
</p>
<p>Наконец, мы прилагаем небольшие усилия, чтобы предотвратить выход из
разматываемого(unwinding) стека Си, закрывая наиболее вероятный случай с 
помощью обработчика ошибок <code>error</code>, который обычно запускается неожиданно.
<a name="DOCF9" href="#FOOT9"><sup>9</sup></a>  Причина в том, что большая часть кода
Си написана так, чтобы понимать свое собственное уникальное условие ошибки, реализованное
выше в случае <code>curl_easy_perform</code>, и далее âнеопределенное поведение(undefined behavior)â
может привести к тому, что мы просто сотрём кадры стека Си, не позволяя им выполнить какие либо действия
по очистке, которые им необходимо выполнять.
</p>
<p>Используя перечисление <code>CURLoption</code> в <samp>curl.h</samp> еще раз, мы
можем описать новую опцию, изменив и пересчитав
<code>define-curl-options</code>.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-curl-options</span></i> curl-option
      <span class="paren2">(<span class="lisp-bg">long 0 objectpoint 10000 functionpoint 20000 off-t 30000</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:noprogress</span> long 43</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:nosignal</span> long 99</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:errorbuffer</span> objectpoint 10</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:url</span> objectpoint 2</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:writefunction</span> functionpoint 11</span>)</span></span>)</span> ;new item here
</pre></div>

<p>Наконец мы можем использовать определенный обратный вызов и новую 
<code>set-curl-option-writefunction</code> для завершения настройки
простого дескриптора, используя макрос <code>callback</code> для получения
<acronym>CFFI</acronym> <code>:pointer</code>, который работает как указатель
на функцию в коде Си.
</p>
<div class="example">
<pre class="example">CFFI-USER&gt; (set-curl-option-writefunction
            *easy-handle* (callback easy-write))
⇒ 0
</pre></div>

<hr>
<a name="Tutorial_002dCompletion"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dTypes" accesskey="n" rel="next">Tutorial-Types</a>, Previous: <a href="#Tutorial_002dCallbacks" accesskey="p" rel="prev">Tutorial-Callbacks</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="A-complete-FFI_003f"></a>
<h3 class="section">4.10 Полный <acronym>FFI</acronym>?</h3>

<p>После окончательной настройки всех параметров и разработки интерфейса промежуточного уровя мы можем
завершить определение и получить
<a href="http://www.cliki.net/CFFI">http://www.cliki.net/CFFI</a>, как это делается в учебном курсе.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"curl_easy_perform"</span> curl-code
    <span class="paren2">(<span class="lisp-bg">handle easy-handle</span>)</span></span>)</span>
</pre></div>

<div class="example">
<pre class="example">CFFI-USER&gt; (with-output-to-string (contents)
             (let ((*easy-write-procedure*
                     (lambda (string)
                       (write-string string contents))))
               (declare (special *easy-write-procedure*))
               (curl-easy-perform *easy-handle*)))
⇒ "&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"
...
Now fear, comprehensively&lt;/P&gt;
"
</pre></div>

<p>Конечно, это само по себе немного громоздко, поэтому вы можете захотеть
определить функцию вокруг этого, которая просто получает <acronym>URL</acronym>.  
Я оставлю обобщение всех соответствующих форм <acronym>REPL</acronym>, представленых
до сих пор, в единую функцию в качестве упражнения для читателя.
</p>
<p>В остальных разделах этого руководства рассматриваются некоторые рассширенные
функции <acronym>CFFI</acronym>; определению новых типов будет уделено особое
внимание.  Некоторые из этих функций важны для вызовов определенных внешних
функций; некоторые очень полезны при разработке Lisp интерфейса к Си.
</p>

<hr>
<a name="Tutorial_002dTypes"></a>
<div class="header">
<p>
Next: <a href="#Tutorial_002dConclusion" accesskey="n" rel="next">Tutorial-Conclusion</a>, Previous: <a href="#Tutorial_002dCompletion" accesskey="p" rel="prev">Tutorial-Completion</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Defining-new-types"></a>
<h3 class="section">4.11 Определение новых типов</h3>

<p>В предыдущих разделах, мы иногда использовали макрос <code>defctype</code>, как
своего рода документацию, это во многом то, что вы делали используя <code>typedef</code>
в коде Си. Мы также попробовали одино особое определение типа <code>defcenum</code>.  
См. <a href="#defcstruct">defcstruct</a>, для определения макроса, который может
пригодиться, если вам нужно использовать Си структуры(<code>struct</code>) в качестве данных.
</p>
<a name="index-type-definition"></a>
<a name="index-data-in-Lisp-and-C"></a>
<a name="index-translating-types"></a>
<p>Тем не менее, все это в основном "синтаксический сахар" для мощного
базового интерфейса внешних типов, называемого <em>преобразователем типов(type translators)</em>.
Вы можете легко определить новые преобразователи для любого простого
именованного внешнего типа.  Поскольку мы определили новый тип <code>curl-code</code> 
используемый в качестве возвращаемого типа для различных функций <code>libcurl</code>,
мы можем использовать его для непосредственного преобразования ошибок
<acronym>URL</acronym> в ошибки Lisp.
</p>
<p>Целью <code>defctype</code> является определение простых <code>typedef</code>-подобных
псевдонимов.  Чтобы использовать <em>преобразователи типов(type translators)</em> мы должны
использовать макрос <code>define-foreign-type</code>.  Итак, давайте переопределим
 <code>curl-code</code> используя этот макрос.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> curl-code-type <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:actual-type</span> <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:simple-parser</span> curl-code</span>)</span></span>)</span>
</pre></div>

<p><code>define-foreign-type</code> это тонкая обертка вокруг <code>defclass</code>.
На данный момент все, что вам нужно знать в контексте этого примера, это то, что
он делает что будет делать <code>(defctype curl-code :int)</code>, и кроме того,
определяет новый класс <code>curl-code-type</code>, которым мы вскоре воспользуемся.
</p>
<p>Перечисление <code>CURLcode</code> по видимому, следует типичному соглашению о
кодах ошибки: â<samp>0</samp>â означает, что все в порядке, и каждое не
нулевое целое число указывает на различный тип ошибок.  Применять его
очень просто, чтобы различать нормальные выходы и выходы с ошибками.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-condition</span></i> curl-code-error <span class="paren2">(<span class="lisp-bg">error</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">$code <span class="keyword">:initarg</span> <span class="keyword">:curl-code</span> <span class="keyword">:reader</span> curl-error-code</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:report</span> <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren4">(<span class="lisp-bg">c stream</span>)</span>
               <span class="paren4">(<span class="lisp-bg">format stream <span class="string">"libcurl function returned error ~A"</span>
                              <span class="paren5">(<span class="lisp-bg">curl-error-code c</span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:documentation</span> <span class="string">"Signalled when a libcurl function answers
  a code other than CURLE_OK."</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-from-foreign <span class="paren2">(<span class="lisp-bg">value <span class="paren3">(<span class="lisp-bg">type curl-code-type</span>)</span></span>)</span>
    <span class="string">"Raise a CURL-CODE-ERROR if VALUE, a curl-code, is non-zero."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">if</span></i> <span class="paren3">(<span class="lisp-bg">zerop value</span>)</span>
        <span class="keyword">:curle-ok</span>
        <span class="paren3">(<span class="lisp-bg">error 'curl-code-error <span class="keyword">:curl-code</span> value</span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Сердцем этого нового преобразователя является новый метод
<code>translate-from-foreign</code>.  Указывая параметр <var>type</var>
равный <code>curl-code-type</code>, мы немедленно модифицируем поведение каждой
функции, которая возвращает <code>curl-code</code> чтобы передать результат
через этот новый метод.
</p>
<p>Чтобы увидеть преобразователь в действии, попробуйте вызвать функцию, которая 
возвращает <code>curl-code</code>.  Вам необходимо пересчитать соответствующую
форму <code>defcfun</code>, чтобы она восприняла новое определение <code>curl-code</code>.
</p>
<div class="example">
<pre class="example">CFFI-USER&gt; (set-curl-option-nosignal *easy-handle* 1)
⇒ :CURLE-OK
</pre></div>

<p>В результае был получен â<samp>0</samp>â, новый метод возвратил <code>:curle-ok</code>,
как это было указано.<a name="DOCF10" href="#FOOT10"><sup>10</sup></a>  Я оставлю разделение отдельных
<code>CURLcode</code> на типы условий и улучшение функции <code>:report</code>
как упражнение для вас.
</p>
<p>Создание <code>*easy-handle-cstrings*</code> и
<code>*easy-handle-errorbuffers*</code> в качестве свойств <code>easy-handle</code>s
является ключевым моментом.  Что нам действительно нужно, так это структура Lisp, которая
хранит эти свойства вместе с указателем Си.  К сожалению,
<code>easy-handle</code> в настоящее время является просто причудливым именем для внешнего
типа <code>:pointer</code>; фактический объект указатель варьируется от одной реализации
Лиспа к другой, и он должен удовлетвроять предикату <code>pointerp</code> и быть
возвращаемым из <code>make-pointer</code> и его друзей.
</p>
<p>Одним из решений, которое позволило бы нам определить новую структуру Lisp для 
представления  <code>easy-handle</code>, было бы написание обертки вокруг каждой функции,
которая в настоящее время получает <code>easy-handle</code>; оболочка извлечет указатель
и передаст его внешней функции.  Однако мы можем использовать преобразователи типов, чтобы
более элегантно интегрировать этот âпреобразователь(translation)â в конструкцию
вызова внешний функций, используя <code>translate-to-foreign</code>.
</p>
<div class="smalllisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defclass</span></i> easy-handle <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">pointer <span class="keyword">:initform</span> <span class="paren4">(<span class="lisp-bg">curl-easy-init</span>)</span>
              <span class="keyword">:documentation</span> <span class="string">"Foreign pointer from curl_easy_init"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg">error-buffer
      <span class="keyword">:initform</span> <span class="paren4">(<span class="lisp-bg">foreign-alloc <span class="keyword">:char</span> <span class="keyword">:count</span> <span class="special">*curl-error-size*</span>
                               <span class="keyword">:initial-element</span> 0</span>)</span>
      <span class="keyword">:documentation</span> <span class="string">"C string describing last error"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg">c-strings <span class="keyword">:initform</span> '<span class="paren4">(<span class="lisp-bg"></span>)</span>
                <span class="keyword">:documentation</span> <span class="string">"C strings set as options"</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:documentation</span> <span class="string">"I am a parameterization you may pass to
  curl-easy-perform to perform a cURL network protocol request."</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> initialize-instance <span class="keyword">:after</span> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">self easy-handle</span>)</span> &amp;key</span>)</span>
    <span class="paren2">(<span class="lisp-bg">set-curl-option-errorbuffer self <span class="paren3">(<span class="lisp-bg">slot-value self 'error-buffer</span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> add-curl-handle-cstring <span class="paren2">(<span class="lisp-bg">handle cstring</span>)</span>
    <span class="string">"Add CSTRING to be freed when HANDLE is, answering CSTRING."</span>
    <span class="paren2">(<span class="lisp-bg">car <span class="paren3">(<span class="lisp-bg">push cstring <span class="paren4">(<span class="lisp-bg">slot-value handle 'c-strings</span>)</span></span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> get-easy-handle-error <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Answer a string containing HANDLE's current error message."</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-to-lisp
     <span class="paren3">(<span class="lisp-bg">slot-value handle 'error-buffer</span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> free-easy-handle <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Free CURL easy interface HANDLE and any C strings created to
  be its options."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-slots</span></i> <span class="paren3">(<span class="lisp-bg">pointer error-buffer c-strings</span>)</span> handle
      <span class="paren3">(<span class="lisp-bg">curl-easy-cleanup pointer</span>)</span>
      <span class="paren3">(<span class="lisp-bg">foreign-free error-buffer</span>)</span>
      <span class="paren3">(<span class="lisp-bg">mapc #'foreign-string-free c-strings</span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> easy-handle-type <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:actual-type</span> <span class="keyword">:pointer</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:simple-parser</span> easy-handle</span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-to-foreign <span class="paren2">(<span class="lisp-bg">handle <span class="paren3">(<span class="lisp-bg">type easy-handle-type</span>)</span></span>)</span>
    <span class="string">"Extract the pointer from an easy-HANDLE."</span>
    <span class="paren2">(<span class="lisp-bg">slot-value handle 'pointer</span>)</span></span>)</span>
</pre></div>

<p>В то время как мы изменили некоторые функции Lisp, оределенные ранее,
чтобы использовать слоты <acronym>CLOS</acronym> вместо хеш-таблиц, внешние 
функции работатют также как и раньше.
</p>
<a name="index-limitations-of-type-translators"></a>
<p>Самая большая сила и самое большое ограничение преобразователей типов - это
их обобщенный интерфейс.  Как указывалось ранее, мы можем определить все вызовы
внешний функций в терминах примитивных внешних типов предоставляемых <acronym>CFFI</acronym>.  
Интерфейс преобразователей типов позволяет нам точно определять отношения между данными
Lisp и данными Си, независимо от того, где они появляются в вызове функции.
Эта независимость имеет свою цену; например, их нельзя использовать для изменения семантики
преобразования базирующейся на других аргументах вызова функции.  В этих случаях вам 
следует полагаться на другие функции Lisp, а не на мощный, но предметно-ориентированный
интерфейс преобразователей типа.
</p>

<hr>
<a name="Tutorial_002dConclusion"></a>
<div class="header">
<p>
Previous: <a href="#Tutorial_002dTypes" accesskey="p" rel="prev">Tutorial-Types</a>, Up: <a href="#Tutorial" accesskey="u" rel="up">Tutorial</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="What_0027s-next_003f"></a>
<h3 class="section">4.12 Что дальше?</h3>

<p><acronym>CFFI</acronym> предоставлялет богатую и мощную основу для взаимодейтсвия
с внешними библиотеками; как мы уже видели, это зависит от вас как сделать этот опыт
программировани на Лисп приятными.  Этот учебник не охватывает все функции <acronym>CFFI</acronym>; 
пожалуйста, смотрите остальную часть руководства для получения детальной инфоpмации.  
В частности, если что-то явно отсутствует, вполне вероятно, присутстует либо код, либо веская
причина его отсутствия.
</p>
<blockquote>
<p><strong>Примечания разработчика:</strong> <em>В <acronym>CFFI</acronym> есть и другие вещи,
которые заслуживают учебных разделов, например свободно преобразуемые объекты(free-translated-object),
или структуры(structs).  Дайте нам знать, какие из них вам не безразличны.</em>
</p></blockquote>

<hr>
<a name="Wrapper-generators"></a>
<div class="header">
<p>
Next: <a href="#Foreign-Types" accesskey="n" rel="next">Foreign Types</a>, Previous: <a href="#Tutorial" accesskey="p" rel="prev">Tutorial</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Wrapper-generators-1"></a>
<h2 class="chapter">5 Генератор оболочек</h2>

<p>Интерфейс <acronym>CFFI</acronym> предназначен для программистов людей, ориентированных
как на эстетическое, так и на техническое совершенство.  Однако, существует несколько программ,
предназначенных для преобразования заголовочных файлов Си и Си++, или их аналогов в 
формы <acronym>CFFI</acronym>, представляющие собой внешний интерфейс для символов в этих файлах.
</p>
<p>Известно, что эти генераторы оберток поддерживают вывод форм <acronym>CFFI</acronym>.
</p>
<dl compact="compact">
<dt><a href="http://www.cliki.net/Verrazano">Verrazano</a></dt>
<dd><p>Разработан специально для Common Lisp.  Использует вывод синтаксического
анализатора <acronym>GCC</acronym> в формате  <acronym>XML</acronym> для обнаружения
функций, переменных и других данных файла заголовка.  Это означает, что вам нужен
<acronym>GCC</acronym> для создания форм; с другой стороны, используемый синтаксический
анализатор в основном соответствует <acronym>ANSI</acronym> C.
</p>
</dd>
<dt><a href="http://www.cliki.net/SWIG">SWIG</a></dt>
<dd><p>Генератор внешних интерфейсов, изначально разработанный для генерации привязок Python,
он был портирован на многие другие системы, включаяя <acronym>CFFI</acronym>
в версии 1.3.28.  Включает в себя собственный модуль деклараций Си, не предназначенный для
полного соответствия  <acronym>ANSI</acronym> C.
</p></dd>
</dl>

<p>Во-первых, это руководство не описывает использовние этих сторонних программ;
у них есть собственная документация.  Если у вас есть проблемы с использованием
сгенерированного интерфейса, пожалуйста, посмотрите на выходные формы 
<acronym>CFFI</acronym>  и убедитесь, что они являются правильным интерфейсом 
<acronym>CFFI</acronym> к рассматриваемой библиотеке; если они верны, обратитесь
к разработчикам <acronym>CFFI</acronym> с подробностями, помня, что они общаются
в терминах этих форм, а не какого-либо конкретного генератора оберток. В противном
случае обратитесь к специалистам по обслуживанию генератора обертки, который вы
используете, при условии, что вы можете ожидать большей точности от
генератора.
</p>
<p>Когда большая точность - это необоснованное ожидание? Как описано в
учебном пособии (см. <a href="#Tutorial_002dAbstraction">Нарушение Абстракции</a>), 
информации в объявлениях Си недостаточно, чтобы полностью описать каждый интерфейс.
На самом деле, довольно часто моно встретить интерфейс, который не может быть обработан
автоматически, и в этом случае, генераторы должны быть освобождены от созданиия полного интерфейса.
</p>
<p>Как описано далее в руководстве, самый тонкий интерфейс Lisp для функций
Си не всегда самый приятный.  Во многих случаях нужно будет вручную написать
Lisp интерфейс для функций Си, которые вас интересуют.
</p>
<p>Генераторы оберток должны рассматриваться как экономия времени, а не полная
автоматизация полного написания внешнего интерфейса.  Отчеты об объеме
работы, выполненной генераторами, варьируются от 30% до 90%.  Стиль
инкрементальной разработки поддерживаемый  <acronym>CFFI</acronym> обычно уменьшает
эту пропорцию ниже, чем в таких языках как Python.
</p>

<hr>
<a name="Foreign-Types"></a>
<div class="header">
<p>
Next: <a href="#Pointers" accesskey="n" rel="next">Pointers</a>, Previous: <a href="#Wrapper-generators" accesskey="p" rel="prev">Wrapper generators</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Foreign-Types-1"></a>
<h2 class="chapter">6 Внешние типы</h2>

<p>Внешние типы описывают, как данные преобразуются между Си и Lisp. <acronym>CFFI</acronym> предоставляет
различные встроенные типы и позволяет пользователю определять новые типы.
</p>
<table class="menu" cellspacing="0" border="0">
<tbody><tr><td valign="top" align="left">• <a href="#Built_002dIn-Types" accesskey="1">Встроенные типы(Built-In Types)</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Other-Types" accesskey="2">Другие типы(Other Types)</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Defining-Foreign-Types" accesskey="3">Определение Внешних Типов(Defining Foreign Types)</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Foreign-Type-Translators" accesskey="4">Преобразователи Внешних Типов(Foreign Type Translators)</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Optimizing-Type-Translators" accesskey="5">Оптимизация Преобразователей типов(Optimizing Type Translators)</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Foreign-Structure-Types" accesskey="6">Внешние Структурные Типы(Foreign Structure Types)</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Allocating-Foreign-Objects" accesskey="7">Выделение памяти для Внешних объектов(Allocating Foreign Objects)</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Словарь

</pre></th></tr><tr><td valign="top" align="left">• <a href="#convert_002dfrom_002dforeign" accesskey="8">convert-from-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#convert_002dto_002dforeign" accesskey="9">convert-to-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#defbitfield">defbitfield</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#defcstruct">defcstruct</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#defcunion">defcunion</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#defctype">defctype</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#defcenum">defcenum</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#define_002dforeign_002dtype">define-foreign-type</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#define_002dparse_002dmethod">define-parse-method</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002denum_002dvalue">foreign-enum-value</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dslot_002dnames">foreign-slot-names</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dslot_002doffset">foreign-slot-offset</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dtype_002dalignment">foreign-type-alignment</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dtype_002dsize">foreign-type-size</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#free_002dconverted_002dobject">free-converted-object</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#free_002dtranslated_002dobject">free-translated-object</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dfrom_002dforeign">translate-from-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dto_002dforeign">translate-to-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dslots">with-foreign-slots</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
</tbody></table>

<hr>
<a name="Built_002dIn-Types"></a>
<div class="header">
<p>
Next: <a href="#Other-Types" accesskey="n" rel="next">Other Types</a>, Previous: <a href="#Foreign-Types" accesskey="p" rel="prev">Foreign Types</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Built_002dIn-Types-1"></a>
<h3 class="section">6.1 Встроенные типы</h3>

<dl>
<dt><a name="index-_003achar"></a>Foreign Type: <strong>:char</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aunsigned_002dchar"></a>Foreign Type: <strong>:unsigned-char</strong></dt>
</dl>
<dl>
<dt><a name="index-_003ashort"></a>Foreign Type: <strong>:short</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aunsigned_002dshort"></a>Foreign Type: <strong>:unsigned-short</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aint"></a>Foreign Type: <strong>:int</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aunsigned_002dint"></a>Foreign Type: <strong>:unsigned-int</strong></dt>
</dl>
<dl>
<dt><a name="index-_003along"></a>Foreign Type: <strong>:long</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aunsigned_002dlong"></a>Foreign Type: <strong>:unsigned-long</strong></dt>
</dl>
<dl>
<dt><a name="index-_003along_002dlong"></a>Foreign Type: <strong>:long-long</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aunsigned_002dlong_002dlong"></a>Foreign Type: <strong>:unsigned-long-long</strong></dt>
</dl>

<p>Эти типы соответствуют собственным целочисленным типам Си в соответствии с
<acronym>ABI</acronym> хост-системы(системы на которой выполняется лисп) реализации Лиспа.
</p>
<p><code>:long-long</code> и <code>:unsigned-long-long</code> изначально не поддерживаются
во всех реализациях. Однако они эмулируются через
<code>mem-ref</code> и <code>mem-set</code>.
</p>
<p>Когда эти типы недоступны, в <code>*features*</code> помещается символ <code>cffi-sys::no-long-long</code>.
</p>
<dl>
<dt><a name="index-_003auchar"></a>Foreign Type: <strong>:uchar</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aushort"></a>Foreign Type: <strong>:ushort</strong></dt>
</dl>
<dl>
<dt><a name="index-_003auint"></a>Foreign Type: <strong>:uint</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aulong"></a>Foreign Type: <strong>:ulong</strong></dt>
</dl>
<dl>
<dt><a name="index-_003allong"></a>Foreign Type: <strong>:llong</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aullong"></a>Foreign Type: <strong>:ullong</strong></dt>
</dl>

<p>Для удобства указанные выше типы предоставляются в виде ярлыков для 
<code>unsigned-char</code>, <code>unsigned-short</code>, <code>unsigned-int</code>,
<code>unsigned-long</code>, <code>long-long</code> и <code>unsigned-long-long</code>,
соответственно.
</p>
<dl>
<dt><a name="index-_003aint8"></a>Foreign Type: <strong>:int8</strong></dt>
</dl>
<dl>
<dt><a name="index-_003auint8"></a>Foreign Type: <strong>:uint8</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aint16"></a>Foreign Type: <strong>:int16</strong></dt>
</dl>
<dl>
<dt><a name="index-_003auint16"></a>Foreign Type: <strong>:uint16</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aint32"></a>Foreign Type: <strong>:int32</strong></dt>
</dl>
<dl>
<dt><a name="index-_003auint32"></a>Foreign Type: <strong>:uint32</strong></dt>
</dl>
<dl>
<dt><a name="index-_003aint64"></a>Foreign Type: <strong>:int64</strong></dt>
</dl>
<dl>
<dt><a name="index-_003auint64"></a>Foreign Type: <strong>:uint64</strong></dt>
</dl>

<p>Внешние целочисленные типы определенных размеров, соответствующие типам Си, 
определенным в <code>stdint.h</code>.
</p>

<dl>
<dt><a name="index-_003afloat"></a>Foreign Type: <strong>:float</strong></dt>
</dl>
<dl>
<dt><a name="index-_003adouble"></a>Foreign Type: <strong>:double</strong></dt>
</dl>

<p>Во всех системах типы <code>:float</code> и <code>:double</code> представляют
Си <code>float</code> и <code>double</code>, соответственно. На большинстве, но
не на всех системах <code>:float</code> и <code>:double</code> представляют Lisp
<code>single-float</code> и <code>double-float</code>, соответственно. Не очень
полезно рассматривать отношения между типами Lisp и типами Си как изоморфные,
как простое отношение и относительно точное, между каждой соответствующей категорией.
</p>
<dl>
<dt><a name="index-_003along_002ddouble"></a>Foreign Type: <strong>:long-double</strong></dt>
</dl>

<p>Этот тип поддерживается только в SCL.
</p>
<dl>
<dt><a name="index-_003apointer"></a>Foreign Type: <strong>:pointer</strong> <em>&amp;optional type</em></dt>
</dl>

<p>Внешний указатель на объект любого типа, соответствующий
<code>void *</code>.  При желании вы можете указать тип указателя
(например <code>(:pointer :char)</code>).  Хотя <acronym>CFFI</acronym> пока ничего
не будет делать с этой информацией, она полезна для целей документирования.
</p>
<dl>
<dt><a name="index-_003avoid"></a>Foreign Type: <strong>:void</strong></dt>
</dl>

<p>Нет типа вообще. Действителен только в качестве типа возврата функции.
</p>
<hr>
<a name="Other-Types"></a>
<div class="header">
<p>
Next: <a href="#Defining-Foreign-Types" accesskey="n" rel="next">Defining Foreign Types</a>, Previous: <a href="#Built_002dIn-Types" accesskey="p" rel="prev">Built-In Types</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Other-Types-1"></a>
<h3 class="section">6.2 Другие Типы</h3>

<p><acronym>CFFI</acronym> также предоставляет несколько полезных типов, которые не 
являются встроенными Си типами.
</p>
<dl>
<dt><a name="index-_003astring"></a>Foreign Type: <strong>:string</strong></dt>
</dl>

<p>Тип <code>:string</code> выполняет автоматическое преобразование между строками 
Lisp и строками Си. Обратите внимание, что в случае функций преобразованная строка Си
будет иметь динамическое время существования(т.е она будет автоматически освобождена после
возврата внешней функции).
</p>
<p>В дополнение к строкам Lisp, этот тип будет принимать внешние указатели и передавать их
без изменений.
</p>
<p>Для этого типа, адаптирован, метод для свободно преобразуемого объекта(<a href="#free_002dtranslated_002dobject">free-translated-object</a>). Так, например,
внешние строки, выделенные этим типом и переданные внешней функции, будут
осовбождены после её возврата.
</p>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"getenv"</span> <span class="keyword">:string</span> <span class="string">"SHELL"</span> <span class="keyword">:string</span></span>)</span>
 ⇒ "/bin/bash"

  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">str <span class="string">"abcdef"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"strlen"</span> <span class="keyword">:string</span> str <span class="keyword">:int</span></span>)</span></span>)</span>
 ⇒ 6
</pre></div>

<dl>
<dt><a name="index-_003astring_002bptr"></a>Foreign Type: <strong>:string+ptr</strong></dt>
</dl>

<p>Подобен <code>:string</code> но возвращает список с двумя значениями при конвертации
из Си в  Lisp: строка Lisp и внешний указатель строки Си.
</p>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"getenv"</span> <span class="keyword">:string</span> <span class="string">"SHELL"</span> <span class="keyword">:string+ptr</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg"><span class="string">"/bin/bash"</span> #.<span class="paren2">(<span class="lisp-bg">SB-SYS:INT-SAP #XBFFFFC6F</span>)</span></span>)</span>
</pre></div>

<dl>
<dt><a name="index-_003aboolean"></a>Foreign Type: <strong>:boolean</strong> <em>&amp;optional (base-type :int)</em></dt>
</dl>

<p>Тип <code>:boolean</code> выполняет конвертацию межд логическми значениями Lisp и
логическими значениями Си. Он канонизируется к <var>base-type</var> который по умолчанию
<code>:int</code>.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">convert-to-foreign nil <span class="keyword">:boolean</span></span>)</span>⇒ 0
  <span class="paren1">(<span class="lisp-bg">convert-to-foreign t <span class="keyword">:boolean</span></span>)</span>⇒ 1
  <span class="paren1">(<span class="lisp-bg">convert-from-foreign 0 <span class="keyword">:boolean</span></span>)</span>⇒ nil
  <span class="paren1">(<span class="lisp-bg">convert-from-foreign 1 <span class="keyword">:boolean</span></span>)</span>⇒ t
</pre></div>

<dl>
<dt><a name="index-_003abool"></a>Foreign Type: <strong>:bool</strong></dt>
</dl>

<p>Тип <code>:bool</code> представляет собой C99 <code>_Bool</code> или C++
<code>bool</code>. Его размер обычно составляет 1 байт, за исключением OSX, где он
<code>int</code>.
</p>
<dl>
<dt><a name="index-_003awrapper"></a>Foreign Type: <strong>:wrapper</strong> <em>base-type &amp;key to-c from-c</em></dt>
</dl>

<p>Тип обертка <code>:wrapper</code> хранит два символа, переданных аргументами
<var>to-c</var> и <var>from-c</var>. Когда значение преобразуется в или из Си, этот
тип вызывает(<code>funcall</code>) соответствующий символ.
</p>
<p>Типы <code>:wrapper</code> будут typedefs для <var>base-type</var> и будут
наследовать его преобразователи, если таковые имеются.
</p>
<p>Вот пример того, как тип <code>:boolean</code> может быть определен в терминах
<code>:wrapper</code>.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> bool-c-to-lisp <span class="paren2">(<span class="lisp-bg">value</span>)</span>
    <span class="paren2">(<span class="lisp-bg">not <span class="paren3">(<span class="lisp-bg">zerop value</span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> bool-lisp-to-c <span class="paren2">(<span class="lisp-bg">value</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">if</span></i> value 1 0</span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> my-bool <span class="paren2">(<span class="lisp-bg"><span class="keyword">:wrapper</span> <span class="keyword">:int</span> <span class="keyword">:from-c</span> bool-c-to-lisp
                                   <span class="keyword">:to-c</span> bool-lisp-to-c</span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg">convert-to-foreign nil 'my-bool</span>)</span>⇒ 0
  <span class="paren1">(<span class="lisp-bg">convert-from-foreign 1 'my-bool</span>)</span>⇒ t
</pre></div>

<hr>
<a name="Defining-Foreign-Types"></a>
<div class="header">
<p>
Next: <a href="#Foreign-Type-Translators" accesskey="n" rel="next">Foreign Type Translators</a>, Previous: <a href="#Other-Types" accesskey="p" rel="prev">Other Types</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Defining-Foreign-Types-1"></a>
<h3 class="section">6.3 Определение Внешних Типов</h3>

<p>Вы можете определить простые типы подобно Си <code>typedef</code> через
макрос <code>defctype</code>. Определить тип очень просто, передав в
<code>defctype</code> новое имя и имя типа которое "оборачивается" новым типом.
</p>
<div class="lisp">
<pre class="lisp">  <span class="comment">;;; Define MY-INT as an alias for the built-in type :INT.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> my-int <span class="keyword">:int</span></span>)</span>
</pre></div>

<p>С этим определением типа можно, например, объявить аргументы внешним функциям как
имеющим тип <code>my-int</code>, и они будут передаваться как целые числа(integers).
</p>
<a name="More-complex-types"></a>
<h4 class="subheading">Более сложные типы</h4>

<p><acronym>CFFI</acronym> предлагает и другой способ определения типов с
помощью <code>define-foreign-type</code>, тонкого макроа-обертки вокруг
<code>defclass</code>. В качестве примера, давайте пройдемся по шагам, необходимым
для определения типа <code>(my-string &amp;key encoding)</code>. Во-первых, нам нужно
определить наш класс типа:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> my-string-type <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">encoding <span class="keyword">:reader</span> string-type-encoding <span class="keyword">:initarg</span> <span class="keyword">:encoding</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:actual-type</span> <span class="keyword">:pointer</span></span>)</span></span>)</span>
</pre></div>

<p>Опция класса <code>:actual-type</code> сообщает CFFI, что этот тип в 
конечном итоге будет передан или получен из внешнего кода в виде указателя
<code>:pointer</code>. Теперь вам нужно рассказать CFFI как анализировать
спецификацию типа, такую как <code>(my-string :encoding :utf8)</code> в 
экземпляр  <code>my-string-type</code>.  Мы делаем это с помощью
<code>define-parse-method</code>:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-parse-method</span></i> my-string <span class="paren2">(<span class="lisp-bg">&amp;key <span class="paren3">(<span class="lisp-bg">encoding <span class="keyword">:utf-8</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">make-instance 'my-string-type <span class="keyword">:encoding</span> encoding</span>)</span></span>)</span>
</pre></div>

<p>В следующем разделе описывается, как заставить этот тип фактически
преобразовывать строки между Си и Lisp.
</p>
<hr>
<a name="Foreign-Type-Translators"></a>
<div class="header">
<p>
Next: <a href="#Optimizing-Type-Translators" accesskey="n" rel="next">Optimizing Type Translators</a>, Previous: <a href="#Defining-Foreign-Types" accesskey="p" rel="prev">Defining Foreign Types</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Foreign-Type-Translators-1"></a>
<h3 class="section">6.4 Преобразователи Внешних Типов</h3>

<p>Преобразователи типов используются для автоматического преобразования
значений Lisp В или ИЗ внешних значений.  Например, используя преобразователи
типов можно взять тип <code>my-string</code>, определенный в предыдущем разделе,
и указать, что он должен:
</p>
<ul>
<li> конвертировать строки Си в стоки Lisp;
</li><li> конвертировать строки Lisp во вновь выделенные в памяти строки Си;
</li><li> Освобождать памать строк Си, когда они больше не нужны.
</li></ul>

<p>Чтобы сообщить <acronym>CFFI</acronym> как автоматически преобразовывать значения
Lisp во внешние значения, определите специальный метод для обобщенной(универсальной) функции
<code>translate-to-foreign</code>:
</p>
<div class="lisp">
<pre class="lisp">  <span class="comment">;;; Define a method that converts Lisp strings to C strings.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-to-foreign <span class="paren2">(<span class="lisp-bg">string <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-alloc string <span class="keyword">:encoding</span> <span class="paren3">(<span class="lisp-bg">string-type-encoding type</span>)</span></span>)</span></span>)</span>
</pre></div>

<p>С этого момента, всякий раз, когда объект передается как <code>my-string</code> 
во внешнюю функию, будет вызываться этот метод для преобразования значения Lisp. 
Чтобы выполнить обратную операцию, которая необходима для функций, которые возвращают
<code>my-string</code>, определите специальный метод обобщенной функции
<code>translate-from-foreign</code> таким же образом:
</p>
<div class="lisp">
<pre class="lisp">  <span class="comment">;;; Define a method that converts C strings to Lisp strings.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-from-foreign <span class="paren2">(<span class="lisp-bg">pointer <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-to-lisp pointer <span class="keyword">:encoding</span> <span class="paren3">(<span class="lisp-bg">string-type-encoding type</span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Когда метод <code>translate-to-foreign</code> требует выделения внешней
памяти, вы также должны определить метод <code>free-translated-object</code>
чтобы освобождить память, когда объект больше не требуется,
в противном случае вы столкнетесь с утечками памяти.  Эта обобщенная функция
автоматически вызывается <acronym>CFFI</acronym> при передаче объектов во
внешние функции. Давайте сделаем это:
</p>
<div class="lisp">
<pre class="lisp">  <span class="comment">;;; Free strings allocated by translate-to-foreign.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> free-translated-object <span class="paren2">(<span class="lisp-bg">pointer <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span> param</span>)</span>
    <span class="paren2">(<span class="lisp-bg">declare <span class="paren3">(<span class="lisp-bg">ignore param</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-free pointer</span>)</span></span>)</span>
</pre></div>

<p>В этом конкретном примере, нам не нужен аргумент <var>param</var>, поэтому
мы его игнорируем. См. <a href="#free_002dtranslated_002dobject">free-translated-object</a>, 
для объяснения его целей и того как вы можете его использовать.
</p>
<p>Преобразователь типа не обязательно должен преобразовывать значение.  
Например, можно определить тип для <code>:pointer</code>, который гарантирует
что в методе <code>translate-to-foreign</code>, значение не является нулевым
указателем, сигнализируя об ошибке, если передан нулевой указатель. Это
предотвратит некоторые ошибки при вызове сторонних функций, которые не
могут обработать нулевые указатели.
</p>
<p><strong>Обратите внимание:</strong> эти методы предназначены только для 
расширения хуков, и вы не должны вызвать их напрямую.  Вместо этого
используйте команды <code>convert-to-foreign</code>, <code>convert-from-foreign</code> 
и <code>free-converted-object</code>.
</p>
<p>См. <a href="#Tutorial_002dTypes">Определение новых типов</a>, для ознакомления с примером
еще одного преобразователя типа.
</p>
<hr>
<a name="Optimizing-Type-Translators"></a>
<div class="header">
<p>
Next: <a href="#Foreign-Structure-Types" accesskey="n" rel="next">Foreign Structure Types</a>, Previous: <a href="#Foreign-Type-Translators" accesskey="p" rel="prev">Foreign Type Translators</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Optimizing-Type-Translators-1"></a>
<h3 class="section">6.5 Оптимизация Преобразователя Типа</h3>

<a name="index-type-translators_002c-optimizing"></a>
<a name="index-compiler-macros-for-type-translation"></a>
<a name="index-defining-type_002dtranslation-compiler-macros"></a>
<p>Основанный на обобщенных функциях механизм преобразования типов, описанный выше,
может добавить немного накладных расходов.  Обычно это не существенно, но мы, тем 
не менее, предоставляем способ избавиться от накладных расходов в тех случаях, когда
это важно.
</p>
<p>Хороший способ понять эту проблему - посмотреть на код, сгенерированный
<code>defcfun</code>. Рассмотрим следующий пример с использованием ранее
определенного типа <code>my-string</code>:
</p>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">macroexpand-1 '<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> foo my-string <span class="paren3">(<span class="lisp-bg">x my-string</span>)</span></span>)</span></span>)</span>
  <span class="comment">;; (simplified, downcased, etc...)
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="lisp-bg">x</span>)</span>
    <span class="paren2">(<span class="lisp-bg">multiple-value-bind <span class="paren3">(<span class="lisp-bg"><span class="keyword">#:G2019</span> <span class="keyword">#:PARAM3149</span></span>)</span>
        <span class="paren3">(<span class="lisp-bg">translate-to-foreign x #&lt;MY-STRING-TYPE {11ED5A79}&gt;</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">unwind-protect</span></i>
          <span class="paren4">(<span class="lisp-bg">translate-from-foreign
           <span class="paren5">(<span class="lisp-bg">foreign-funcall <span class="string">"foo"</span> <span class="keyword">:pointer</span> <span class="keyword">#:G2019</span> <span class="keyword">:pointer</span></span>)</span>
           #&lt;MY-STRING-TYPE {11ED5659}&gt;</span>)</span>
        <span class="paren4">(<span class="lisp-bg">free-translated-object <span class="keyword">#:G2019</span> #&lt;MY-STRING-TYPE {11ED51A79}&gt;
                                <span class="keyword">#:PARAM3149</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Для того чтобы избавиться от этих вызовов обобщенных функций, 
<acronym>CFFI</acronym> имеет еще один набор расширяемых обобщенных функций,
которые предоставляют функциональность, аналогичную макросам
компилятора <acronym>CL</acronym>â:
<code>expand-to-foreign-dyn</code>, <code>expand-to-foreign</code> и
<code>expand-from-foreign</code>. Вот как можно определить <code>my-boolean</code> 
с их использованием:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> my-boolean-type <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:actual-type</span> <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:simple-parser</span> my-boolean</span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-to-foreign <span class="paren2">(<span class="lisp-bg">value <span class="paren3">(<span class="lisp-bg">type my-boolean-type</span>)</span></span>)</span>
    `<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">if</span></i> ,value 1 0</span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-from-foreign <span class="paren2">(<span class="lisp-bg">value <span class="paren3">(<span class="lisp-bg">type my-boolean-type</span>)</span></span>)</span>
    `<span class="paren2">(<span class="lisp-bg">not <span class="paren3">(<span class="lisp-bg">zerop ,value</span>)</span></span>)</span></span>)</span>
</pre></div>

<p>А вот как будет выглядеть макрорасширение функции использующей этот тип:
</p>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">macroexpand-1 '<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> bar my-boolean <span class="paren3">(<span class="lisp-bg">x my-boolean</span>)</span></span>)</span></span>)</span>
  <span class="comment">;; (simplified, downcased, etc...)
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> bar <span class="paren2">(<span class="lisp-bg">x</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg"><span class="keyword">#:g3182</span> <span class="paren5">(<span class="lisp-bg"><i><span class="symbol">if</span></i> x 1 0</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">not <span class="paren4">(<span class="lisp-bg">zerop <span class="paren5">(<span class="lisp-bg">foreign-funcall <span class="string">"bar"</span> <span class="keyword">:int</span> <span class="keyword">#:g3182</span> <span class="keyword">:int</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Нет накладных расходов на обобщенные функции.
</p>
<p>Давайте вернемся к нашему типу <code>my-string</code>.  Интерфейс расширения
не имеет эквивалента <code>free-translated-object</code>; вместо этого вы должны
определить метод в <code>expand-to-foreign-dyn</code>, третьей обобщенной функции
в этом интерфейсе.  Это особенно полезно, когда вы можете выделить память для чего-то
гораздо более эффективно, если знаете что объект имеет динамическое пространство существования,
как в случае с вызовами функций, которые не сохраняют соответствующие выделенные аргументы.
</p>
<p>Это именно то, что нам нужно для типа <code>my-string</code>:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-from-foreign <span class="paren2">(<span class="lisp-bg">form <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span></span>)</span>
    `<span class="paren2">(<span class="lisp-bg">foreign-string-to-lisp ,form</span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-to-foreign-dyn <span class="paren2">(<span class="lisp-bg">value var body <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">encoding <span class="paren5">(<span class="lisp-bg">string-type-encoding type</span>)</span></span>)</span></span>)</span>
      `<span class="paren3">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren4">(<span class="lisp-bg">,var ,value <span class="keyword">:encoding</span> ',encoding</span>)</span>
         ,@body</span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Итак, давайте посмотрим на его макрорасширение:
</p>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">macroexpand-1 '<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> foo my-string <span class="paren3">(<span class="lisp-bg">x my-string</span>)</span></span>)</span></span>)</span>
  <span class="comment">;; (simplified, downcased, etc...)
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="lisp-bg">x</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren3">(<span class="lisp-bg"><span class="keyword">#:G2021</span> X <span class="keyword">:encoding</span> '<span class="keyword">:utf-8</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">foreign-string-to-lisp
       <span class="paren4">(<span class="lisp-bg">foreign-funcall <span class="string">"foo"</span> <span class="keyword">:pointer</span> <span class="keyword">#:g2021</span> <span class="keyword">:pointer</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Опять же, нет никаких накладных расходов обобщенных функций.
</p>
<a name="Other-details"></a>
<h4 class="subheading">Другие детали</h4>

<p>Чтобы сократить расширение и использовать вместо него функции <code>translate-*</code>,
просто вызовите следующий(next) метод.  Верните его результат в тех случаях, когда
ваш метод не может создать для него подходящую замену.
Это аналог механизма компиляции макроса всей формы.
</p>
<p>Методы <code>expand-*</code> имеют приоритет перед аналогами
<code>translate-*</code> и гарантированно будут использоваться в 
<code>defcfun</code>, <code>foreign-funcall</code>, <code>defcvar</code> и
<code>defcallback</code>.  Если вы определили метод для каждой из 
<code>expand-*</code> обобщенных функций, вы гарантированно получите
полный контроль над выражениями, сгенерированными для преобразования
типов в этих макросах.
</p>
<p>Они могут использоваться, а могут не использоваться и в других операторах
 <acronym>CFFI</acronym>, которые должны преобразовывать данные между
Lisp и Си; вы можете только предполагать, что методы
<code>expand-*</code> будут использоваться только во время компиляции Lisp.
</p>
<p><code>expand-to-foreign-dyn</code> имеет приоритет над
<code>expand-to-foreign</code> и используется только в <code>defcfun</code> и
<code>foreign-funcall</code> и имеет смысл только в этих контекстах.
</p>
<p><strong>Важное замечание:</strong> Этот набор обобщенных функций вызывается
во время макрорасширения.  Методы определяются на стадии загрузки или вычисления,
а не компиляции.  Вы несете ответственность за то, чтобы ваши методы
<code>expand-*</code> были определены при компиляции <code>foreign-funcall</code> или
других форм, которые их используют.  Один из способов сделать это - поместить определение
метода в файл раньше других форм и в соответствующую форму <code>eval-when</code>; 
другой способ - всегда загружать отдельный файл Lisp или <acronym>FASL</acronym>, 
содержащий ваши определения <code>expand-*</code>, прежде чем компилировать файлы
с формами, которые должны их использовать. В противном случае они не будут найдены, и
вместо них будут использоваться преобразователи времени выполнения..
</p>
<hr>
<a name="Foreign-Structure-Types"></a>
<div class="header">
<p>
Next: <a href="#Allocating-Foreign-Objects" accesskey="n" rel="next">Allocating Foreign Objects</a>, Previous: <a href="#Optimizing-Type-Translators" accesskey="p" rel="prev">Optimizing Type Translators</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Foreign-Structure-Types-1"></a>
<h3 class="section">6.6 Внешние Структурные Типы</h3>

<p>Для типов Си более сложных, чем простые псевдонимы для встроенных типов, таких которые
вы можете сделать с помощью <code>defctype</code>, <acronym>CFFI</acronym> позволяет
обявлять структуры и объединения с помощью <code>defcstruct</code> и <code>defcunion</code>.
</p>
<p>Например, рассмотрим это вымышленное объявление Си структуры, содержащей некоторую
персональную информацию:
</p>
<div class="example">
<pre class="example">struct person {
  int number;
  char* reason;
};
</pre></div>

<p>Её эквивалентная форма <code>defcstruct</code> следующая:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> person
    <span class="paren2">(<span class="lisp-bg">number <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">reason <span class="keyword">:string</span></span>)</span></span>)</span>
</pre></div>

<p>По умолчанию, <a href="#convert_002dfrom_002dforeign">convert-from-foreign</a> (а также <a href="#mem_002dref">mem-ref</a>) создадет список с именами слотов в качестве ключей,  <a href="#convert_002dto_002dforeign">convert-to-foreign</a> преобразует этот
список(plist) во внешнюю структуру.  Пользователь, желающий определить другие
преобразования должен использовать аргумент <code>:class</code> в
<a href="#defcstruct">defcstruct</a>, а затем определить методы для
<a href="#translate_002dfrom_002dforeign">translate-from-foreign</a> и
<a href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a>, которые
специализируются на этом классе, возможно вызывая <code>call-next-method</code> 
для преобразования из и в plists, а не для обеспечения прямого интерфейса с внешним объектом.
Макрос <code>translation-forms-for-class</code> будет генерировать формы, необходимые
для преобразования класс Lisp во внешнюю структуру и наоборот.
</p>
<p>Обратите внимание, что этот интерфейс предназначен только для тех, кто должен знать о
значениях содержащихся в соответствующей структуре.  Если библиотека, с которой 
вы взаимодействуете, возвращает непрозрачный указатель(т.е гарантировано не известно, на
что он указывает), который нужно только передать другим функциям библиотеки Си, во что бы то
ни стало просто используйте <code>:pointer</code> или определение безопасного типа,
объединенное с <code>defctype</code> и преобразование типа.  Чтобы передать или вернуть
структуру по значению в функцию, загрузите систему cffi-libffi и определите структуру
как <code>(:struct <var>structure-name</var>)</code>.  Чтобы передать или вернуть указатель,
вы может использовать либо <code>:pointer</code> или <code>(:pointer (:struct
<var>structure-name</var>))</code>.
</p>
<a name="Optimizing-translate_002dinto_002dforeign_002dmemory"></a>
<h4 class="subheading">Оптимизация преобразования во внешнюю память(translate-into-foreign-memory)</h4>

<p>Точно так же, как  <a href="#translate_002dfrom_002dforeign">translate-from-foreign</a> использовал
<code>expand-from-foreign</code>, чтобы оптимизировать вызов обобщенных функций  и 
<a href="#translate_002dto_002dforeign">translate-to-foreign</a> делал тоже самое в
<code>expand-to-foreign</code>, <a href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a> использует для этого
<code>expand-into-foreign-memory</code>.
</p>
<p>Давайте использовать нашу структуру <code>person</code> в качестве примера. Тем не менее,
мы собираемся приправить его(пример) использованием структуры lisp, а не plist 
для представления person(человека) в lisp.
</p>
<p>Сначала мы чуть чуть переопределим <code>person</code>.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> <span class="paren2">(<span class="lisp-bg">person <span class="keyword">:class</span> c-person</span>)</span>
    <span class="paren2">(<span class="lisp-bg">number <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">reason <span class="keyword">:string</span></span>)</span></span>)</span>
</pre></div>

<p>Добавив <code>:class</code> мы можем специализировать методы <code>translate-*</code>
для типа <code>c-person</code>.
</p>
<p>Далее мы определяем структуру lisp для использования вместо plists.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defstruct</span></i> lisp-person
    <span class="paren2">(<span class="lisp-bg">number 0 <span class="keyword">:type</span> integer</span>)</span>
    <span class="paren2">(<span class="lisp-bg">reason <span class="string">""</span> <span class="keyword">:type</span> string</span>)</span></span>)</span>
</pre></div>

<p>И теперь давайте определим преобразователи типа, которые мы уже знаем:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-from-foreign <span class="paren2">(<span class="lisp-bg">ptr <span class="paren3">(<span class="lisp-bg">type c-person</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">number reason</span>)</span> ptr <span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> person</span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">make-lisp-person <span class="keyword">:number</span> number <span class="keyword">:reason</span> reason</span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-from-foreign <span class="paren2">(<span class="lisp-bg">ptr <span class="paren3">(<span class="lisp-bg">type c-person</span>)</span></span>)</span>
    `<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">number reason</span>)</span> ,ptr <span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> person</span>)</span></span>)</span>
       <span class="paren3">(<span class="lisp-bg">make-lisp-person <span class="keyword">:number</span> number <span class="keyword">:reason</span> reason</span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-into-foreign-memory <span class="paren2">(<span class="lisp-bg">value <span class="paren3">(<span class="lisp-bg">type c-person</span>)</span> ptr</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">number reason</span>)</span> ptr <span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> person</span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">setf number <span class="paren4">(<span class="lisp-bg">lisp-person-number value</span>)</span>
            reason <span class="paren4">(<span class="lisp-bg">lisp-person-reason value</span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>На данный момент все работает, мы можем преобразовать В и ИЗ нашего
<code>lisp-person</code> и внешнего <code>person</code>. Если мы выполним macroexpand
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">setf <span class="paren2">(<span class="lisp-bg">mem-aref ptr '<span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> person</span>)</span></span>)</span> x</span>)</span>
</pre></div>

<p>мы получим что-то вроде:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">#:store879</span> x</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">translate-into-foreign-memory <span class="keyword">#:store879</span> #&lt;c-person person&gt;
                                   <span class="paren3">(<span class="lisp-bg">inc-pointer ptr 0</span>)</span></span>)</span>
    <span class="keyword">#:store879</span></span>)</span>
</pre></div>

<p>Это хорошо, но теперь мы можем сделать лучше и избавиться от вызова
обобщенной функции <code>translate-into-foreign-memory</code>.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-into-foreign-memory <span class="paren2">(<span class="lisp-bg">value <span class="paren3">(<span class="lisp-bg">type c-person</span>)</span> ptr</span>)</span>
    `<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">number reason</span>)</span> ,ptr <span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> person</span>)</span></span>)</span>
       <span class="paren3">(<span class="lisp-bg">setf number <span class="paren4">(<span class="lisp-bg">lisp-person-number ,value</span>)</span>
             reason <span class="paren4">(<span class="lisp-bg">lisp-person-reason ,value</span>)</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Теперь мы можем снова выполнить макрорасширение, чтобы увидеть изменения:
</p>
<div class="lisp">
<pre class="lisp">  <span class="comment">;; this:
  </span><span class="paren1">(<span class="lisp-bg">setf <span class="paren2">(<span class="lisp-bg">mem-aref ptr '<span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> person</span>)</span></span>)</span> x</span>)</span>

  <span class="comment">;; expands to this
  </span><span class="comment">;; (simplified, downcased, etc..)
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">#:store887</span> x</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">number reason</span>)</span> <span class="paren4">(<span class="lisp-bg">inc-pointer ptr 0</span>)</span> <span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> person</span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">setf number <span class="paren4">(<span class="lisp-bg">lisp-person-number <span class="keyword">#:store887</span></span>)</span>
            reason <span class="paren4">(<span class="lisp-bg">lisp-person-reason <span class="keyword">#:store887</span></span>)</span></span>)</span></span>)</span> <span class="keyword">#:store887</span></span>)</span>
</pre></div>

<p>И вот здесь, мы уже невидим никаких накладных расходов на обобщенные функции!
</p>
<a name="Compatibility-note"></a>
<h4 class="subheading">Замечания о совместимости</h4>

<p>Предыдущие версии CFFI принимали âголоеâ <var>structure-name</var> как
спецификацию типа, что интерпретировалось как указатель на структуру.
Теперь это устарело и выдается предупреждение о стиле. Использование этой
устаревшей формы означает, что <a href="#mem_002daref">mem-aref</a> сохраняет
свое прежнее значение и возвращает указатель.  Используя форму
<code>(:struct <var>structure-name</var>)</code> для типа,
<a href="#mem_002daref">mem-aref</a> предоставляет объект Lisp преобразованный
из структуры (по умолчанию plist).  Таким образом, семантика согласуется со всеми
типами при возвращении объекта, представленного в Lisp, а не указателя,
за исключением сохранения совместимости с âголойâ структурой.
Чтобы получить указатель, вы должны использовать функцию <a href="#mem_002daptr">mem-aptr</a>.
</p>
<p>См. <a href="#defcstruct">defcstruct</a> для получения более подробной информации.
</p>
<hr>
<a name="Allocating-Foreign-Objects"></a>
<div class="header">
<p>
Next: <a href="#convert_002dfrom_002dforeign" accesskey="n" rel="next">convert-from-foreign</a>, Previous: <a href="#Foreign-Structure-Types" accesskey="p" rel="prev">Foreign Structure Types</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Allocating-Foreign-Objects-1"></a>
<h3 class="section">6.7 Размещение в памяти Внешних Объектов</h3>

<p>См. <a href="#Allocating-Foreign-Memory">Распределение Внешней Памяти</a>.
</p>

<hr>
<a name="convert_002dfrom_002dforeign"></a>
<div class="header">
<p>
Next: <a href="#convert_002dto_002dforeign" accesskey="n" rel="next">convert-to-foreign</a>, Previous: <a href="#Allocating-Foreign-Objects" accesskey="p" rel="prev">Allocating Foreign Objects</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">convert-from-foreign</h4>
<a name="convert_002dfrom_002dforeign-1"></a>
<h3 class="heading">convert-from-foreign</h3>
<a name="Syntax"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-convert_002dfrom_002dforeign"></a>Function: <strong>convert-from-foreign</strong> <em>foreign-value type⇒ value</em></dt>
</dl>

<a name="Arguments-and-Values"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>foreign-value</var></dt>
<dd><p>The primitive C value as returned from a primitive foreign function or
from <code>convert-to-foreign</code>.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A <acronym>CFFI</acronym> type specifier.
</p>
</dd>
<dt><var>value</var></dt>
<dd><p>The Lisp value translated from <var>foreign-value</var>.
</p></dd>
</dl>

<a name="Description"></a>
<h4 class="subheading">Description</h4>

<p>Это внешний интерфейс для функции преобразования типа.  В реализации
все внешние функции в конечном итоге определяются как обертки вокруг
примитивных вызовов внешних функций.
</p>
<p>Эта функция доступна в основном для проверки процесса преобразования типа,
и возможно, для оптимизации специальных случаев вызовов ваших внешних функций.
</p>
<p>Её поведение лучше описано в документации <code>translate-from-foreign</code>.
</p>
<a name="Examples"></a>
<h4 class="subheading">Примеры</h4>

<div class="lisp">
<pre class="lisp">  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-to-foreign <span class="string">"a boat"</span> <span class="keyword">:string</span></span>)</span>
 ⇒ #&lt;FOREIGN-ADDRESS #x097ACDC0&gt;
 ⇒ T
  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-from-foreign * <span class="keyword">:string</span></span>)</span>
 ⇒ "a boat"
</pre></div>

<a name="See-Also"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#convert_002dto_002dforeign">convert-to-foreign</a> <br>
<a href="#free_002dconverted_002dobject">free-converted-object</a> <br>
<a href="#translate_002dfrom_002dforeign">translate-from-foreign</a>
</p>

<hr>
<a name="convert_002dto_002dforeign"></a>
<div class="header">
<p>
Next: <a href="#defbitfield" accesskey="n" rel="next">defbitfield</a>, Previous: <a href="#convert_002dfrom_002dforeign" accesskey="p" rel="prev">convert-from-foreign</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">convert-to-foreign</h4>
<a name="convert_002dto_002dforeign-1"></a>
<h3 class="heading">convert-to-foreign</h3>
<a name="Syntax-1"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-convert_002dto_002dforeign"></a>Function: <strong>convert-to-foreign</strong> <em>value type⇒ foreign-value, alloc-params</em></dt>
</dl>

<a name="Arguments-and-Values-1"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>value</var></dt>
<dd><p>The Lisp object to be translated to a foreign object.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A <acronym>CFFI</acronym> type specifier.
</p>
</dd>
<dt><var>foreign-value</var></dt>
<dd><p>The primitive C value, ready to be passed to a primitive foreign
function.
</p>
</dd>
<dt><var>alloc-params</var></dt>
<dd><p>Something of a translation state; you must pass it to
<code>free-converted-object</code> along with the foreign value for that to
work.
</p></dd>
</dl>

<a name="Description-1"></a>
<h4 class="subheading">Description</h4>

<p>Это внешний интерфейс для функциональности преобразования типа.  В реализации,
все внешние функции в конечном итоге определяются как обертки преобразования типа 
вокруг примитивных вызов внешних функций.
</p>
<p>Эта функция доступна в основном для проверки процесса преобразования типа и, возможно,
для оптимизации особых случаев вызовов ваших внешних функций.
</p>
<p>Ее поведение лучше описано в документации по <code>translate-to-foreign</code>.
</p>
<a name="Examples-1"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-to-foreign t <span class="keyword">:boolean</span></span>)</span>
 ⇒ 1
 ⇒ NIL
  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-to-foreign <span class="string">"hello, world"</span> <span class="keyword">:string</span></span>)</span>
 ⇒ #&lt;FOREIGN-ADDRESS #x097C5F80&gt;
 ⇒ T
  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">code-char <span class="paren2">(<span class="lisp-bg">mem-aref * <span class="keyword">:char</span> 5</span>)</span></span>)</span>
 ⇒ #\,
</pre></div>

<a name="See-Also-1"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#convert_002dfrom_002dforeign">convert-from-foreign</a> <br>
<a href="#free_002dconverted_002dobject">free-converted-object</a> <br>
<a href="#translate_002dto_002dforeign">translate-to-foreign</a>
</p>

<hr>
<a name="defbitfield"></a>
<div class="header">
<p>
Next: <a href="#defcstruct" accesskey="n" rel="next">defcstruct</a>, Previous: <a href="#convert_002dto_002dforeign" accesskey="p" rel="prev">convert-to-foreign</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">defbitfield</h4>
<a name="defbitfield-1"></a>
<h3 class="heading">defbitfield</h3>
<a name="Syntax-2"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-defbitfield"></a>Macro: <strong>defbitfield</strong> <em>name-and-options &amp;body masks</em></dt>
</dl>

<p>masks ::= [docstring] { (symbol value) }* <br>
name-and-options ::= name | (name &amp;optional (base-type :int))
</p>
<a name="Arguments-and-Values-2"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>The name of the new bitfield type.
</p>
</dd>
<dt><var>docstring</var></dt>
<dd><p>A documentation string, ignored.
</p>
</dd>
<dt><var>base-type</var></dt>
<dd><p>A symbol denoting a foreign type.
</p>
</dd>
<dt><var>symbol</var></dt>
<dd><p>A Lisp symbol.
</p>
</dd>
<dt><var>value</var></dt>
<dd><p>An integer representing a bitmask.
</p></dd>
</dl>

<a name="Description-2"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>defbitfield</code> используется для определения внешних типов,
которые отображают списки символов в целочисленные значения.
</p>
<p>Если значение <var>value</var> опущено, оно будет вычислено следующим образом: 
ищется наибольшее ранее использованное значение <var>value</var>, включая и 
вычисленные, только с одним 1-bit в его двоичном представлении (это степень
двойки), и сдвигается влево на одну позицию(в бинарном представлении).  Это правило
гарантирует, что вычисленное значение не может конфликтовать с предыдущими значениями,
но может конфликтовать с будущими явно указанными значениями.
</p>
<p>Списки символов будут автоматически преобразованы в значения и наоборот,
если они передаются в качестве аргументов или возвращаются из внешних функций,
соответственно. Тоже относится и к любым ситуациям, когда ожидается объект типа битового
поля(bitfield).
</p>
<p>Типы, определенные с помощью <code>defbitfield</code> канонизируются с <var>base-type</var>,
который по умолчанию является <code>:int</code>.
</p>
<a name="Examples-2"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defbitfield</span></i> open-flags
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:rdonly</span> #x0000</span>)</span>
    <span class="keyword">:wronly</span>               <span class="comment">;#x0001
  </span>  <span class="keyword">:rdwr</span>                 <span class="comment">;&amp;hellip;
  </span>  <span class="keyword">:nonblock</span>
    <span class="keyword">:append</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:creat</span>  #x0200</span>)</span></span>)</span>
    ;; etc&amp;hellip;

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-bitfield-symbols 'open-flags #b1101</span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg"><span class="keyword">:WRONLY</span> <span class="keyword">:NONBLOCK</span> <span class="keyword">:APPEND</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-bitfield-value 'open-flags '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:rdwr</span> <span class="keyword">:creat</span></span>)</span></span>)</span>
 ⇒ 514   ; #x0202

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="paren2">(<span class="lisp-bg"><span class="string">"open"</span> unix-open</span>)</span> <span class="keyword">:int</span>
    <span class="paren2">(<span class="lisp-bg">path <span class="keyword">:string</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">flags open-flags</span>)</span>
    <span class="paren2">(<span class="lisp-bg">mode <span class="keyword">:uint16</span></span>)</span></span>)</span> ; unportable

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">unix-open <span class="string">"/tmp/foo"</span> '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:wronly</span> <span class="keyword">:creat</span></span>)</span> #o644</span>)</span>
 ⇒ #&lt;an fd&gt;

  <span class="comment">;;; Consider also the following lispier wrapper around open()
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> lispier-open <span class="paren2">(<span class="lisp-bg">path mode &amp;rest flags</span>)</span>
    <span class="paren2">(<span class="lisp-bg">unix-open path flags mode</span>)</span></span>)</span>
</pre></div>

<a name="See-Also-2"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a> <br>
<a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>
</p>

<hr>
<a name="defcstruct"></a>
<div class="header">
<p>
Next: <a href="#defcunion" accesskey="n" rel="next">defcunion</a>, Previous: <a href="#defbitfield" accesskey="p" rel="prev">defbitfield</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">defcstruct</h4>
<a name="defcstruct-1"></a>
<h3 class="heading">defcstruct</h3>
<a name="Syntax-3"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-defcstruct"></a>Macro: <strong>defcstruct</strong> <em>name-and-options &amp;body doc-and-slots⇒ name</em></dt>
</dl>

<p>name-and-options ::= structure-name | (structure-name &amp;key size)
</p>
<p>doc-and-slots ::= [docstring] { (slot-name slot-type &amp;key count offset) }*
</p>
<a name="Arguments-and-Values-3"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>structure-name</var></dt>
<dd><p>Имя нового структурного типа.
</p>
</dd>
<dt><var>docstring</var></dt>
<dd><p>Строка документации, игнорируется.
</p>
</dd>
<dt><var>slot-name</var></dt>
<dd><p>Символ обозначающий имя слота.  Он должен быть уникальным среди имен слотов
в данной структуре.
</p>
</dd>
<dt><var>size</var></dt>
<dd><p>Использование этой опции переопределяет размер(в байтах) структуры.
</p>
</dd>
<dt><var>slot-type</var></dt>
<dd><p>Указывает тип слота.
</p>
</dd>
<dt><var>count</var></dt>
<dd><p>Используется для объявления массивов размером <var>count</var> внутри структуры.  
По умолчанию равен <code>1</code> как массив из одного элемента, семантически
эквивалентен единичному элементу.
</p>
</dd>
<dt><var>offset</var></dt>
<dd><p>Переопределяет смещение слота. Смещение следующего слота вычисляется
опираясь на этот параметр.
</p></dd>
</dl>

<a name="Description-3"></a>
<h4 class="subheading">Description</h4>
<p>Здесь определяется новый агрегатный(составной) тип <acronym>CFFI</acronym>,
сродни структурам(<code>struct</code>) Си.
Другими словами, он указывает, что внешние объекты типа <var>structure-name</var> 
являются группой из разных частей данных, или âслотов(slots)â, имеющих тип
 <var>slot-type</var>s, отличающихся друг от друга именами
<var>slot-name</var>.  Каждая структура располагается в памяти в определенном месте,
и слоты распределяются последовательно, начиная с позиции выделения памяти 
(с некоторыми допускаемыми заполнениями, как определено в Си <acronym>ABI</acronym>, 
если иное не определяется путем указания смещения(<var>offset</var> от начал
структуры (offset 0).
</p>
<p>Другими словами, он изоморфен структуре(<code>struct</code>) в Си, что дает
несколько дополнительных возможностей.
</p>
<p>Существует два вида слотов, для двух видов типов <acronym>CFFI</acronym>:
</p>
<dl compact="compact">
<dt><em>Простой</em></dt>
<dd><p>Содержит один экземпляр типа, который канонизируется встроенным типом, 
таким как <code>:long</code> или <code>:pointer</code>.  Используется для
простых типов  <acronym>CFFI</acronym>.
</p>
</dd>
<dt><em>Сложный</em></dt>
<dd><p>Содержит встроенную структуру или объединение, или массив объектов. Используется для
агрегатных типов <acronym>CFFI</acronym>.
</p></dd>
</dl>

<p>Использование терминологии <acronym>CLOS</acronym> для функций, связанных со
структурой, является преднамеренным; определения структуры очень похожи на классы
с гораздо меньшим количеством возможностей.
</p>
<a name="Examples-3"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> point
    <span class="string">"Point structure."</span>
    <span class="paren2">(<span class="lisp-bg">x <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">y <span class="keyword">:int</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">ptr 'point</span>)</span>
          <span class="comment">;; Initialize the slots
  </span>        <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">foreign-slot-value ptr 'point 'x</span>)</span> 42
                <span class="paren3">(<span class="lisp-bg">foreign-slot-value ptr 'point 'y</span>)</span> 42</span>)</span>
          <span class="comment">;; Return a list with the coordinates
  </span>        <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">x y</span>)</span> ptr point</span>)</span>
            <span class="paren3">(<span class="lisp-bg">list x y</span>)</span></span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg">42 42</span>)</span>
</pre></div>

<div class="lisp">
<pre class="lisp">  <span class="comment">;; Using the :size and :offset options to define a partial structure.
  </span><span class="comment">;; (this is useful when you are interested in only a few slots
  </span><span class="comment">;; of a big foreign structure)
  </span> 
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> <span class="paren2">(<span class="lisp-bg">foo <span class="keyword">:size</span> 32</span>)</span>
    <span class="string">"Some struct with 32 bytes."</span>
                          <span class="comment">; &lt;16 bytes we don't care about&gt;
  </span>  <span class="paren2">(<span class="lisp-bg">x <span class="keyword">:int</span> <span class="keyword">:offset</span> 16</span>)</span>   <span class="comment">; an int at offset 16
  </span>  <span class="paren2">(<span class="lisp-bg">y <span class="keyword">:int</span></span>)</span>              <span class="comment">; another int at offset 16+sizeof(int)
  </span>                        <span class="comment">; &lt;a couple more bytes we don't care about&gt;
  </span>  <span class="paren2">(<span class="lisp-bg">z <span class="keyword">:char</span> <span class="keyword">:offset</span> 24</span>)</span></span>)</span> ; a char at offset 24
                          ; &lt;7 more bytes ignored <span class="paren1">(<span class="lisp-bg">since size is 32</span>)</span>&gt;

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-size 'foo</span>)</span>
 ⇒ 32
</pre></div>

<div class="lisp">
<pre class="lisp">  <span class="comment">;;; Using :count to define arrays inside of a struct.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> video_tuner
    <span class="paren2">(<span class="lisp-bg">name <span class="keyword">:char</span> <span class="keyword">:count</span> 32</span>)</span></span>)</span>
</pre></div>

<a name="See-Also-3"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a> <br>
<a href="#with_002dforeign_002dslots">with-foreign-slots</a>
</p>

<hr>
<a name="defcunion"></a>
<div class="header">
<p>
Next: <a href="#defctype" accesskey="n" rel="next">defctype</a>, Previous: <a href="#defcstruct" accesskey="p" rel="prev">defcstruct</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">defcunion</h4>
<a name="defcunion-1"></a>
<h3 class="heading">defcunion</h3>
<a name="Syntax-4"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-defcunion"></a>Macro: <strong>defcunion</strong> <em>name &amp;body doc-and-slots⇒ name</em></dt>
</dl>

<p>doc-and-slots ::= [docstring] { (slot-name slot-type &amp;key count) }*
</p>
<a name="Arguments-and-Values-4"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>The name of new union type.
</p>
</dd>
<dt><var>docstring</var></dt>
<dd><p>A documentation string, ignored.
</p>
</dd>
<dt><var>slot-name</var></dt>
<dd><p>A symbol naming the slot.
</p>
</dd>
<dt><var>slot-type</var></dt>
<dd><p>The type specifier for the slot.
</p>
</dd>
<dt><var>count</var></dt>
<dd><p>Used to declare an array of size <var>count</var> inside the
structure.
</p></dd>
</dl>

<a name="Description-4"></a>
<h4 class="subheading">Description</h4>
<p>Объединение это структура, в которой все слоты имеют нулевое смещение.
Оно изоморфно объединению(<code>union</code>) в Си.  Поэтому вы должны
использовать обычные операции над внешними структурами для доступа к слотам
объединения.
</p>
<a name="Examples-4"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcunion</span></i> uint32-bytes
    <span class="paren2">(<span class="lisp-bg">int-value <span class="keyword">:unsigned-int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">bytes <span class="keyword">:unsigned-char</span> <span class="keyword">:count</span> 4</span>)</span></span>)</span>
</pre></div>

<a name="See-Also-4"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>
</p>

<hr>
<a name="defctype"></a>
<div class="header">
<p>
Next: <a href="#defcenum" accesskey="n" rel="next">defcenum</a>, Previous: <a href="#defcunion" accesskey="p" rel="prev">defcunion</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">defctype</h4>
<a name="defctype-1"></a>
<h3 class="heading">defctype</h3>
<a name="Syntax-5"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-defctype"></a>Macro: <strong>defctype</strong> <em>name base-type &amp;optional documentation</em></dt>
</dl>

<a name="Arguments-and-Values-5"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>The name of the new foreign type.
</p>
</dd>
<dt><var>base-type</var></dt>
<dd><p>A symbol or a list defining the new type.
</p>
</dd>
<dt><var>documentation</var></dt>
<dd><p>A documentation string, currently ignored.
</p></dd>
</dl>

<a name="Description-5"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>defctype</code> предоставляет механизм, аналогичный
<code>typedef</code> в Си, для определения новых типов. новый тип
наследует преобразователи базового типа(<var>base-type</var>),
если они есть. Невозможно определить преобразователи для типов,
определенных с помощью <code>defctype</code>.  Для этого вы должны
использовать <a href="#define_002dforeign_002dtype">define-foreign-type</a>.
</p>
<a name="Examples-5"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> my-string <span class="keyword">:string</span>
    <span class="string">"My own string type."</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> long-bools <span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:long</span></span>)</span>
    <span class="string">"Booleans that map to C longs."</span></span>)</span>
</pre></div>

<a name="See-Also-5"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#define_002dforeign_002dtype">define-foreign-type</a>
</p>

<hr>
<a name="defcenum"></a>
<div class="header">
<p>
Next: <a href="#define_002dforeign_002dtype" accesskey="n" rel="next">define-foreign-type</a>, Previous: <a href="#defctype" accesskey="p" rel="prev">defctype</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">defcenum</h4>
<a name="defcenum-1"></a>
<h3 class="heading">defcenum</h3>
<a name="Syntax-6"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-defcenum"></a>Macro: <strong>defcenum</strong> <em>name-and-options &amp;body enum-list</em></dt>
</dl>

<p>enum-list ::= [docstring] { keyword | (keyword value) }*
name-and-options ::= name | (name &amp;optional (base-type :int))
</p>
<a name="Arguments-and-Values-6"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>The name of the new enum type.
</p>
</dd>
<dt><var>docstring</var></dt>
<dd><p>A documentation string, ignored.
</p>
</dd>
<dt><var>base-type</var></dt>
<dd><p>A symbol denoting a foreign type.
</p>
</dd>
<dt><var>keyword</var></dt>
<dd><p>A keyword symbol.
</p>
</dd>
<dt><var>value</var></dt>
<dd><p>An index value for a keyword.
</p></dd>
</dl>

<a name="Description-6"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>defcenum</code> используется для определения внешних типов,
которые отображают символы ключевые слова на целочисленные значения,
аналогично типу <code>enum</code> в Си.
</p>
<p>Если значение(<var>value</var>) опущено, его значение будет равно 0, если
это первая запись, или оно будет продолжать програссию от последнего
указанного значения.
</p>
<p>Ключевые слова будут автоматически преобразовываться в значения и наоборот
при передаче в качестве аргументов или возвращаемых значений из
внешних функций, соответственно. То же относится к любым другим ситуациям,
когда ожидается объект типа <code>enum</code>.
</p>
<p>Типы определенные с помощью <code>defcenum</code> канонизируются с 
базовым типом(<var>base-type</var>), который по умолчанию является
 <code>:int</code>.
</p>
<a name="Examples-6"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> boolean
    <span class="keyword">:no</span>
    <span class="keyword">:yes</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-enum-value 'boolean <span class="keyword">:no</span></span>)</span>
 ⇒ 0
</pre></div>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> numbers
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:one</span> 1</span>)</span>
    <span class="keyword">:two</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:four</span> 4</span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-enum-keyword 'numbers 2</span>)</span>
 ⇒ :TWO
</pre></div>

<a name="See-Also-6"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002denum_002dvalue">foreign-enum-value</a> <br>
<a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>
</p>

<hr>
<a name="define_002dforeign_002dtype"></a>
<div class="header">
<p>
Next: <a href="#define_002dparse_002dmethod" accesskey="n" rel="next">define-parse-method</a>, Previous: <a href="#defcenum" accesskey="p" rel="prev">defcenum</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">define-foreign-type</h4>
<a name="define_002dforeign_002dtype-1"></a>
<h3 class="heading">define-foreign-type</h3>
<a name="Syntax-7"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-define_002dforeign_002dtype"></a>Macro: <strong>define-foreign-type</strong> <em>class-name supers slots &amp;rest options⇒ class-name</em></dt>
</dl>

<p>options ::= (<code>:actual-type</code> <var>type</var>) | &nbsp;    (<code>:simple-parser</code> <var>symbol</var>) | &nbsp;    <em>regular defclass option</em>
</p>
<a name="Arguments-and-Values-7"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>class-name</var></dt>
<dd><p>A symbol naming the new foreign type class.
</p>
</dd>
<dt><var>supers</var></dt>
<dd><p>A list of symbols naming the super classes.
</p>
</dd>
<dt><var>slots</var></dt>
<dd><p>A list of slot definitions, passed to <code>defclass</code>.
</p></dd>
</dl>

<a name="Description-7"></a>
<h4 class="subheading">Description</h4>

<p>Макрос <code>define-foreign-type</code> определяет новый класс
<var>class-name</var>. Это тонкая обертка округ <code>defclass</code>. Помимо
прочего, он гарантирует, что  <var>class-name</var> становиться подклассом
<var>foreign-type</var>. О чем вам необходимо знать, так это о том, что есть
инициализирующий аргумент(initarg) <code>:actual-type</code>, который служит
той же цели, что и аргумент  <var>base-type</var> в <code>defctype</code>.
</p>

<a name="Examples-7"></a>
<h4 class="subheading">Examples</h4>
<p>Taken from <acronym>CFFI</acronym>âs <code>:boolean</code> type definition:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> <span class="keyword">:boolean</span> <span class="paren2">(<span class="lisp-bg">&amp;optional <span class="paren3">(<span class="lisp-bg">base-type <span class="keyword">:int</span></span>)</span></span>)</span>
    <span class="string">"Boolean type. Maps to an :int by default. Only accepts integer types."</span>
    <span class="paren2">(<span class="lisp-bg">ecase base-type
      <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg"><span class="keyword">:char</span>
        <span class="keyword">:unsigned-char</span>
        <span class="keyword">:int</span>
        <span class="keyword">:unsigned-int</span>
        <span class="keyword">:long</span>
        <span class="keyword">:unsigned-long</span></span>)</span> base-type</span>)</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type <span class="keyword">:boolean</span></span>)</span>
 ⇒ :INT
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:long</span></span>)</span></span>)</span>
 ⇒ :LONG
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:float</span></span>)</span></span>)</span>
  <span class="comment">;; error&amp;rarr; signalled by ECASE.
  </span>
</pre></div>

<a name="See-Also-7"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defctype">defctype</a> <br>
<a href="#define_002dparse_002dmethod">define-parse-method</a>
</p>

<hr>
<a name="define_002dparse_002dmethod"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dbitfield_002dsymbols" accesskey="n" rel="next">foreign-bitfield-symbols</a>, Previous: <a href="#define_002dforeign_002dtype" accesskey="p" rel="prev">define-foreign-type</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">define-parse-method</h4>
<a name="define_002dparse_002dmethod-1"></a>
<h3 class="heading">define-parse-method</h3>
<a name="Syntax-8"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-define_002dparse_002dmethod"></a>Macro: <strong>define-parse-method</strong> <em>name lambda-list &amp;body body⇒ name</em></dt>
</dl>

<a name="Arguments-and-Values-8"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type-name</var></dt>
<dd><p>A symbol naming the new foreign type.
</p>
</dd>
<dt><var>lambda-list</var></dt>
<dd><p>A lambda list which is the argument list of the new foreign type.
</p>
</dd>
<dt><var>body</var></dt>
<dd><p>One or more forms that provide a definition of the new foreign type.
</p></dd>
</dl>

<a name="Description-8"></a>
<h4 class="subheading">Description</h4>

<a name="Examples-8"></a>
<h4 class="subheading">Examples</h4>
<p>Получим из <acronym>CFFI</acronym>âs определение типа <code>:boolean</code>:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> <span class="keyword">:boolean</span> <span class="paren2">(<span class="lisp-bg">&amp;optional <span class="paren3">(<span class="lisp-bg">base-type <span class="keyword">:int</span></span>)</span></span>)</span>
    <span class="string">"Boolean type. Maps to an :int by default. Only accepts integer types."</span>
    <span class="paren2">(<span class="lisp-bg">ecase base-type
      <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg"><span class="keyword">:char</span>
        <span class="keyword">:unsigned-char</span>
        <span class="keyword">:int</span>
        <span class="keyword">:unsigned-int</span>
        <span class="keyword">:long</span>
        <span class="keyword">:unsigned-long</span></span>)</span> base-type</span>)</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type <span class="keyword">:boolean</span></span>)</span>
 ⇒ :INT
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:long</span></span>)</span></span>)</span>
 ⇒ :LONG
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:float</span></span>)</span></span>)</span>
  <span class="comment">;; error&amp;rarr; signalled by ECASE.
  </span>
</pre></div>

<a name="See-Also-8"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#define_002dforeign_002dtype">define-foreign-type</a>
</p>

<hr>
<a name="foreign_002dbitfield_002dsymbols"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dbitfield_002dvalue" accesskey="n" rel="next">foreign-bitfield-value</a>, Previous: <a href="#define_002dparse_002dmethod" accesskey="p" rel="prev">define-parse-method</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-bitfield-symbols</h4>
<a name="foreign_002dbitfield_002dsymbols-1"></a>
<h3 class="heading">foreign-bitfield-symbols</h3>
<a name="Syntax-9"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dbitfield_002dsymbols"></a>Function: <strong>foreign-bitfield-symbols</strong> <em>type value⇒ symbols</em></dt>
</dl>

<a name="Arguments-and-Values-9"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type</var></dt>
<dd><p>A bitfield type.
</p>
</dd>
<dt><var>value</var></dt>
<dd><p>An integer.
</p>
</dd>
<dt><var>symbols</var></dt>
<dd><p>A potentially shared list of symbols.
<code>nil</code>.
</p></dd>
</dl>

<a name="Description-9"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-bitfield-symbols</code> возвращает возможно совместно
используемый список символов, которые соответствуют значению <var>value</var> в <var>type</var>.
</p>
<a name="Examples-9"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defbitfield</span></i> flags
    <span class="paren2">(<span class="lisp-bg">flag-a 1</span>)</span>
    <span class="paren2">(<span class="lisp-bg">flag-b 2</span>)</span>
    <span class="paren2">(<span class="lisp-bg">flag-c 4</span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-bitfield-symbols 'flags #b101</span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg">FLAG-A FLAG-C</span>)</span>
</pre></div>

<a name="See-Also-9"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defbitfield">defbitfield</a> <br>
<a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a>
</p>

<hr>
<a name="foreign_002dbitfield_002dvalue"></a>
<div class="header">
<p>
Next: <a href="#foreign_002denum_002dkeyword" accesskey="n" rel="next">foreign-enum-keyword</a>, Previous: <a href="#foreign_002dbitfield_002dsymbols" accesskey="p" rel="prev">foreign-bitfield-symbols</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-bitfield-value</h4>
<a name="foreign_002dbitfield_002dvalue-1"></a>
<h3 class="heading">foreign-bitfield-value</h3>
<a name="Syntax-10"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dbitfield_002dvalue"></a>Function: <strong>foreign-bitfield-value</strong> <em>type symbols⇒ value</em></dt>
</dl>

<a name="Arguments-and-Values-10"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type</var></dt>
<dd><p>A <code>bitfield</code> type.
</p>
</dd>
<dt><var>symbol</var></dt>
<dd><p>A Lisp symbol.
</p>
</dd>
<dt><var>value</var></dt>
<dd><p>An integer.
</p></dd>
</dl>

<a name="Description-10"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-bitfield-value</code> возвращает значение <var>value</var> 
соотвествующее списку символов(<var>symbols</var>).
</p>
<a name="Examples-10"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defbitfield</span></i> flags
    <span class="paren2">(<span class="lisp-bg">flag-a 1</span>)</span>
    <span class="paren2">(<span class="lisp-bg">flag-b 2</span>)</span>
    <span class="paren2">(<span class="lisp-bg">flag-c 4</span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-bitfield-value 'flags '<span class="paren2">(<span class="lisp-bg">flag-a flag-c</span>)</span></span>)</span>
 ⇒ 5  ; #b101
</pre></div>

<a name="See-Also-10"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defbitfield">defbitfield</a> <br>
<a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>
</p>

<hr>
<a name="foreign_002denum_002dkeyword"></a>
<div class="header">
<p>
Next: <a href="#foreign_002denum_002dvalue" accesskey="n" rel="next">foreign-enum-value</a>, Previous: <a href="#foreign_002dbitfield_002dvalue" accesskey="p" rel="prev">foreign-bitfield-value</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-enum-keyword</h4>
<a name="foreign_002denum_002dkeyword-1"></a>
<h3 class="heading">foreign-enum-keyword</h3>
<a name="Syntax-11"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002denum_002dkeyword"></a>Function: <strong>foreign-enum-keyword</strong> <em>type value &amp;key errorp⇒ keyword</em></dt>
</dl>

<a name="Arguments-and-Values-11"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type</var></dt>
<dd><p>An <code>enum</code> type.
</p>
</dd>
<dt><var>value</var></dt>
<dd><p>An integer.
</p>
</dd>
<dt><var>errorp</var></dt>
<dd><p>If true (the default), signal an error if <var>value</var> is not defined
in <var>type</var>.  If false, <code>foreign-enum-keyword</code> returns
<code>nil</code>.
</p>
</dd>
<dt><var>keyword</var></dt>
<dd><p>A keyword symbol.
</p></dd>
</dl>

<a name="Description-11"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-enum-keyword</code> возвращает символ ключевое слово
которое соответствует значению <var>value</var> в типе <var>type</var>.
</p>
<p>Сообщение об ошибке выдается, если тип(<var>type</var>) не содержит значения<var>value</var>
и <var>errorp</var> равно true.
</p>
<a name="Examples-11"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> boolean
    <span class="keyword">:no</span>
    <span class="keyword">:yes</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-enum-keyword 'boolean 1</span>)</span>
 ⇒ :YES
</pre></div>

<a name="See-Also-11"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcenum">defcenum</a> <br>
<a href="#foreign_002denum_002dvalue">foreign-enum-value</a>
</p>

<hr>
<a name="foreign_002denum_002dvalue"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dslot_002dnames" accesskey="n" rel="next">foreign-slot-names</a>, Previous: <a href="#foreign_002denum_002dkeyword" accesskey="p" rel="prev">foreign-enum-keyword</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-enum-value</h4>
<a name="foreign_002denum_002dvalue-1"></a>
<h3 class="heading">foreign-enum-value</h3>
<a name="Syntax-12"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002denum_002dvalue"></a>Function: <strong>foreign-enum-value</strong> <em>type keyword &amp;key errorp⇒ value</em></dt>
</dl>

<a name="Arguments-and-Values-12"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type</var></dt>
<dd><p>An <code>enum</code> type.
</p>
</dd>
<dt><var>keyword</var></dt>
<dd><p>A keyword symbol.
</p>
</dd>
<dt><var>errorp</var></dt>
<dd><p>If true (the default), signal an error if <var>keyword</var> is not
defined in <var>type</var>.  If false, <code>foreign-enum-value</code> returns
<code>nil</code>.
</p>
</dd>
<dt><var>value</var></dt>
<dd><p>An integer.
</p></dd>
</dl>

<a name="Description-12"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-enum-value</code> возвращает значение <var>value</var>,
которое соответствует ключевому слову <var>keyword</var> в типе <var>type</var>.
</p>
<p>Сообщение об ошибке выдается, если тип <var>type</var> не содержит такого
ключевого слова <var>keyword</var>, и <var>errorp</var> равен true.
</p>
<a name="Examples-12"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> boolean
    <span class="keyword">:no</span>
    <span class="keyword">:yes</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-enum-value 'boolean <span class="keyword">:yes</span></span>)</span>
 ⇒ 1
</pre></div>

<a name="See-Also-12"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcenum">defcenum</a> <br>
<a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>
</p>

<hr>
<a name="foreign_002dslot_002dnames"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dslot_002doffset" accesskey="n" rel="next">foreign-slot-offset</a>, Previous: <a href="#foreign_002denum_002dvalue" accesskey="p" rel="prev">foreign-enum-value</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-slot-names</h4>
<a name="foreign_002dslot_002dnames-1"></a>
<h3 class="heading">foreign-slot-names</h3>
<a name="Syntax-13"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dslot_002dnames"></a>Function: <strong>foreign-slot-names</strong> <em>type⇒ names</em></dt>
</dl>

<a name="Arguments-and-Values-13"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type</var></dt>
<dd><p>A foreign struct type.
</p>
</dd>
<dt><var>names</var></dt>
<dd><p>A list.
</p></dd>
</dl>

<a name="Description-13"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-slot-names</code> возвращает потенциально
совместно используемый список имен <var>names</var> слотов для данного
типа(<var>type</var>) структуры. Этот список не имеет определенного порядка.
</p>
<a name="Examples-13"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> timeval
    <span class="paren2">(<span class="lisp-bg">tv-secs <span class="keyword">:long</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">tv-usecs <span class="keyword">:long</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-slot-names '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> timeval</span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg">TV-SECS TV-USECS</span>)</span>
</pre></div>

<a name="See-Also-13"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#foreign_002dslot_002doffset">foreign-slot-offset</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a> <br>
<a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a>
</p>

<hr>
<a name="foreign_002dslot_002doffset"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dslot_002dpointer" accesskey="n" rel="next">foreign-slot-pointer</a>, Previous: <a href="#foreign_002dslot_002dnames" accesskey="p" rel="prev">foreign-slot-names</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-slot-offset</h4>
<a name="foreign_002dslot_002doffset-1"></a>
<h3 class="heading">foreign-slot-offset</h3>
<a name="Syntax-14"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dslot_002doffset"></a>Function: <strong>foreign-slot-offset</strong> <em>type slot-name⇒ offset</em></dt>
</dl>

<a name="Arguments-and-Values-14"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type</var></dt>
<dd><p>A foreign struct type.
</p>
</dd>
<dt><var>slot-name</var></dt>
<dd><p>A symbol.
</p>
</dd>
<dt><var>offset</var></dt>
<dd><p>An integer.
</p></dd>
</dl>

<a name="Description-14"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-slot-offset</code> возвращает смещение(<var>offset</var>)
в байтах длял слота в типе внешней структуры.
</p>
<a name="Examples-14"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> timeval
    <span class="paren2">(<span class="lisp-bg">tv-secs <span class="keyword">:long</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">tv-usecs <span class="keyword">:long</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-slot-offset '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> timeval</span>)</span> 'tv-secs</span>)</span>
 ⇒ 0
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-slot-offset '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> timeval</span>)</span> 'tv-usecs</span>)</span>
 ⇒ 4
</pre></div>

<a name="See-Also-14"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#foreign_002dslot_002dnames">foreign-slot-names</a> <br>
<a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>
</p>

<hr>
<a name="foreign_002dslot_002dpointer"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dslot_002dvalue" accesskey="n" rel="next">foreign-slot-value</a>, Previous: <a href="#foreign_002dslot_002doffset" accesskey="p" rel="prev">foreign-slot-offset</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-slot-pointer</h4>
<a name="foreign_002dslot_002dpointer-1"></a>
<h3 class="heading">foreign-slot-pointer</h3>
<a name="Syntax-15"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dslot_002dpointer"></a>Function: <strong>foreign-slot-pointer</strong> <em>ptr type slot-name⇒ pointer</em></dt>
</dl>

<a name="Arguments-and-Values-15"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>A pointer to a structure.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A foreign structure type.
</p>
</dd>
<dt><var>slot-names</var></dt>
<dd><p>A slot name in the <var>type</var>.
</p>
</dd>
<dt><var>pointer</var></dt>
<dd><p>A pointer to the slot <var>slot-name</var>.
</p></dd>
</dl>

<a name="Description-15"></a>
<h4 class="subheading">Description</h4>
<p>Возвращает указатель на расположение слота с именем(<var>slot-name</var>)
во внешнем объекте с типом(<var>type</var>) записыая его в <var>ptr</var>. 
Возвращаенный указател указывает внутрь структруы. Указатель и память, на
которую он указывает имеют тоже самое время жизни, что и <var>ptr</var>.
</p>
<p>Для составных слотов это тоже самое значение, которое возвращает
<code>foreign-slot-value</code>.
</p>
<a name="Examples-15"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> point
    <span class="string">"Pointer structure."</span>
    <span class="paren2">(<span class="lisp-bg">x <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">y <span class="keyword">:int</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">ptr '<span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-slot-pointer ptr '<span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span> 'x</span>)</span></span>)</span>
 ⇒ #&lt;FOREIGN-ADDRESS #xBFFF6E60&gt;
  <span class="comment">;; Note: the exact pointer representation varies from lisp to lisp.
  </span>
</pre></div>

<a name="See-Also-15"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a> <br>
<a href="#foreign_002dslot_002dnames">foreign-slot-names</a> <br>
<a href="#foreign_002dslot_002doffset">foreign-slot-offset</a>
</p>

<hr>
<a name="foreign_002dslot_002dvalue"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dtype_002dalignment" accesskey="n" rel="next">foreign-type-alignment</a>, Previous: <a href="#foreign_002dslot_002dpointer" accesskey="p" rel="prev">foreign-slot-pointer</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-slot-value</h4>
<a name="foreign_002dslot_002dvalue-1"></a>
<h3 class="heading">foreign-slot-value</h3>
<a name="Syntax-16"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dslot_002dvalue"></a>Accessor: <strong>foreign-slot-value</strong> <em>ptr type slot-name⇒ object</em></dt>
</dl>

<a name="Arguments-and-Values-16"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>A pointer to a structure.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A foreign structure type.
</p>
</dd>
<dt><var>slot-name</var></dt>
<dd><p>A symbol naming a slot in the structure type.
</p>
</dd>
<dt><var>object</var></dt>
<dd><p>The object contained in the slot specified by <var>slot-name</var>.
</p></dd>
</dl>

<a name="Description-16"></a>
<h4 class="subheading">Description</h4>
<p>Для простых слотов, <code>foreign-slot-value</code> возвращает значение
объекта, такое как целое Lisp или указатель. В си это будет выражаться
как <code>ptr-&gt;slot</code>.
</p>
<p>Для составных слотов возвращается указатель внутрь структуры на
начало данных слота. В Си это будет выражаться как <code>&amp;ptr-&gt;slot</code>. 
Этот указатель или память, на которую он указывает, имеют тоже время
существования что и <var>ptr</var>.
</p>
<p>Имеются макросы компилятора для <code>foreign-slot-value</code> и
его расширения <code>setf</code>, которые открывают код для доступа
к памяти, когда <var>type</var> и <var>slot-names</var> являются
константами во время компиляции.
</p>
<a name="Examples-16"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> point
    <span class="string">"Pointer structure."</span>
    <span class="paren2">(<span class="lisp-bg">x <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">y <span class="keyword">:int</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">ptr '<span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span></span>)</span>
          <span class="comment">;; Initialize the slots
  </span>        <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">foreign-slot-value ptr '<span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span> 'x</span>)</span> 42
                <span class="paren3">(<span class="lisp-bg">foreign-slot-value ptr '<span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span> 'y</span>)</span> 42</span>)</span>
          <span class="comment">;; Return a list with the coordinates
  </span>        <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">x y</span>)</span> ptr <span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span></span>)</span>
            <span class="paren3">(<span class="lisp-bg">list x y</span>)</span></span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg">42 42</span>)</span>
</pre></div>

<a name="See-Also-16"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#foreign_002dslot_002dnames">foreign-slot-names</a> <br>
<a href="#foreign_002dslot_002doffset">foreign-slot-offset</a> <br>
<a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <br>
<a href="#with_002dforeign_002dslots">with-foreign-slots</a>
</p>

<hr>
<a name="foreign_002dtype_002dalignment"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dtype_002dsize" accesskey="n" rel="next">foreign-type-size</a>, Previous: <a href="#foreign_002dslot_002dvalue" accesskey="p" rel="prev">foreign-slot-value</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-type-alignment</h4>
<a name="foreign_002dtype_002dalignment-1"></a>
<h3 class="heading">foreign-type-alignment</h3>
<a name="Syntax-17"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dtype_002dalignment"></a>Function: <strong>foreign-type-alignment</strong> <em>type⇒ alignment</em></dt>
</dl>

<a name="Arguments-and-Values-17"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>alignment</var></dt>
<dd><p>An integer.
</p></dd>
</dl>

<a name="Description-17"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-type-alignment</code> возвращает выравнивание
(<var>alignment</var>) типа( <var>type</var>) в байтах.
</p>
<a name="Examples-17"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-alignment <span class="keyword">:char</span></span>)</span>
 ⇒ 1
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-alignment <span class="keyword">:short</span></span>)</span>
 ⇒ 2
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-alignment <span class="keyword">:int</span></span>)</span>
 ⇒ 4
</pre></div>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> foo
    <span class="paren2">(<span class="lisp-bg">a <span class="keyword">:char</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-alignment '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> foo</span>)</span></span>)</span>
 ⇒ 1
</pre></div>

<a name="See-Also-17"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dtype_002dsize">foreign-type-size</a>
</p>

<hr>
<a name="foreign_002dtype_002dsize"></a>
<div class="header">
<p>
Next: <a href="#free_002dconverted_002dobject" accesskey="n" rel="next">free-converted-object</a>, Previous: <a href="#foreign_002dtype_002dalignment" accesskey="p" rel="prev">foreign-type-alignment</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-type-size</h4>
<a name="foreign_002dtype_002dsize-1"></a>
<h3 class="heading">foreign-type-size</h3>
<a name="Syntax-18"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dtype_002dsize"></a>Function: <strong>foreign-type-size</strong> <em>type⇒ size</em></dt>
</dl>

<a name="Arguments-and-Values-18"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>size</var></dt>
<dd><p>An integer.
</p></dd>
</dl>

<a name="Description-18"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-type-size</code> возвращает размер(<var>size</var>)
типа(<var>type</var>) в байтах.  Он включает в себя любые отступы внутри и после,
представления в памяти, необходимые для создания массива объектов данного
типа(<var>type</var>).
</p>
<a name="Examples-18"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> foo
    <span class="paren2">(<span class="lisp-bg">a <span class="keyword">:double</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">c <span class="keyword">:char</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-size <span class="keyword">:double</span></span>)</span>
 ⇒ 8
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-size <span class="keyword">:char</span></span>)</span>
 ⇒ 1
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-size '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> foo</span>)</span></span>)</span>
 ⇒ 16
</pre></div>

<a name="See-Also-18"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dtype_002dalignment">foreign-type-alignment</a>
</p>

<hr>
<a name="free_002dconverted_002dobject"></a>
<div class="header">
<p>
Next: <a href="#free_002dtranslated_002dobject" accesskey="n" rel="next">free-translated-object</a>, Previous: <a href="#foreign_002dtype_002dsize" accesskey="p" rel="prev">foreign-type-size</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">free-converted-object</h4>
<a name="free_002dconverted_002dobject-1"></a>
<h3 class="heading">free-converted-object</h3>
<a name="Syntax-19"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-free_002dconverted_002dobject"></a>Function: <strong>free-converted-object</strong> <em>foreign-value type params</em></dt>
</dl>

<a name="Arguments-and-Values-19"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>foreign-value</var></dt>
<dd><p>The C object to be freed.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A <acronym>CFFI</acronym> type specifier.
</p>
</dd>
<dt><var>params</var></dt>
<dd><p>The state returned as the second value from <code>convert-to-foreign</code>;
used to implement the third argument to <code>free-translated-object</code>.
</p></dd>
</dl>

<a name="Description-19"></a>
<h4 class="subheading">Description</h4>

<p>Возвращаемое значение не указано.
</p>
<p>Это внешний интерфейс для обеспечения возможности преобразования типа.  
В реализации все внешние функции в конечном итоге определяются как обертки
преобразования типа вокруг примитивных вызовов вшнешних функций.
</p>
<p>Эта функция в основном для проверки процесса преобразования типа, и возможно,
для оптимизации особых случаев вызовов ваших внешних функций.
</p>
<p>Её поведение лучше описано в документации <code>free-translated-object</code>.
</p>
<a name="Examples-19"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-to-foreign <span class="string">"a boat"</span> <span class="keyword">:string</span></span>)</span>
 ⇒ #&lt;FOREIGN-ADDRESS #x097ACDC0&gt;
 ⇒ T
  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">free-converted-object * <span class="keyword">:string</span> t</span>)</span>
 ⇒ NIL
</pre></div>

<a name="See-Also-19"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#convert_002dfrom_002dforeign">convert-from-foreign</a> <br>
<a href="#convert_002dto_002dforeign">convert-to-foreign</a> <br>
<a href="#free_002dtranslated_002dobject">free-translated-object</a>
</p>

<hr>
<a name="free_002dtranslated_002dobject"></a>
<div class="header">
<p>
Next: <a href="#translate_002dfrom_002dforeign" accesskey="n" rel="next">translate-from-foreign</a>, Previous: <a href="#free_002dconverted_002dobject" accesskey="p" rel="prev">free-converted-object</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">free-translated-object</h4>
<a name="free_002dtranslated_002dobject-1"></a>
<h3 class="heading">free-translated-object</h3>
<a name="Syntax-20"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-free_002dtranslated_002dobject"></a>Generic Function: <strong>free-translated-object</strong> <em>value type-name param</em></dt>
</dl>

<a name="Arguments-and-Values-20"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>pointer</var></dt>
<dd><p>The foreign value returned by <code>translate-to-foreign</code>.
</p>
</dd>
<dt><var>type-name</var></dt>
<dd><p>A symbol naming a foreign type defined by <code>defctype</code>.
</p>
</dd>
<dt><var>param</var></dt>
<dd><p>The second value, if any, returned by <code>translate-to-foreign</code>.
</p></dd>
</dl>

<a name="Description-20"></a>
<h4 class="subheading">Description</h4>
<p>Эта обобщенная функция может быть специализирована пользовательским
кодом для автоматического освобождения внешних объектов, когда они передаются в
функции Си.
</p>
<p>Любые методы, определенные в этой обобщенной функции, должны
EQL-специализировать параметр <var>type-name</var> для символа определенного как
внешний тип через макрос <code>defctype</code>.
</p>
<a name="See-Also-20"></a>
<h4 class="subheading">См. также</h4>
<p><a href="#Foreign-Type-Translators">Foreign Type Translators</a> <br>
<a href="#translate_002dto_002dforeign">translate-to-foreign</a>
</p>

<hr>
<a name="translate_002dfrom_002dforeign"></a>
<div class="header">
<p>
Next: <a href="#translate_002dto_002dforeign" accesskey="n" rel="next">translate-to-foreign</a>, Previous: <a href="#free_002dtranslated_002dobject" accesskey="p" rel="prev">free-translated-object</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">translate-from-foreign</h4>
<a name="translate_002dfrom_002dforeign-1"></a>
<h3 class="heading">translate-from-foreign</h3>
<a name="Syntax-21"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-translate_002dfrom_002dforeign"></a>Generic Function: <strong>translate-from-foreign</strong> <em>foreign-value type-name                                        ⇒ lisp-value</em></dt>
</dl>

<a name="Arguments-and-Values-21"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>foreign-value</var></dt>
<dd><p>The foreign value to convert to a Lisp object.
</p>
</dd>
<dt><var>type-name</var></dt>
<dd><p>A symbol naming a foreign type defined by <code>defctype</code>.
</p>
</dd>
<dt><var>lisp-value</var></dt>
<dd><p>The lisp value to pass in place of <code>foreign-value</code> to Lisp code.
</p></dd>
</dl>

<a name="Description-21"></a>
<h4 class="subheading">Description</h4>
<p>Эта обобщенная функция вызывается <acronym>CFFI</acronym> для преобразования
внешнего значения в значение Lisp, например, при возврате из внешней функции, 
передаче аргументов в функцию обратного вызова, или доступе к внешней переменной.
</p>
<p>Чтобыб расширить систему типов <acronym>CFFI</acronym>, выполняя пользовательские
преобразования, этот метод может быть специализирован по <small>EQL</small>-специализирующему
имени типа(<code>type-name</code>) для символа, обозначающего внешний тип определенный с 
помощью <code>defctype</code>.  Этот метод должен возвращать соответствующее значение  Lisp
для использования внешнего значения.
</p>
<p>Результаты не определены, если параметр <code>type-name</code> специализирован
каки-либо образом, кроме <small>EQL</small> специлизации для внешнего типа
определенного с помощью <code>defctype</code>.  В частности, преобразования не могут 
быть определены для встроенных типов.
</p>
<a name="See-Also-21"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#Foreign-Type-Translators">Foreign Type Translators</a> <br>
<a href="#translate_002dto_002dforeign">translate-to-foreign</a> <br>
<a href="#free_002dtranslated_002dobject">free-translated-object</a>
</p>

<hr>
<a name="translate_002dto_002dforeign"></a>
<div class="header">
<p>
Next: <a href="#translate_002dinto_002dforeign_002dmemory" accesskey="n" rel="next">translate-into-foreign-memory</a>, Previous: <a href="#translate_002dfrom_002dforeign" accesskey="p" rel="prev">translate-from-foreign</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">translate-to-foreign</h4>
<a name="translate_002dto_002dforeign-1"></a>
<h3 class="heading">translate-to-foreign</h3>
<a name="Syntax-22"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-translate_002dto_002dforeign"></a>Generic Function: <strong>translate-to-foreign</strong> <em>lisp-value type-name                                      ⇒ foreign-value, alloc-param</em></dt>
</dl>

<a name="Arguments-and-Values-22"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>lisp-value</var></dt>
<dd><p>The Lisp value to convert to foreign representation.
</p>
</dd>
<dt><var>type-name</var></dt>
<dd><p>A symbol naming a foreign type defined by <code>defctype</code>.
</p>
</dd>
<dt><var>foreign-value</var></dt>
<dd><p>The foreign value to pass in place of <code>lisp-value</code> to foreign code.
</p>
</dd>
<dt><var>alloc-param</var></dt>
<dd><p>If present, this value will be passed to
<code>free-translated-object</code>.
</p></dd>
</dl>

<a name="Description-22"></a>
<h4 class="subheading">Description</h4>
<p>Эта обобщенная функция вызывается <acronym>CFFI</acronym> для преобразования
значения Lisp во внешнее значение, например, при передаче аргументов во
внешнюю функцию, возврата значения из функции обратного вызова, или установке 
значения внешней переменной.  âВнешнее значение(foreign value)â это то,
которое подходит для передачи к следующему преобразователю более низкого уровня,
включая преобразователей низкого уровня, которые в конечном итоге незаметно
вызываются в <acronym>CFFI</acronym>.
</p>
<p>Чтобы расширить систему типов <acronym>CFFI</acronym>, выполнением пользовательских преобразований,
этот метод может быть специализирован по <small>EQL</small>-специлизирующему имени типа(<code>type-name</code>)
для символа, обзначающего внешний тип, определенный с помощью <code>defctype</code>.  Этот
метод дожен возвращать соответствующее значение для использования вместо значения Lisp.
</p>
<p>в тех случаях, когда <acronym>CFFI</acronym> не может определить время жизни внешнего
объекта, возвращаемого этим методом, он вызовет <code>free-translated-object</code>
для внешнего объекта в соответствующее время.  Если <code>translate-to-foreign</code> 
возвращает второе значение, оно будет передано в качестве аргумента(<code>param</code>) в
<code>free-translated-object</code>.  Он может быть использован для установления связи
между методами выделения и освобождения памяти объекта.
</p>
<p>Результаты не определены, если параметр <code>type-name</code> специализирован
каким-либо образом, кроме  <small>EQL</small> специлизатора для стороннего типа
определенного с помощью <code>defctype</code>.  В частности, преобразователи не могут
быть определены для встроенных типов.
</p>
<a name="See-Also-22"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#Foreign-Type-Translators">Foreign Type Translators</a> <br>
<a href="#translate_002dfrom_002dforeign">translate-from-foreign</a> <br>
<a href="#free_002dtranslated_002dobject">free-translated-object</a>
</p>

<hr>
<a name="translate_002dinto_002dforeign_002dmemory"></a>
<div class="header">
<p>
Next: <a href="#with_002dforeign_002dslots" accesskey="n" rel="next">with-foreign-slots</a>, Previous: <a href="#translate_002dto_002dforeign" accesskey="p" rel="prev">translate-to-foreign</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">translate-into-foreign-memory</h4>
<a name="translate_002dinto_002dforeign_002dmemory-1"></a>
<h3 class="heading">translate-into-foreign-memory</h3>
<a name="Syntax-23"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-translate_002dinto_002dforeign_002dmemory"></a>Generic Function: <strong>translate-into-foreign-memory</strong> <em>lisp-value type-name pointer</em></dt>
</dl>

<a name="Arguments-and-Values-23"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>lisp-value</var></dt>
<dd><p>The Lisp value to convert to foreign representation.
</p>
</dd>
<dt><var>type-name</var></dt>
<dd><p>A symbol or list <code>(:struct <var>structure-name</var>)</code> naming a foreign type defined by <code>defctype</code>.
</p>
</dd>
<dt><var>pointer</var></dt>
<dd><p>The foreign pointer where the translated object should be stored.
</p></dd>
</dl>

<a name="Description-23"></a>
<h4 class="subheading">Description</h4>
<p>Преобразует значение Lisp во внешнюю память, указанную указателем.  
Возвращаемое значение не используется.
</p>

<hr>
<a name="with_002dforeign_002dslots"></a>
<div class="header">
<p>
Previous: <a href="#translate_002dinto_002dforeign_002dmemory" accesskey="p" rel="prev">translate-into-foreign-memory</a>, Up: <a href="#Foreign-Types" accesskey="u" rel="up">Foreign Types</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">with-foreign-slots</h4>
<a name="with_002dforeign_002dslots-1"></a>
<h3 class="heading">with-foreign-slots</h3>
<a name="Syntax-24"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-with_002dforeign_002dslots"></a>Macro: <strong>with-foreign-slots</strong> <em>(vars ptr type) &amp;body body</em></dt>
</dl>

<a name="Arguments-and-Values-24"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>vars</var></dt>
<dd><p>A list with each element a symbol, or list of length two with the
first element <code>:pointer</code> and the second a symbol.
</p>
</dd>
<dt><var>ptr</var></dt>
<dd><p>A foreign pointer to a structure.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A structure type.
</p>
</dd>
<dt><var>body</var></dt>
<dd><p>A list of forms to be executed.
</p></dd>
</dl>

<a name="Description-24"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>with-foreign-slots</code> создает символьные макросы для каждой
переменной var из <var>vars</var> для ссылки на внешние слоты в <var>ptr</var> 
для типа <var>type</var>.
Если var это список, начинающийся с указателя <code>:pointer</code>, он будет
привязывать этот указатель к слоту(а не значению). Он похож на макрос Common
Lispâs <code>with-slots</code>.
</p>
<a name="Examples-20"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> tm
    <span class="paren2">(<span class="lisp-bg">sec <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">min <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">hour <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">mday <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">mon  <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">year <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">wday <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">yday <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">isdst  <span class="keyword">:boolean</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">zone   <span class="keyword">:string</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">gmtoff <span class="keyword">:long</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">time <span class="keyword">:int</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">mem-ref time <span class="keyword">:int</span></span>)</span>
                <span class="paren3">(<span class="lisp-bg">foreign-funcall <span class="string">"time"</span> <span class="keyword">:pointer</span> <span class="paren4">(<span class="lisp-bg">null-pointer</span>)</span> <span class="keyword">:int</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"gmtime"</span> <span class="keyword">:pointer</span> time <span class="paren3">(<span class="lisp-bg"><span class="keyword">:pointer</span> <span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> tm</span>)</span></span>)</span></span>)</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #x102A30&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">sec min hour mday mon year</span>)</span> * <span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> tm</span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">format nil <span class="string">"~A:~A:~A, ~A/~A/~A"</span>
                  hour min sec <span class="paren3">(<span class="lisp-bg">+ 1900 year</span>)</span> mon mday</span>)</span></span>)</span>
 ⇒ "7:22:47, 2005/8/2"
</pre></div>

<a name="See-Also-23"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#defcunion">defcunion</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>
</p>

<hr>
<a name="Pointers"></a>
<div class="header">
<p>
Next: <a href="#Strings" accesskey="n" rel="next">Strings</a>, Previous: <a href="#Foreign-Types" accesskey="p" rel="prev">Foreign Types</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Pointers-1"></a>
<h2 class="chapter">7 Указатели</h2>

<p>На все Си данные в <acronym>CFFI</acronym> ссылаются через указатели(pointers).
Это включает в себя определённые переменные Си, которые содержат
непосредственные значения, и целые числа.
</p>
<p>Чтобы понять, почему это так, рассмотрим случай целого числа Си. Это не 
только произвольное представление целого числа, совпадающее с Lisp fixnums; 
целое число Си(integer) имеет определенный битовый шаблон в памяти, определенный
Си <acronym>ABI</acronym>.  Lisp не имеет такого ограничения на свои fixnums;
поэтому имеет смысл думать о fixnums как о целых числах в Си, если вы предполагаете
что <acronym>CFFI</acronym> преобразует их при необходимости, например при
сохранении для использования в вызове функии Си, или в качестве значения
переенной Си.  Для этого необходимо определить область памяти<a name="DOCF11" href="#FOOT11"><sup>11</sup></a>,
представленную через эффективный адрес, и сохранить его(значение) там.
</p>
<p>Из-за этого разделения имеет смысл манипулировать необработанными данными
Си в Лиспе, только через указатели на них.  Например, хотя может существовать
представление структруры(<code>struct</code>) Лисп, которое преобразуется в
Си во время хранения, вы можете манипулировать её необработанными данными
только через указатель. Компилятор Си делает это также, хотя и неформально.
</p>
<table class="menu" cellspacing="0" border="0">
<tbody><tr><td valign="top" align="left">• <a href="#Basic-Pointer-Operations" accesskey="1">Basic Pointer Operations</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Allocating-Foreign-Memory" accesskey="2">Allocating Foreign Memory</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Accessing-Foreign-Memory" accesskey="3">Accessing Foreign Memory</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Dictionary

</pre></th></tr><tr><td valign="top" align="left">• <a href="#foreign_002dfree" accesskey="4">foreign-free</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dalloc" accesskey="5">foreign-alloc</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dsymbol_002dpointer" accesskey="6">foreign-symbol-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#inc_002dpointer" accesskey="7">inc-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#incf_002dpointer" accesskey="8">incf-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#make_002dpointer" accesskey="9">make-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#mem_002daptr">mem-aptr</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#mem_002daref">mem-aref</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#mem_002dref">mem-ref</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#null_002dpointer">null-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#null_002dpointer_002dp">null-pointer-p</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#pointerp">pointerp</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#pointer_002daddress">pointer-address</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#pointer_002deq">pointer-eq</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dobject">with-foreign-object</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dobjects">with-foreign-objects</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dpointer">with-foreign-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
</tbody></table>

<hr>
<a name="Basic-Pointer-Operations"></a>
<div class="header">
<p>
Next: <a href="#Allocating-Foreign-Memory" accesskey="n" rel="next">Allocating Foreign Memory</a>, Previous: <a href="#Pointers" accesskey="p" rel="prev">Pointers</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Basic-Pointer-Operations-1"></a>
<h3 class="section">7.1 Базовые операции с указателями</h3>

<p>Правильно манипулировать указателями можно с помощью большинства
других операций определенныхй в словаре указателей(Pointers dictionary),
таких как <code>make-pointer</code>, <code>pointer-address</code>, и <code>pointer-eq</code>.
При их использовании имейте в виду, что они просто манипулируют представлением
указателей в Lisp, а не значениями, на которые они указывают.
</p>
<dl>
<dt><a name="index-foreign_002dpointer"></a>Тип Lisp: <strong>foreign-pointer</strong></dt>
<dd><p>Представления указателей различаются от реализации к реализации и имеют
разные типы.  <code>foreign-pointer</code> представляет псевдоним
переносимого типа каждому из этих типов.
</p></dd></dl>

<hr>
<a name="Allocating-Foreign-Memory"></a>
<div class="header">
<p>
Next: <a href="#Accessing-Foreign-Memory" accesskey="n" rel="next">Accessing Foreign Memory</a>, Previous: <a href="#Basic-Pointer-Operations" accesskey="p" rel="prev">Basic Pointer Operations</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Allocating-Foreign-Memory-1"></a>
<h3 class="section">7.2 Выделение внешней памяти</h3>

<p><acronym>CFFI</acronym> обеспечивает поддержку выделение памяти для
стека и Си кучи(heap). Выделение памяти из стека, выполняемое с помощью
 <code>with-foreign-object</code>, иногда назвается âдинамическим(dynamic)â
распределением в Lisp, потому что память выделенная таким образом, имеет
димнаическую протяженность существования(dynamic extent), почти как с
привязками <code>let</code> специальных переменных.
</p>
<p>Её не следует путать с тем, что в Си называется âдинамическим(dynamic  allocation)â
выделением памяти, или тем, что делается с помощью <code>malloc</code> 
и её друзей.  Такого рода выделение из кучи выполняется с помощью
 <code>foreign-alloc</code>, создающей объекты, которые существуют пока
не будут освобождены с помощью <code>foreign-free</code>.
</p>

<hr>
<a name="Accessing-Foreign-Memory"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dfree" accesskey="n" rel="next">foreign-free</a>, Previous: <a href="#Allocating-Foreign-Memory" accesskey="p" rel="prev">Allocating Foreign Memory</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Accessing-Foreign-Memory-1"></a>
<h3 class="section">7.3 Доступ к внешней памяти</h3>

<p>При манипулировании необработанным данными Си, учитывайте, что все 
укзатели указывают на массив.  когда вам необходимо только одно Си значение.,
например одиночная структура(<code>struct</code>), этот массив имеет только
одно такое значение. Стоит помнить, что всё является массивом, потому что
это таже семантика, которую Си навязывает изначально.
</p>
<p>Доступ к значениям Си осуществляется как  <code>setf</code>-доступных мест определенных
с помощью <code>mem-aref</code> и <code>mem-ref</code>.  При наличии указателя и
типа <acronym>CFFI</acronym> (см. <a href="#Foreign-Types">Внешние типы</a>), любой из
них разименует указатель, преобразуя данные Си обратно в Lisp, и возвращая
результат указанного преобразования, выполняя обратную операцию при
<code>setf</code>(установке значения).  Чтобы решить, какой из них использовать,
подумайте, будете ли вы использовать оператор индекса массива <code>[<var>n</var>]</code> 
или разыменовывание указателя <code>*</code> в Си; Используйте <code>mem-aref</code> 
для индексированных массивов и <code>mem-ref</code> для разыменовывания указателя.
</p>

<hr>
<a name="foreign_002dfree"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dalloc" accesskey="n" rel="next">foreign-alloc</a>, Previous: <a href="#Accessing-Foreign-Memory" accesskey="p" rel="prev">Accessing Foreign Memory</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-free</h4>
<a name="foreign_002dfree-1"></a>
<h3 class="heading">foreign-free</h3>
<a name="Syntax-25"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dfree"></a>Function: <strong>foreign-free</strong> <em>ptr⇒ undefined</em></dt>
</dl>

<a name="Arguments-and-Values-25"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>A foreign pointer.
</p></dd>
</dl>

<a name="Description-25"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-free</code> освобождает память указываемую <code>ptr</code> 
ранее выделенную  <code>foreign-alloc</code>. Последствия освобождения данного указателя
выполненые дважды не определены.
</p>
<a name="Examples-21"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #x1022E0&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-free *</span>)</span>
 ⇒ NIL
</pre></div>

<a name="See-Also-24"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dalloc">foreign-alloc</a> <br>
<a href="#with_002dforeign_002dpointer">with-foreign-pointer</a>
</p>

<hr>
<a name="foreign_002dalloc"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dsymbol_002dpointer" accesskey="n" rel="next">foreign-symbol-pointer</a>, Previous: <a href="#foreign_002dfree" accesskey="p" rel="prev">foreign-free</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-alloc</h4>
<a name="foreign_002dalloc-1"></a>
<h3 class="heading">foreign-alloc</h3>
<a name="Syntax-26"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dalloc"></a>Function: <strong>foreign-alloc</strong> <em>type &amp;key initial-element initial-contents (count 1)                         null-terminated-p⇒ pointer</em></dt>
</dl>

<a name="Arguments-and-Values-26"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>initial-element</var></dt>
<dd><p>A Lisp object.
</p>
</dd>
<dt><var>initial-contents</var></dt>
<dd><p>A sequence.
</p>
</dd>
<dt><var>count</var></dt>
<dd><p>An integer. Defaults to 1 or the length of <var>initial-contents</var> if
supplied.
</p>
</dd>
<dt><var>null-terminated-p</var></dt>
<dd><p>A boolean, false by default.
</p>
</dd>
<dt><var>pointer</var></dt>
<dd><p>A foreign pointer to the newly allocated memory.
</p></dd>
</dl>

<a name="Description-26"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-alloc</code> выделяет необходимую память для хранения
<var>count</var> объектов типа(<var>type</var>) и возвращает
указатель(<var>pointer</var>). Эта память должна быть явно освобождена
с использованием <code>foreign-free</code>, если она более не требуется.
</p>
<p>Если указан <var>initial-element</var>, он использууется для инициализации
<var>count</var> объектов, которые содержит вновь выделенная память.
</p>
<p>Если указан <var>initial-contents</var>, он должен иметь длину меньшую или
равную <var>count</var> и каждый его элемент будет использоваться для 
инициализации содержимого вновь выделенной памяти.
</p>
<p>Если <var>count</var> опущен, а <var>initial-contents</var> указан, по
умолчанию используется длина <code>(length <var>initial-contents</var>)</code>.
</p>
<p><var>initial-element</var> и <var>initial-contents</var> являются взаимоисключающими
праметрами.
</p>
<p>Когда <var>null-terminated-p</var> равно true,
Элементы <code>(1+ (max <var>count</var> (length <var>initial-contents</var>)))</code> 
размещаются, а последний устанавливается в ноль(<code>NULL</code>). Обратите внимаение,
что в этом случае типом(<var>type</var>) должен быть тип указателя (т.е. тип который
канонизируется(приводиться) к <code>:pointer</code>), oв противном случае сообщается
об ошибке.
</p>
<a name="Examples-22"></a>
<h4 class="subheading">Examples</h4>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:char</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #x102D80&gt;     ; A pointer to 1 byte of memory.

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:char</span> <span class="keyword">:count</span> 20</span>)</span>
 ⇒ #&lt;A Mac Pointer #x1024A0&gt;     ; A pointer to 20 bytes of memory.

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span> <span class="keyword">:initial-element</span> 12</span>)</span>
 ⇒ #&lt;A Mac Pointer #x1028B0&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">mem-ref * <span class="keyword">:int</span></span>)</span>
 ⇒ 12

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span> <span class="keyword">:initial-contents</span> '<span class="paren2">(<span class="lisp-bg">1 2 3</span>)</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #x102950&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 3
              collect <span class="paren2">(<span class="lisp-bg">mem-aref * <span class="keyword">:int</span> i</span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg">1 2 3</span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span> <span class="keyword">:initial-contents</span> #<span class="paren2">(<span class="lisp-bg">1 2 3</span>)</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #x102960&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 3
              collect <span class="paren2">(<span class="lisp-bg">mem-aref * <span class="keyword">:int</span> i</span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg">1 2 3</span>)</span>

  <span class="comment">;;; Allocate a char** pointer that points to newly allocated memory
  </span><span class="comment">;;; by the :string type translator for the string "foo".
  </span>CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:string</span> <span class="keyword">:initial-element</span> <span class="string">"foo"</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #x102C40&gt;
</pre></div>

<div class="lisp">
<pre class="lisp">  <span class="comment">;;; Allocate a null-terminated array of strings.
  </span><span class="comment">;;; (Note: FOREIGN-STRING-TO-LISP returns NIL when passed a null pointer)
  </span>CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:string</span>
                       <span class="keyword">:initial-contents</span> '<span class="paren2">(<span class="lisp-bg"><span class="string">"foo"</span> <span class="string">"bar"</span> <span class="string">"baz"</span></span>)</span>
                       <span class="keyword">:null-terminated-p</span> t</span>)</span>
 ⇒ #&lt;A Mac Pointer #x102D20&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 4
              collect <span class="paren2">(<span class="lisp-bg">mem-aref * <span class="keyword">:string</span> i</span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg"><span class="string">"foo"</span> <span class="string">"bar"</span> <span class="string">"baz"</span> NIL</span>)</span>
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
          <span class="paren2">(<span class="lisp-bg">dotimes <span class="paren3">(<span class="lisp-bg">i 3</span>)</span>
            <span class="paren3">(<span class="lisp-bg">foreign-free <span class="paren4">(<span class="lisp-bg">mem-aref ** <span class="keyword">:pointer</span> i</span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-free **</span>)</span></span>)</span>
 ⇒ nil
</pre></div>

<a name="See-Also-25"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dfree">foreign-free</a> <br>
<a href="#with_002dforeign_002dobject">with-foreign-object</a> <br>
<a href="#with_002dforeign_002dpointer">with-foreign-pointer</a>
</p>

<hr>
<a name="foreign_002dsymbol_002dpointer"></a>
<div class="header">
<p>
Next: <a href="#inc_002dpointer" accesskey="n" rel="next">inc-pointer</a>, Previous: <a href="#foreign_002dalloc" accesskey="p" rel="prev">foreign-alloc</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-symbol-pointer</h4>
<a name="foreign_002dsymbol_002dpointer-1"></a>
<h3 class="heading">foreign-symbol-pointer</h3>
<a name="Syntax-27"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dsymbol_002dpointer"></a>Function: <strong>foreign-symbol-pointer</strong> <em>foreign-name &amp;key library⇒ pointer</em></dt>
</dl>

<a name="Arguments-and-Values-27"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>foreign-name</var></dt>
<dd><p>A string.
</p>
</dd>
<dt><var>pointer</var></dt>
<dd><p>A foreign pointer, or <code>nil</code>.
</p>
</dd>
<dt><var>library</var></dt>
<dd><p>A Lisp symbol or an instance of <code>foreign-library</code>.
</p></dd>
</dl>

<a name="Description-27"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-symbol-pointer</code> вернет внешний указатель
соответствующий внешнему символу, обозначенному строкой
<var>foreign-name</var>.  Если внешний символ с именем <var>foreign-name</var>
не существует, возвращается <code>nil</code>.
</p>
<p>Искажение ABI имени будет выполняться на <var>foreign-name</var> 
с помощью <code>foreign-symbol-pointer</code>, если это необходимо. 
(например: добавление нижнего подчеркивания на darwin/ppc)
</p>
<p><var>library</var> должна  именовать внешнюю библиотеку в соответствии с
определением <code>define-foreign-library</code>, <code>:default</code> (которое является
значением по умолчанию) или экземпляром <code>foreign-library</code>, возвращаемым
функцией <code>load-foreign-library</code>.
</p>
<p><strong>Важное примечание:</strong> не храните указатели в сохраненных ядрах Lisp,
так как внешняя библиотека(foreign-library) может быть перемещена между сеансами.
</p>
<a name="Examples-23"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-symbol-pointer <span class="string">"errno"</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #xA0008130&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-symbol-pointer <span class="string">"strerror"</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #x9002D0F8&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall-pointer * <span class="paren2">(<span class="lisp-bg"></span>)</span> <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg">mem-ref ** <span class="keyword">:int</span></span>)</span> <span class="keyword">:string</span></span>)</span>
 ⇒ "No such file or directory"

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-symbol-pointer <span class="string">"inexistent symbol"</span></span>)</span>
 ⇒ NIL
</pre></div>

<a name="See-Also-26"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcvar">defcvar</a>
</p>

<hr>
<a name="inc_002dpointer"></a>
<div class="header">
<p>
Next: <a href="#incf_002dpointer" accesskey="n" rel="next">incf-pointer</a>, Previous: <a href="#foreign_002dsymbol_002dpointer" accesskey="p" rel="prev">foreign-symbol-pointer</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">inc-pointer</h4>
<a name="inc_002dpointer-1"></a>
<h3 class="heading">inc-pointer</h3>
<a name="Syntax-28"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-inc_002dpointer"></a>Function: <strong>inc-pointer</strong> <em>pointer offset⇒ new-pointer</em></dt>
</dl>

<a name="Arguments-and-Values-28"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>pointer</var></dt>
<dt><var>new-pointer</var></dt>
<dd><p>A foreign pointer.
</p>
</dd>
<dt><var>offset</var></dt>
<dd><p>An integer.
</p></dd>
</dl>

<a name="Description-28"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>inc-pointer</code> будет возвращаеть новый указатель <var>new-pointer</var> 
указывающий на смещенние на <var>offset</var> байт за указателем <var>pointer</var>.
</p>
<a name="Examples-24"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-alloc <span class="string">"Common Lisp"</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #x102EA0&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">inc-pointer * 7</span>)</span>
 ⇒ #&lt;A Mac Pointer #x102EA7&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-to-lisp *</span>)</span>
 ⇒ "Lisp"
</pre></div>

<a name="See-Also-27"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#incf_002dpointer">incf-pointer</a> <br>
<a href="#make_002dpointer">make-pointer</a> <br>
<a href="#pointerp">pointerp</a> <br>
<a href="#null_002dpointer">null-pointer</a> <br>
<a href="#null_002dpointer_002dp">null-pointer-p</a>
</p>

<hr>
<a name="incf_002dpointer"></a>
<div class="header">
<p>
Next: <a href="#make_002dpointer" accesskey="n" rel="next">make-pointer</a>, Previous: <a href="#inc_002dpointer" accesskey="p" rel="prev">inc-pointer</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">incf-pointer</h4>
<a name="incf_002dpointer-1"></a>
<h3 class="heading">incf-pointer</h3>
<a name="Syntax-29"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-incf_002dpointer"></a>Macro: <strong>incf-pointer</strong> <em>place &amp;optional (offset 1)⇒ new-pointer</em></dt>
</dl>

<a name="Arguments-and-Values-29"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>place</var></dt>
<dd><p>A <code>setf</code> place.
</p>
</dd>
<dt><var>new-pointer</var></dt>
<dd><p>A foreign pointer.
</p>
</dd>
<dt><var>offset</var></dt>
<dd><p>An integer.
</p></dd>
</dl>

<a name="Description-29"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>incf-pointer</code> берет внешний указатель из
<var>place</var> и создает новый указатель <var>new-pointer</var>,
величенный на <var>offset</var> байтов и сохраняет его обратно в <var>place</var>.
</p>
<a name="Examples-25"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defparameter</span></i> <span class="special">*two-words*</span> <span class="paren2">(<span class="lisp-bg">foreign-string-alloc <span class="string">"Common Lisp"</span></span>)</span></span>)</span>
 ⇒ *TWO-WORDS*
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defparameter</span></i> <span class="special">*one-word*</span> <span class="special">*two-words*</span></span>)</span>
 ⇒ *ONE-WORD*
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">incf-pointer <span class="special">*one-word*</span> 7</span>)</span>
 ⇒ #.<span class="paren1">(<span class="lisp-bg">SB-SYS:INT-SAP #X00600457</span>)</span>
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-to-lisp <span class="special">*one-word*</span></span>)</span>
 ⇒ "Lisp"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-to-lisp <span class="special">*two-words*</span></span>)</span>
 ⇒ "Common Lisp"
</pre></div>

<a name="See-Also-28"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#inc_002dpointer">inc-pointer</a> <br>
<a href="#make_002dpointer">make-pointer</a> <br>
<a href="#pointerp">pointerp</a> <br>
<a href="#null_002dpointer">null-pointer</a> <br>
<a href="#null_002dpointer_002dp">null-pointer-p</a>
</p>

<hr>
<a name="make_002dpointer"></a>
<div class="header">
<p>
Next: <a href="#mem_002daptr" accesskey="n" rel="next">mem-aptr</a>, Previous: <a href="#incf_002dpointer" accesskey="p" rel="prev">incf-pointer</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">make-pointer</h4>
<a name="make_002dpointer-1"></a>
<h3 class="heading">make-pointer</h3>
<a name="Syntax-30"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-make_002dpointer"></a>Function: <strong>make-pointer</strong> <em>address⇒ ptr</em></dt>
</dl>

<a name="Arguments-and-Values-30"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>address</var></dt>
<dd><p>An integer.
</p>
</dd>
<dt><var>ptr</var></dt>
<dd><p>A foreign pointer.
</p></dd>
</dl>

<a name="Description-30"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>make-pointer</code> вернет внешний указатель, указывающий
на адрес <var>address</var>.
</p>
<a name="Examples-26"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">make-pointer 42</span>)</span>
 ⇒ #&lt;FOREIGN-ADDRESS #x0000002A&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointerp *</span>)</span>
 ⇒ T
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointer-address **</span>)</span>
 ⇒ 42
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">inc-pointer <span class="special">***</span> -42</span>)</span>
 ⇒ #&lt;FOREIGN-ADDRESS #x00000000&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">null-pointer-p *</span>)</span>
 ⇒ T
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">typep ** 'foreign-pointer</span>)</span>
 ⇒ T
</pre></div>

<a name="See-Also-29"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#inc_002dpointer">inc-pointer</a> <br>
<a href="#null_002dpointer">null-pointer</a> <br>
<a href="#null_002dpointer_002dp">null-pointer-p</a> <br>
<a href="#pointerp">pointerp</a> <br>
<a href="#pointer_002daddress">pointer-address</a> <br>
<a href="#pointer_002deq">pointer-eq</a> <br>
<a href="#mem_002dref">mem-ref</a>
</p>

<hr>
<a name="mem_002daptr"></a>
<div class="header">
<p>
Next: <a href="#mem_002daref" accesskey="n" rel="next">mem-aref</a>, Previous: <a href="#make_002dpointer" accesskey="p" rel="prev">make-pointer</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">mem-aptr</h4>
<a name="mem_002daptr-1"></a>
<h3 class="heading">mem-aptr</h3>
<a name="Syntax-31"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-mem_002daptr"></a>Accessor: <strong>mem-aptr</strong> <em>ptr type &amp;optional (index 0)</em></dt>
</dl>

<a name="Arguments-and-Values-31"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>A foreign pointer.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>index</var></dt>
<dd><p>An integer.
</p>
</dd>
<dt><var>new-value</var></dt>
<dd><p>A Lisp value compatible with <var>type</var>.
</p></dd>
</dl>

<a name="Description-31"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>mem-aptr</code> находит указатель на элемент массива.
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">mem-aptr ptr type n</span>)</span>

  <span class="comment">;; is identical to:
  </span> 
  <span class="paren1">(<span class="lisp-bg">inc-pointer ptr <span class="paren2">(<span class="lisp-bg">* n <span class="paren3">(<span class="lisp-bg">foreign-type-size type</span>)</span></span>)</span></span>)</span>
</pre></div>

<a name="Examples-27"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">str <span class="string">"Hello, foreign world!"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">mem-aptr str <span class="keyword">:char</span> 6</span>)</span></span>)</span>
 ⇒ #.<span class="paren1">(<span class="lisp-bg">SB-SYS:INT-SAP #X0063D4B6</span>)</span>
</pre></div>

<hr>
<a name="mem_002daref"></a>
<div class="header">
<p>
Next: <a href="#mem_002dref" accesskey="n" rel="next">mem-ref</a>, Previous: <a href="#mem_002daptr" accesskey="p" rel="prev">mem-aptr</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">mem-aref</h4>
<a name="mem_002daref-1"></a>
<h3 class="heading">mem-aref</h3>
<a name="Syntax-32"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-mem_002daref"></a>Accessor: <strong>mem-aref</strong> <em>ptr type &amp;optional (index 0)</em></dt>
</dl>

<p>(setf (<strong>mem-aref</strong> <em>ptr type &amp;optional (index 0)) new-value</em>)
</p>
<a name="Arguments-and-Values-32"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>A foreign pointer.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>index</var></dt>
<dd><p>An integer.
</p>
</dd>
<dt><var>new-value</var></dt>
<dd><p>A Lisp value compatible with <var>type</var>.
</p></dd>
</dl>

<a name="Description-32"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>mem-aref</code> аналогична <code>mem-ref</code>, но автоматически
рассчитывает смещение по индексу(<var>index</var>).
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">mem-aref ptr type n</span>)</span>

  <span class="comment">;; is identical to:
  </span> 
  <span class="paren1">(<span class="lisp-bg">mem-ref ptr type <span class="paren2">(<span class="lisp-bg">* n <span class="paren3">(<span class="lisp-bg">foreign-type-size type</span>)</span></span>)</span></span>)</span>
</pre></div>

<a name="Examples-28"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">str <span class="string">"Hello, foreign world!"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">mem-aref str <span class="keyword">:char</span> 6</span>)</span></span>)</span>
 ⇒ 32
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">code-char *</span>)</span>
 ⇒ #\Space

  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">array <span class="keyword">:int</span> 10</span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i below 10
                do <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span> <span class="paren4">(<span class="lisp-bg">random 100</span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i below 10 collect <span class="paren3">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span></span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg">22 7 22 52 69 1 46 93 90 65</span>)</span>
</pre></div>

<a name="Compatibility-Note"></a>
<h4 class="subheading">Compatibility Note</h4>

<p>Для совместимости со старыми версиями CFFI, <a href="#mem_002daref">mem-aref</a> будет
создавать указатель для устаревшей спецификации голой структуры, но это
согласуется с другими типами текущей формы спецификации 
<code>(:struct <var>structure-name</var>)</code> и предоставляет объект Lisp 
преобразованный из структуры (по умолчанию plist).  Чтобы получить указатель,
вы должны использовать новую функцию <a href="#mem_002daptr">mem-aptr</a>.
</p>
<a name="See-Also-30"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#mem_002dref">mem-ref</a> <br>
<a href="#mem_002daptr">mem-aptr</a>
</p>

<hr>
<a name="mem_002dref"></a>
<div class="header">
<p>
Next: <a href="#null_002dpointer" accesskey="n" rel="next">null-pointer</a>, Previous: <a href="#mem_002daref" accesskey="p" rel="prev">mem-aref</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">mem-ref</h4>
<a name="mem_002dref-1"></a>
<h3 class="heading">mem-ref</h3>
<a name="Syntax-33"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-mem_002dref"></a>Accessor: <strong>mem-ref</strong> <em>ptr type &amp;optional offset⇒ object</em></dt>
</dl>

<a name="Arguments-and-Values-33"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>A pointer.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>offset</var></dt>
<dd><p>An integer (in byte units).
</p>
</dd>
<dt><var>object</var></dt>
<dd><p>The value <var>ptr</var> points to.
</p></dd>
</dl>

<a name="Description-33"></a>
<h4 class="subheading">Description</h4>
<a name="Examples-29"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">ptr <span class="string">"Saluton"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">mem-ref ptr <span class="keyword">:char</span> 3</span>)</span> <span class="paren3">(<span class="lisp-bg">char-code <span class="character">#\a</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 8
                collect <span class="paren3">(<span class="lisp-bg">code-char <span class="paren4">(<span class="lisp-bg">mem-ref ptr <span class="keyword">:char</span> i</span>)</span></span>)</span></span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg"><span class="character">#\S</span> <span class="character">#\a</span> <span class="character">#\l</span> <span class="character">#\a</span> <span class="character">#\t</span> <span class="character">#\o</span> <span class="character">#\n</span> <span class="character">#\Null</span></span>)</span>
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">setq</span></i> ptr-to-int <span class="paren2">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span></span>)</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #x1047D0&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">mem-ref ptr-to-int <span class="keyword">:int</span></span>)</span>
 ⇒ 1054619
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">setf <span class="paren2">(<span class="lisp-bg">mem-ref ptr-to-int <span class="keyword">:int</span></span>)</span> 1984</span>)</span>
 ⇒ 1984
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">mem-ref ptr-to-int <span class="keyword">:int</span></span>)</span>
 ⇒ 1984
</pre></div>

<a name="See-Also-31"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#mem_002daref">mem-aref</a>
</p>

<hr>
<a name="null_002dpointer"></a>
<div class="header">
<p>
Next: <a href="#null_002dpointer_002dp" accesskey="n" rel="next">null-pointer-p</a>, Previous: <a href="#mem_002dref" accesskey="p" rel="prev">mem-ref</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">null-pointer</h4>
<a name="null_002dpointer-1"></a>
<h3 class="heading">null-pointer</h3>
<a name="Syntax-34"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-null_002dpointer"></a>Function: <strong>null-pointer</strong> <em>⇒ pointer</em></dt>
</dl>

<a name="Arguments-and-Values-34"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>pointer</var></dt>
<dd><p>A <code>NULL</code> pointer.
</p></dd>
</dl>

<a name="Description-34"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>null-pointer</code> возвращает нулевой указатель.
</p>
<a name="Examples-30"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">null-pointer</span>)</span>
 ⇒ #&lt;A Null Mac Pointer&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointerp *</span>)</span>
 ⇒ T
</pre></div>

<a name="See-Also-32"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#null_002dpointer_002dp">null-pointer-p</a> <br>
<a href="#make_002dpointer">make-pointer</a>
</p>

<hr>
<a name="null_002dpointer_002dp"></a>
<div class="header">
<p>
Next: <a href="#pointerp" accesskey="n" rel="next">pointerp</a>, Previous: <a href="#null_002dpointer" accesskey="p" rel="prev">null-pointer</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">null-pointer-p</h4>
<a name="null_002dpointer_002dp-1"></a>
<h3 class="heading">null-pointer-p</h3>
<a name="Syntax-35"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-null_002dpointer_002dp"></a>Function: <strong>null-pointer-p</strong> <em>ptr⇒ boolean</em></dt>
</dl>

<a name="Arguments-and-Values-35"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>A foreign pointer that may be a null pointer.
</p>
</dd>
<dt><var>boolean</var></dt>
<dd><p><code>T</code> or <code>NIL</code>.
</p></dd>
</dl>

<a name="Description-35"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>null-pointer-p</code> возвращает true, если <var>ptr</var> является
нулевым указателем и false в противном случае.
</p>
<a name="Examples-31"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">null-pointer-p <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span></span>)</span>
 ⇒ T
</pre></div>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> contains-str-p <span class="paren2">(<span class="lisp-bg">big little</span>)</span>
    <span class="paren2">(<span class="lisp-bg">not <span class="paren3">(<span class="lisp-bg">null-pointer-p
          <span class="paren4">(<span class="lisp-bg">foreign-funcall <span class="string">"strstr"</span> <span class="keyword">:string</span> big <span class="keyword">:string</span> little <span class="keyword">:pointer</span></span>)</span></span>)</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">contains-str-p <span class="string">"Popcorns"</span> <span class="string">"corn"</span></span>)</span>
 ⇒ T
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">contains-str-p <span class="string">"Popcorns"</span> <span class="string">"salt"</span></span>)</span>
 ⇒ NIL
</pre></div>

<a name="See-Also-33"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#null_002dpointer">null-pointer</a> <br>
<a href="#pointerp">pointerp</a>
</p>

<hr>
<a name="pointerp"></a>
<div class="header">
<p>
Next: <a href="#pointer_002daddress" accesskey="n" rel="next">pointer-address</a>, Previous: <a href="#null_002dpointer_002dp" accesskey="p" rel="prev">null-pointer-p</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">pointerp</h4>
<a name="pointerp-1"></a>
<h3 class="heading">pointerp</h3>
<a name="Syntax-36"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-pointerp"></a>Function: <strong>pointerp</strong> <em>ptr⇒ boolean</em></dt>
</dl>

<a name="Arguments-and-Values-36"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>An object that may be a foreign pointer.
</p>
</dd>
<dt><var>boolean</var></dt>
<dd><p><code>T</code> or <code>NIL</code>.
</p></dd>
</dl>

<a name="Description-36"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>pointerp</code> возвращает true, если <var>ptr</var> является
внешним указателем и false в противном случае.
</p>
<a name="Implementation_002dspecific-Notes"></a>
<h4 class="subheading">Implementation-specific Notes</h4>
<p>В Allegro CL, внешний укзатель является целым числом, поэтому в этой реализации
 <code>pointerp</code> вернет true для любого обычного целого числа.
</p>
<a name="Examples-32"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc 32</span>)</span>
 ⇒ #&lt;A Mac Pointer #x102D20&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointerp *</span>)</span>
 ⇒ T
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointerp <span class="string">"this is not a pointer"</span></span>)</span>
 ⇒ NIL
</pre></div>

<a name="See-Also-34"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#make_002dpointer">make-pointer</a>
<a href="#null_002dpointer_002dp">null-pointer-p</a>
</p>

<hr>
<a name="pointer_002daddress"></a>
<div class="header">
<p>
Next: <a href="#pointer_002deq" accesskey="n" rel="next">pointer-eq</a>, Previous: <a href="#pointerp" accesskey="p" rel="prev">pointerp</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">pointer-address</h4>
<a name="pointer_002daddress-1"></a>
<h3 class="heading">pointer-address</h3>
<a name="Syntax-37"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-pointer_002daddress"></a>Function: <strong>pointer-address</strong> <em>ptr⇒ address</em></dt>
</dl>

<a name="Arguments-and-Values-37"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>A foreign pointer.
</p>
</dd>
<dt><var>address</var></dt>
<dd><p>An integer.
</p></dd>
</dl>

<a name="Description-37"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>pointer-address</code> вернет <var>address</var> 
внешнего указателя <var>ptr</var>.
</p>
<a name="Examples-33"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointer-address <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span></span>)</span>
 ⇒ 0
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointer-address <span class="paren2">(<span class="lisp-bg">make-pointer 123</span>)</span></span>)</span>
 ⇒ 123
</pre></div>

<a name="See-Also-35"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#make_002dpointer">make-pointer</a> <br>
<a href="#inc_002dpointer">inc-pointer</a> <br>
<a href="#null_002dpointer">null-pointer</a> <br>
<a href="#null_002dpointer_002dp">null-pointer-p</a> <br>
<a href="#pointerp">pointerp</a> <br>
<a href="#pointer_002deq">pointer-eq</a> <br>
<a href="#mem_002dref">mem-ref</a>
</p>

<hr>
<a name="pointer_002deq"></a>
<div class="header">
<p>
Next: <a href="#with_002dforeign_002dobject" accesskey="n" rel="next">with-foreign-object</a>, Previous: <a href="#pointer_002daddress" accesskey="p" rel="prev">pointer-address</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">pointer-eq</h4>
<a name="pointer_002deq-1"></a>
<h3 class="heading">pointer-eq</h3>
<a name="Syntax-38"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-pointer_002deq"></a>Function: <strong>pointer-eq</strong> <em>ptr1 ptr2⇒ boolean</em></dt>
</dl>

<a name="Arguments-and-Values-38"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr1</var></dt>
<dt><var>ptr2</var></dt>
<dd><p>A foreign pointer.
</p>
</dd>
<dt><var>boolean</var></dt>
<dd><p><code>T</code> or <code>NIL</code>.
</p></dd>
</dl>

<a name="Description-38"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>pointer-eq</code> возвращает true, если <var>ptr1</var> и
<var>ptr2</var> указывают на один и тот же адрес памяти, и false в противном случае.
</p>
<a name="Implementation_002dspecific-Notes-1"></a>
<h4 class="subheading">Примечания по реализации</h4>
<p>Представление внешних указателей различается в разных реализациях Lisp,
как и поведение встроиенных в Common Lisp предикатов их равенства.
Сравнение двух указателей, которые указывают на один и тот же адрес с помощью
<code>EQ</code> Lisp вернет true на некоторых Lisp, другие требуют более
общих предикатов, таких как <code>EQL</code> или <code>EQUALP</code> и наконец,
некоторые вернут false с использованием любого из этих предикатов. Поэтому, для
переносимости, вы должны испольовать <code>POINTER-EQ</code>.
</p>
<a name="Examples-34"></a>
<h4 class="subheading">Examples</h4>
<p>This is an example using <acronym>SBCL</acronym>, see the
implementation-specific notes above.
</p>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">eql <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span> <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span></span>)</span>
 ⇒ NIL
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointer-eq <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span> <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span></span>)</span>
 ⇒ T
</pre></div>

<a name="See-Also-36"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#inc_002dpointer">inc-pointer</a>
</p>

<hr>
<a name="with_002dforeign_002dobject"></a>
<div class="header">
<p>
Next: <a href="#with_002dforeign_002dpointer" accesskey="n" rel="next">with-foreign-pointer</a>, Previous: <a href="#pointer_002deq" accesskey="p" rel="prev">pointer-eq</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">with-foreign-object</h4>
<a name="with_002dforeign_002dobject_002c-with_002dforeign_002dobjects"></a>
<h3 class="heading">with-foreign-object, with-foreign-objects</h3>
<a name="Syntax-39"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-with_002dforeign_002dobject"></a>Macro: <strong>with-foreign-object</strong> <em>(var type &amp;optional count) &amp;body body</em></dt>
</dl>

<a name="with_002dforeign_002dobjects"></a><dl>
<dt><a name="index-with_002dforeign_002dobjects"></a>Macro: <strong>with-foreign-objects</strong> <em>(bindings) &amp;body body</em></dt>
</dl>

<p>bindings ::= {(var type &amp;optional count)}*
</p>
<a name="Arguments-and-Values-39"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>var</var></dt>
<dd><p>A symbol.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A foreign type, evaluated.
</p>
</dd>
<dt><var>count</var></dt>
<dd><p>An integer.
</p></dd>
</dl>

<a name="Description-39"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>with-foreign-object</code> и <code>with-foreign-objects</code>
связывают <var>var</var> с указателем(pointer) на <var>count</var> вновь выделенных
объектов типа(<var>type</var>) во время выполнения кода(<var>body</var>). Буфер имеет
динамическую протяженность на время выполнения кода(dynamic extent)
и может быть выделен в стеке, если это поддерживается хостом Lisp.
</p>
<a name="Examples-35"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">array <span class="keyword">:int</span> 10</span>)</span>
          <span class="paren2">(<span class="lisp-bg">dotimes <span class="paren3">(<span class="lisp-bg">i 10</span>)</span>
            <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span> <span class="paren4">(<span class="lisp-bg">random 100</span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i below 10
                collect <span class="paren3">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span></span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg">22 7 22 52 69 1 46 93 90 65</span>)</span>
</pre></div>

<a name="See-Also-37"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dalloc">foreign-alloc</a>
</p>

<hr>
<a name="with_002dforeign_002dpointer"></a>
<div class="header">
<p>
Previous: <a href="#with_002dforeign_002dobject" accesskey="p" rel="prev">with-foreign-object</a>, Up: <a href="#Pointers" accesskey="u" rel="up">Pointers</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">with-foreign-pointer</h4>
<a name="with_002dforeign_002dpointer-1"></a>
<h3 class="heading">with-foreign-pointer</h3>
<a name="Syntax-40"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-with_002dforeign_002dpointer"></a>Macro: <strong>with-foreign-pointer</strong> <em>(var size &amp;optional size-var) &amp;body body</em></dt>
</dl>

<a name="Arguments-and-Values-40"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>var</var></dt>
<dt><var>size-var</var></dt>
<dd><p>A symbol.
</p>
</dd>
<dt><var>size</var></dt>
<dd><p>An integer.
</p>
</dd>
<dt><var>body</var></dt>
<dd><p>A list of forms to be executed.
</p></dd>
</dl>

<a name="Description-40"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>with-foreign-pointer</code> связывает <var>var</var> с
байтами внешней памяти размером(<var>size</var>) во время выполнения
кода(<var>body</var>). Указатель в <var>var</var> не допустим
за пределами динмаической протяженности времени выполнения кода
<var>body</var> и может быть выделен в стеке, если это поддерживается
реализацией.
</p>
<p>Если указан <var>size-var</var>, он будет связан с размером(<var>size</var>) 
в течении выремени выполнения <var>body</var>.
</p>
<a name="Examples-36"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer</span></i> <span class="paren2">(<span class="lisp-bg">string 4 size</span>)</span>
          <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">mem-ref string <span class="keyword">:char</span> <span class="paren4">(<span class="lisp-bg">1- size</span>)</span></span>)</span> 0</span>)</span>
          <span class="paren2">(<span class="lisp-bg">lisp-string-to-foreign <span class="string">"Popcorns"</span> string size</span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below size
                collect <span class="paren3">(<span class="lisp-bg">code-char <span class="paren4">(<span class="lisp-bg">mem-ref string <span class="keyword">:char</span> i</span>)</span></span>)</span></span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg"><span class="character">#\P</span> <span class="character">#\o</span> <span class="character">#\p</span> <span class="character">#\Null</span></span>)</span>
</pre></div>

<a name="See-Also-38"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dalloc">foreign-alloc</a> <br>
<a href="#foreign_002dfree">foreign-free</a>
</p>

<hr>
<a name="Strings"></a>
<div class="header">
<p>
Next: <a href="#Variables" accesskey="n" rel="next">Variables</a>, Previous: <a href="#Pointers" accesskey="p" rel="prev">Pointers</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Strings-1"></a>
<h2 class="chapter">8 Строки</h2>

<p>Как и во многих языках программирования, Lisp и Си имеют специальную поддержку для
логических массивов символов, вплоть до того, что дают им специальное имя,
âstringsâ.  В том духе, <acronym>CFFI</acronym> предоставляет специальную
поддержку для преобразования строк между Lisp и Си.
</p>
<p>Тип <code>:string</code> и связанные с ним символы указанные ниже также служат
примером, что вы можете делать с помощью <acronym>CFFI</acronym>; если бы этот тип
не был включен, вы могли бы написать такой же функциональный <samp>strings.lisp</samp>,
не обращаясь к каким либо специфическим для реализации символам.
</p>
<table class="menu" cellspacing="0" border="0">
<tbody><tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">Dictionary

</pre></th></tr><tr><td valign="top" align="left">• <a href="#g_t_002adefault_002dforeign_002dencoding_002a" accesskey="1">*default-foreign-encoding*</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dstring_002dalloc" accesskey="2">foreign-string-alloc</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dstring_002dfree" accesskey="3">foreign-string-free</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dstring_002dto_002dlisp" accesskey="4">foreign-string-to-lisp</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#lisp_002dstring_002dto_002dforeign" accesskey="5">lisp-string-to-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dstring" accesskey="6">with-foreign-string</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dstrings" accesskey="7">with-foreign-strings</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#with_002dforeign_002dpointer_002das_002dstring" accesskey="8">with-foreign-pointer-as-string</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
</tbody></table>

<hr>
<a name="g_t_002adefault_002dforeign_002dencoding_002a"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dstring_002dalloc" accesskey="n" rel="next">foreign-string-alloc</a>, Previous: <a href="#Strings" accesskey="p" rel="prev">Strings</a>, Up: <a href="#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">*default-foreign-encoding*</h4>
<a name="g_t_002adefault_002dforeign_002dencoding_002a-1"></a>
<h3 class="heading">*default-foreign-encoding*</h3>
<a name="Syntax-41"></a>
<h4 class="subheading">Syntax</h4>

<dl>
<dt><a name="index-_002adefault_002dforeign_002dencoding_002a"></a>Special Variable: <strong>*default-foreign-encoding*</strong></dt>
</dl>

<a name="Value-type"></a>
<h4 class="subheading">Value type</h4>

<p>A keyword.
</p>
<a name="Initial-value"></a>
<h4 class="subheading">Initial value</h4>

<p><code>:utf-8</code>
</p>
<a name="Description-41"></a>
<h4 class="subheading">Description</h4>

<p>Это специальная переменная содержит внешнюю кодировку по умолчанию.
</p>
<a name="Examples-37"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; *default-foreign-encoding*
  :utf-8
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strdup"</span> <span class="paren2">(<span class="lisp-bg"><span class="keyword">:string</span> <span class="keyword">:encoding</span> <span class="keyword">:utf-16</span></span>)</span> <span class="string">"foo"</span> <span class="keyword">:string</span></span>)</span>
  "f"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="special">*default-foreign-encoding*</span> <span class="keyword">:utf-16</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"strdup"</span> <span class="paren3">(<span class="lisp-bg"><span class="keyword">:string</span> <span class="keyword">:encoding</span> <span class="keyword">:utf-16</span></span>)</span> <span class="string">"foo"</span> <span class="keyword">:string</span></span>)</span></span>)</span>
  "foo"
</pre></div>

<a name="See-also"></a>
<h4 class="subheading">See also</h4>

<p><a href="#Other-Types">Other Types</a> (<code>:string</code> type) <br>
<a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <br>
<a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a> <br>
<a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a> <br>
<a href="#with_002dforeign_002dstring">with-foreign-string</a> <br>
<a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>
</p>

<hr>
<a name="foreign_002dstring_002dalloc"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dstring_002dfree" accesskey="n" rel="next">foreign-string-free</a>, Previous: <a href="#g_t_002adefault_002dforeign_002dencoding_002a" accesskey="p" rel="prev">*default-foreign-encoding*</a>, Up: <a href="#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-string-alloc</h4>
<a name="foreign_002dstring_002dalloc-1"></a>
<h3 class="heading">foreign-string-alloc</h3>
<a name="Syntax-42"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dstring_002dalloc"></a>Function: <strong>foreign-string-alloc</strong> <em>string &amp;key encoding null-terminated-p                                start end⇒ pointer</em></dt>
</dl>

<a name="Arguments-and-Values-41"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><em><var>string</var></em></dt>
<dd><p>A Lisp string.
</p>
</dd>
<dt><em><var>encoding</var></em></dt>
<dd><p>Foreign encoding. Defaults to <code>*default-foreign-encoding*</code>.
</p>
</dd>
<dt><em><var>null-terminated-p</var></em></dt>
<dd><p>Boolean, defaults to true.
</p>
</dd>
<dt><em><var>start</var>, <var>end</var></em></dt>
<dd><p>Bounding index designators of <var>string</var>. 0 and <code>nil</code>, by
default.
</p>
</dd>
<dt><em><var>pointer</var></em></dt>
<dd><p>A pointer to the newly allocated foreign string.
</p></dd>
</dl>

<a name="Description-42"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-string-alloc</code> выделяет внешнюю память, сохраняя
копию <var>string</var> преобразованную с использованием указанной кодировки
<var>encoding</var>. Начало(<var>Start</var>) определяет смещение в строке(<var>string</var>)
и конец(<var>end</var>) отмечает позицию, следующую за последним элементом внешней
строки.
</p>
<p>Эта строка должна быть освобождена с помощью <code>foreign-string-free</code>.
</p>
<p>Если <var>null-terminated-p</var> равен false, строка не будет иметь нулевое окончание.
</p>
<a name="Examples-38"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defparameter</span></i> <span class="special">*str*</span> <span class="paren2">(<span class="lisp-bg">foreign-string-alloc <span class="string">"Hello, foreign world!"</span></span>)</span></span>)</span>
 ⇒ #&lt;FOREIGN-ADDRESS #x00400560&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strlen"</span> <span class="keyword">:pointer</span> <span class="special">*str*</span> <span class="keyword">:int</span></span>)</span>
 ⇒ 21
</pre></div>

<a name="See-Also-39"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dstring_002dfree">foreign-string-free</a> <br>
<a href="#with_002dforeign_002dstring">with-foreign-string</a>
</p>

<hr>
<a name="foreign_002dstring_002dfree"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dstring_002dto_002dlisp" accesskey="n" rel="next">foreign-string-to-lisp</a>, Previous: <a href="#foreign_002dstring_002dalloc" accesskey="p" rel="prev">foreign-string-alloc</a>, Up: <a href="#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-string-free</h4>
<a name="foreign_002dstring_002dfree-1"></a>
<h3 class="heading">foreign-string-free</h3>
<a name="Syntax-43"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dstring_002dfree"></a>Function: <strong>foreign-string-free</strong> <em>pointer</em></dt>
</dl>

<a name="Arguments-and-Values-42"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>pointer</var></dt>
<dd><p>A pointer to a string allocated by <code>foreign-string-alloc</code>.
</p></dd>
</dl>

<a name="Description-43"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-string-free</code> освобождает внешнюю строку
выделенную с помощью <code>foreign-string-alloc</code>.
</p>
<a name="Examples-39"></a>
<h4 class="subheading">Examples</h4>

<a name="See-Also-40"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a>
</p>

<hr>
<a name="foreign_002dstring_002dto_002dlisp"></a>
<div class="header">
<p>
Next: <a href="#lisp_002dstring_002dto_002dforeign" accesskey="n" rel="next">lisp-string-to-foreign</a>, Previous: <a href="#foreign_002dstring_002dfree" accesskey="p" rel="prev">foreign-string-free</a>, Up: <a href="#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-string-to-lisp</h4>
<a name="foreign_002dstring_002dto_002dlisp-1"></a>
<h3 class="heading">foreign-string-to-lisp</h3>
<a name="Syntax-44"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dstring_002dto_002dlisp"></a>Function: <strong>foreign-string-to-lisp</strong> <em>ptr &amp;key offset count max-chars                                  encoding⇒ string</em></dt>
</dl>

<a name="Arguments-and-Values-43"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>ptr</var></dt>
<dd><p>A pointer.
</p>
</dd>
<dt><var>offset</var></dt>
<dd><p>An integer greater than or equal to 0. Defauls to 0.
</p>
</dd>
<dt><var>count</var></dt>
<dd><p>Either <code>nil</code> (the default), or an integer greater than or equal to 0.
</p>
</dd>
<dt><var>max-chars</var></dt>
<dd><p>An integer greater than or equal to 0.
<code>(1- array-total-size-limit)</code>, by default.
</p>
</dd>
<dt><var>encoding</var></dt>
<dd><p>Foreign encoding. Defaults to <code>*default-foreign-encoding*</code>.
</p>
</dd>
<dt><var>string</var></dt>
<dd><p>A Lisp string.
</p></dd>
</dl>

<a name="Description-44"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>foreign-string-to-lisp</code> преобразует максимум <var>count</var> 
октетов из указателя <var>ptr</var> в строку Lisp, используя заданную
кодировку <var>encoding</var>.
</p>
<p>Если количество <var>count</var> равно <code>nil</code> (по умолчанию), символы
копируютя до тех пор, пока не будет достигнуто <var>max-chars</var> символов или
не будет найден симолв <code>NULL</code>.
</p>
<p>Если <var>ptr</var> это нулевой указатель, взвращается <code>nil</code>.
</p>
<p>Обратите внимание, что тип <code>:string</code> автоматически выполняет преобразование
между строками Lisp и внешними строками.
</p>
<a name="Examples-40"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"getenv"</span> <span class="keyword">:string</span> <span class="string">"HOME"</span> <span class="keyword">:pointer</span></span>)</span>
 ⇒ #&lt;FOREIGN-ADDRESS #xBFFFFFD5&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-to-lisp *</span>)</span>
 ⇒ "/Users/luis"
</pre></div>

<a name="See-Also-41"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a> <br>
<a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a>
</p>

<hr>
<a name="lisp_002dstring_002dto_002dforeign"></a>
<div class="header">
<p>
Next: <a href="#with_002dforeign_002dstring" accesskey="n" rel="next">with-foreign-string</a>, Previous: <a href="#foreign_002dstring_002dto_002dlisp" accesskey="p" rel="prev">foreign-string-to-lisp</a>, Up: <a href="#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">lisp-string-to-foreign</h4>
<a name="lisp_002dstring_002dto_002dforeign-1"></a>
<h3 class="heading">lisp-string-to-foreign</h3>
<a name="Syntax-45"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-lisp_002dstring_002dto_002dforeign"></a>Function: <strong>lisp-string-to-foreign</strong> <em>string buffer bufsize &amp;key start                                  end offset encoding⇒ buffer</em></dt>
</dl>

<a name="Arguments-and-Values-44"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><em><var>string</var></em></dt>
<dd><p>A Lisp string.
</p>
</dd>
<dt><em><var>buffer</var></em></dt>
<dd><p>A foreign pointer.
</p>
</dd>
<dt><em><var>bufsize</var></em></dt>
<dd><p>An integer.
</p>
</dd>
<dt><em><var>start</var>, <var>end</var></em></dt>
<dd><p>Bounding index designators of <var>string</var>. 0 and <code>nil</code>, by
default.
</p>
</dd>
<dt><em><var>offset</var></em></dt>
<dd><p>An integer greater than or equal to 0. Defauls to 0.
</p>
</dd>
<dt><em><var>encoding</var></em></dt>
<dd><p>Foreign encoding. Defaults to <code>*default-foreign-encoding*</code>.
</p></dd>
</dl>

<a name="Description-45"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>lisp-string-to-foreign</code> копирует не более 
<var>bufsize</var>-1 октетов из строки(<var>string</var>) Lisp с использованием
указанной кодировки(<var>encoding</var>) в буффер <var>buffer</var>+<var>offset</var>. Внешняя
строка будет заканчиваться нулем(null-terminated).
</p>
<p>Начало(<var>Start</var>) указывает смещение в <var>string</var> и
<var>end</var> отмечает позицию следующую за последним элементом внешней строки.
</p>
<a name="Examples-41"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer-as-string</span></i> <span class="paren2">(<span class="lisp-bg">str 255</span>)</span>
          <span class="paren2">(<span class="lisp-bg">lisp-string-to-foreign <span class="string">"Hello, foreign world!"</span> str 6</span>)</span></span>)</span>
 ⇒ "Hello"
</pre></div>

<a name="See-Also-42"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <br>
<a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a> <br>
<a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>
</p>

<hr>
<a name="with_002dforeign_002dstring"></a>
<div class="header">
<p>
Next: <a href="#with_002dforeign_002dpointer_002das_002dstring" accesskey="n" rel="next">with-foreign-pointer-as-string</a>, Previous: <a href="#lisp_002dstring_002dto_002dforeign" accesskey="p" rel="prev">lisp-string-to-foreign</a>, Up: <a href="#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">with-foreign-string</h4>
<a name="with_002dforeign_002dstring_002c-with_002dforeign_002dstrings"></a>
<h3 class="heading">with-foreign-string, with-foreign-strings</h3>
<a name="Syntax-46"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-with_002dforeign_002dstring"></a>Macro: <strong>with-foreign-string</strong> <em>(var-or-vars string &amp;rest args) &amp;body body</em></dt>
</dl>

<a name="with_002dforeign_002dstrings"></a><dl>
<dt><a name="index-with_002dforeign_002dstrings"></a>Macro: <strong>with-foreign-strings</strong> <em>(bindings) &amp;body body</em></dt>
</dl>

<p>var-or-vars ::= var | (var &amp;optional octet-size-var)
bindings ::= {(var-or-vars string &amp;rest args)}*
</p>
<a name="Arguments-and-Values-45"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><em><var>var</var>, <var>byte-size-var</var></em></dt>
<dd><p>A symbol.
</p>
</dd>
<dt><em><var>string</var></em></dt>
<dd><p>A Lisp string.
</p>
</dd>
<dt><em><var>body</var></em></dt>
<dd><p>A list of forms to be executed.
</p></dd>
</dl>

<a name="Description-46"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>with-foreign-string</code> связывает <var>var</var> с новой 
выделенной внешней строкой содержащей <var>string</var>. Аргументы <var>Args</var>
предаются базовому вызову <code>foreign-string-alloc</code>.
</p>
<p>Если указан <var>octet-size-var</var>, он будет ограничивать длину внешнйе строки в
октетах, включая нулевой конечный символ(null terminator).
</p>
<a name="Examples-42"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">foo <span class="string">"12345"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"strlen"</span> <span class="keyword">:pointer</span> foo <span class="keyword">:int</span></span>)</span></span>)</span>
 ⇒ 5

  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">array <span class="paren4">(<span class="lisp-bg">coerce #<span class="paren5">(<span class="lisp-bg">84 117 114 97 110 103 97</span>)</span>
                             '<span class="paren5">(<span class="lisp-bg">array <span class="paren6">(<span class="lisp-bg">unsigned-byte 8</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren3">(<span class="lisp-bg">foreign-string array</span>)</span>
            <span class="paren3">(<span class="lisp-bg">foreign-string-to-lisp foreign-string</span>)</span></span>)</span></span>)</span>
 ⇒ "Turanga"
</pre></div>

<a name="See-Also-43"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <br>
<a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>
</p>

<hr>
<a name="with_002dforeign_002dpointer_002das_002dstring"></a>
<div class="header">
<p>
Previous: <a href="#with_002dforeign_002dstring" accesskey="p" rel="prev">with-foreign-string</a>, Up: <a href="#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">with-foreign-pointer-as-string</h4>
<a name="with_002dforeign_002dpointer_002das_002dstring-1"></a>
<h3 class="heading">with-foreign-pointer-as-string</h3>
<a name="Syntax-47"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-with_002dforeign_002dpointer_002das_002dstring"></a>Macro: <strong>with-foreign-pointer-as-string</strong> <em>(var size &amp;optional size-var                                       &amp;rest args) &amp;body body⇒ string</em></dt>
</dl>

<a name="Arguments-and-Values-46"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>var</var></dt>
<dd><p>A symbol.
</p>
</dd>
<dt><var>string</var></dt>
<dd><p>A Lisp string.
</p>
</dd>
<dt><var>body</var></dt>
<dd><p>List of forms to be executed.
</p></dd>
</dl>

<a name="Description-47"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>with-foreign-pointer-as-string</code> похож на макрос
<code>with-foreign-pointer</code>, за исключением того, что <var>var</var> используется
как возвращаемое значение неявного <code>progn</code> вокруг тела макроса <var>body</var>, 
после преобразования в строку Lisp с использованием предоставленных аргументов <var>args</var>.
</p>
<a name="Examples-43"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer-as-string</span></i> <span class="paren2">(<span class="lisp-bg">str 6 str-size <span class="keyword">:encoding</span> <span class="keyword">:ascii</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">lisp-string-to-foreign <span class="string">"Hello, foreign world!"</span> str str-size</span>)</span></span>)</span>
 ⇒ "Hello"
</pre></div>

<a name="See-Also-44"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <br>
<a href="#with_002dforeign_002dstring">with-foreign-string</a>
</p>

<hr>
<a name="Variables"></a>
<div class="header">
<p>
Next: <a href="#Functions" accesskey="n" rel="next">Functions</a>, Previous: <a href="#Strings" accesskey="p" rel="prev">Strings</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Variables-1"></a>
<h2 class="chapter">9 Переменные</h2>

<table class="menu" cellspacing="0" border="0">
<tbody><tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">Dictionary

</pre></th></tr><tr><td valign="top" align="left">• <a href="#defcvar" accesskey="1">defcvar</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#get_002dvar_002dpointer" accesskey="2">get-var-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
</tbody></table>

<hr>
<a name="defcvar"></a>
<div class="header">
<p>
Next: <a href="#get_002dvar_002dpointer" accesskey="n" rel="next">get-var-pointer</a>, Previous: <a href="#Variables" accesskey="p" rel="prev">Variables</a>, Up: <a href="#Variables" accesskey="u" rel="up">Variables</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">defcvar</h4>
<a name="defcvar-1"></a>
<h3 class="heading">defcvar</h3>
<a name="Syntax-48"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-defcvar"></a>Macro: <strong>defcvar</strong> <em>name-and-options type &amp;optional documentation⇒ lisp-name</em></dt>
</dl>

<p><var>name-and-options</var> ::= name | (name &amp;key read-only (library :default)) <br>
<var>name</var> ::= lisp-name [foreign-name] | foreign-name [lisp-name]
</p>
<a name="Arguments-and-Values-47"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>foreign-name</var></dt>
<dd><p>A string denoting a foreign function.
</p>
</dd>
<dt><var>lisp-name</var></dt>
<dd><p>A symbol naming the Lisp function to be created.
</p>
</dd>
<dt><var>type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>read-only</var></dt>
<dd><p>A boolean.
</p>
</dd>
<dt><var>documentation</var></dt>
<dd><p>A Lisp string; not evaluated.
</p></dd>
</dl>

<a name="Description-48"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>defcvar</code> определяет символьный макрос <var>lisp-name</var>,
который находит <var>foreign-name</var> и разыменовывает его в соответствии с
типом(<var>type</var>).  Он также может быть использован для <code>setf</code>, 
если только не установлен <var>read-only</var> в true, в этом случае будет 
выдано сообщение об ошибке.
</p>
<p>Когда одно из <var>lisp-name</var> или <var>foreign-name</var> опущено, 
другое автоматически выводиться с использованием следующих правил:
</p>
<ul>
<li> Внешние имена преобразуются в имена Lisp в верхнем регистре, заменяя
подчеркивания дефисами, и заключая их в звездочки.
</li><li> Имена Lisp преобразуются во внешние имена преобразованием в нижний регистр, 
заменяя дефисы подчеркиваниями и удаляя окружающие имя звездочки, если они есть.
</li></ul>

<a name="Examples-44"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcvar</span></i> <span class="string">"errno"</span> <span class="keyword">:int</span></span>)</span>
 ⇒ *ERRNO*
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strerror"</span> <span class="keyword">:int</span> <span class="special">*errno*</span> <span class="keyword">:string</span></span>)</span>
 ⇒ "Inappropriate ioctl for device"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">setf <span class="special">*errno*</span> 1</span>)</span>
 ⇒ 1
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strerror"</span> <span class="keyword">:int</span> <span class="special">*errno*</span> <span class="keyword">:string</span></span>)</span>
 ⇒ "Operation not permitted"
</pre></div>

<p>Trying to modify a read-only foreign variable:
</p>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcvar</span></i> <span class="paren2">(<span class="lisp-bg"><span class="string">"errno"</span> +error-number+ <span class="keyword">:read-only</span> t</span>)</span> <span class="keyword">:int</span></span>)</span>
 ⇒ +ERROR-NUMBER+
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">setf +error-number+ 12</span>)</span>
  <span class="comment">;; error&amp;rarr; Trying to modify read-only foreign var: +ERROR-NUMBER+.
  </span>
</pre></div>

<p><em>Note that accessing <code>errno</code> this way wonât work with every
implementation of the C standard library.</em>
</p>
<a name="See-Also-45"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#get_002dvar_002dpointer">get-var-pointer</a>
</p>

<hr>
<a name="get_002dvar_002dpointer"></a>
<div class="header">
<p>
Previous: <a href="#defcvar" accesskey="p" rel="prev">defcvar</a>, Up: <a href="#Variables" accesskey="u" rel="up">Variables</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">get-var-pointer</h4>
<a name="get_002dvar_002dpointer-1"></a>
<h3 class="heading">get-var-pointer</h3>
<a name="Syntax-49"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-get_002dvar_002dpointer"></a>Function: <strong>get-var-pointer</strong> <em>symbol⇒ pointer</em></dt>
</dl>

<a name="Arguments-and-Values-48"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>symbol</var></dt>
<dd><p>A symbol denoting a foreign variable defined with <code>defcvar</code>.
</p>
</dd>
<dt><var>pointer</var></dt>
<dd><p>A foreign pointer.
</p></dd>
</dl>

<a name="Description-49"></a>
<h4 class="subheading">Description</h4>
<p>Функция <code>get-var-pointer</code> возвращает указатель(<var>pointer</var>) на
внешнюю глобальную переменную <var>symbol</var>, ранее определенну с помощью
<code>defcvar</code>.
</p>
<a name="Examples-45"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcvar</span></i> <span class="string">"errno"</span> <span class="keyword">:int</span> <span class="keyword">:read-only</span> t</span>)</span>
 ⇒ *ERRNO*
  CFFI&gt; *errno*
 ⇒ 25
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">get-var-pointer '<span class="special">*errno*</span></span>)</span>
 ⇒ #&lt;A Mac Pointer #xA0008130&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">mem-ref * <span class="keyword">:int</span></span>)</span>
 ⇒ 25
</pre></div>

<a name="See-Also-46"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcvar">defcvar</a>
</p>

<hr>
<a name="Functions"></a>
<div class="header">
<p>
Next: <a href="#Libraries" accesskey="n" rel="next">Libraries</a>, Previous: <a href="#Variables" accesskey="p" rel="prev">Variables</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Functions-1"></a>
<h2 class="chapter">10 Функции</h2>

<table class="menu" cellspacing="0" border="0">
<tbody><tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Dictionary

</pre></th></tr><tr><td valign="top" align="left">• <a href="#defcfun" accesskey="1">defcfun</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dfuncall" accesskey="2">foreign-funcall</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dfuncall_002dpointer" accesskey="3">foreign-funcall-pointer</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dfuncall_002dvarargs" accesskey="4">foreign-funcall-varargs</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#foreign_002dfuncall_002dpointer_002dvarargs" accesskey="5">foreign-funcall-pointer-varargs</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dcamelcase_002dname" accesskey="6">translate-camelcase-name</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dname_002dfrom_002dforeign" accesskey="7">translate-name-from-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dname_002dto_002dforeign" accesskey="8">translate-name-to-foreign</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#translate_002dunderscore_002dseparated_002dname" accesskey="9">translate-underscore-separated-name</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
</tbody></table>

<hr>
<a name="defcfun"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dfuncall" accesskey="n" rel="next">foreign-funcall</a>, Previous: <a href="#Functions" accesskey="p" rel="prev">Functions</a>, Up: <a href="#Functions" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">defcfun</h4>
<a name="defcfun-1"></a>
<h3 class="heading">defcfun</h3>
<a name="Syntax-50"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-defcfun"></a>Macro: <strong>defcfun</strong> <em>name-and-options return-type &amp;body [docstring] arguments [&amp;rest]               ⇒ lisp-name</em></dt>
</dl>

<p><var>name-and-options</var> ::= <var>name</var> | (<var>name</var> &amp;key <var>library</var> <var>convention</var>) <br>
<var>name</var> ::= <var>lisp-name</var> [<var>foreign-name</var>] | <var>foreign-name</var> [<var>lisp-name</var>] <br>
<var>arguments</var> ::= { (<var>arg-name</var> <var>arg-type</var>) }* <br>
</p>
<a name="Arguments-and-Values-49"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>foreign-name</var></dt>
<dd><p>A string denoting a foreign function.
</p>
</dd>
<dt><var>lisp-name</var></dt>
<dd><p>A symbol naming the Lisp function to be created.
</p>
</dd>
<dt><var>arg-name</var></dt>
<dd><p>A symbol.
</p>
</dd>
<dt><var>return-type</var></dt>
<dt><var>arg-type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>convention</var></dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.
</p>
</dd>
<dt><var>library</var></dt>
<dd><p>A symbol designating a foreign library.
</p>
</dd>
<dt><var>docstring</var></dt>
<dd><p>A documentation string.
</p></dd>
</dl>

<a name="Description-50"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>defcfun</code> предоставляет декларативный интерфейс для определения
функций Lisp, которые вызывают внешние функции.
</p>
<p>Когда одно из имен <var>lisp-name</var> или <var>foreign-name</var> опущено, другое
автоматически выводиться с использованием следующих правил:
</p>
<ul>
<li> Внешние имена преобразуются в имена Lisp преобразованием в верхний регистр, 
заменяя подчеркивания на дефисы.
</li><li> Имена Lisp преобразуются во внешние имена преобразованием в нижний регистр и
заменой дефисов на подчеркивания.
</li></ul>

<p>Если вы поместите символ <code>&amp;rest</code> в конец списка аргументов
после фиксированных аргументов, <code>defcfun</code> будет рассматривать
внешнюю функцию, как <strong>функцию с переменным числом аргументов(variadic function)</strong>. 
Аргументы функции с переменным числом аргументов должны передаваться способом,
аналогичным тому, котоырй ожидалм бы медод <code>foreign-funcall</code>. 
В от метода <code>foreign-funcall</code>, <code>defcfun</code> позаботится
о продвижении аргументов. Обратите внимание, что в этом случае <code>defcfun</code> 
сгенерируетм макрос<em>macro</em> Лисп, вместо функции и будет работать только
для Lisp-ов, которые поддерживают <code>foreign-funcall.</code>
</p>
<p>Если внешняя структура должна быть передана или возвращена по значению (т.е.
тип имеет форму <code>(:struct ...)</code>), то должна быть загружена
система cffi-libffi, которая в свою очередь, зависит от
<a href="http://sourceware.org/libffi/">libffi</a>, включая заголовочные файлы.
Невозможность загрузить эту систему приведт к ошибке. Функции с перемнным
числом аргументов(Variadic) в настоящее время не могут принимать или возвращать
структуры по значению.
</p>
<a name="Examples-46"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"strlen"</span> <span class="keyword">:int</span>
    <span class="string">"Calculate the length of a string."</span>
    <span class="paren2">(<span class="lisp-bg">n <span class="keyword">:string</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">strlen <span class="string">"123"</span></span>)</span>
 ⇒ 3
</pre></div>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="paren2">(<span class="lisp-bg"><span class="string">"abs"</span> c-abs</span>)</span> <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg">n <span class="keyword">:int</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">c-abs -42</span>)</span>
 ⇒ 42
</pre></div>

<p>Function without arguments:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"rand"</span> <span class="keyword">:int</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg">rand</span>)</span>
 ⇒ 1804289383
</pre></div>

<p>Variadic function example:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"sprintf"</span> <span class="keyword">:int</span>
    <span class="paren2">(<span class="lisp-bg">str <span class="keyword">:pointer</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">control <span class="keyword">:string</span></span>)</span>
    &amp;rest</span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer-as-string</span></i> <span class="paren2">(<span class="lisp-bg">s 100</span>)</span>
          <span class="paren2">(<span class="lisp-bg">sprintf s <span class="string">"%c %d %.2f %s"</span> <span class="keyword">:char</span> 90 <span class="keyword">:short</span> 42 <span class="keyword">:float</span> pi
                   <span class="keyword">:string</span> <span class="string">"super-locrian"</span></span>)</span></span>)</span>
 ⇒ "A 42 3.14 super-locrian"
</pre></div>

<a name="See-Also-47"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#foreign_002dfuncall">foreign-funcall</a> <br>
<a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a> <br>
<a href="#foreign_002dfuncall_002dvarargs">foreign-funcall-varargs</a> <br>
<a href="#foreign_002dfuncall_002dpointer_002dvarargs">foreign-funcall-pointer-varargs</a>
</p>

<hr>
<a name="foreign_002dfuncall"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dfuncall_002dpointer" accesskey="n" rel="next">foreign-funcall-pointer</a>, Previous: <a href="#defcfun" accesskey="p" rel="prev">defcfun</a>, Up: <a href="#Functions" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-funcall</h4>
<a name="foreign_002dfuncall-1"></a>
<h3 class="heading">foreign-funcall</h3>
<a name="Syntax-51"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dfuncall"></a>Macro: <strong>foreign-funcall</strong> <em>name-and-options &amp;rest arguments⇒ return-value</em></dt>
</dl>

<p><var>arguments</var> ::= { <var>arg-type</var> <var>arg</var> }* [<var>return-type</var>] <br>
<var>name-and-options</var> ::= <var>name</var> | (<var>name</var> &amp;key <var>library</var> <var>convention</var>) <br>
</p>
<a name="Arguments-and-Values-50"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>A Lisp string.
</p>
</dd>
<dt><var>arg-type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>arg</var></dt>
<dd><p>An argument of type <var>arg-type</var>.
</p>
</dd>
<dt><var>return-type</var></dt>
<dd><p>A foreign type, <code>:void</code> by default.
</p>
</dd>
<dt><var>return-value</var></dt>
<dd><p>A lisp object.
</p>
</dd>
<dt><var>library</var></dt>
<dd><p>A lisp symbol; not evaluated.
</p>
</dd>
<dt><var>convention</var></dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.
</p></dd>
</dl>

<a name="Description-51"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>foreign-funcall</code> является основным примитивом для
вызова внешних функций.
</p>
<p>Если внешняя структура должна быть передана или возвращена по
значению(то есть тип имеет форму <code>(:struct ...)</code>), то должна быть
загружена система cffi-libffi, которая в свою очередь зависит от
<a href="http://sourceware.org/libffi/">libffi</a>, включая заголовочные файлы.
Невозможность загрузить эту систему приведет к ошибке.
Функции с переменным количеством аргументов(Variadic) в нестоящее время не могут
принимать и возвращать структуры по значению.
</p>
<p><em>Примечание: Возвращаемое значение foreign-funcall для функций с возвращаемым
типом :void не определено.</em>
</p>
<a name="Implementation_002dspecific-Notes-2"></a>
<h4 class="subheading">Implementation-specific Notes</h4>
<ul>
<li> Corman Lisp does not support <code>foreign-funcall</code>. On
implementations that <strong>donât</strong> support <code>foreign-funcall</code>
<code>cffi-sys::no-foreign-funcall</code> will be present in
<code>*features*</code>. Note: in these Lisps you can still use the
<code>defcfun</code> interface.
</li></ul>

<a name="Examples-47"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strlen"</span> <span class="keyword">:string</span> <span class="string">"foo"</span> <span class="keyword">:int</span></span>)</span>
 ⇒ 3
</pre></div>

<p>Учитывая код на Си:
</p>
<div class="example">
<pre class="example">void print_number(int n)
{
    printf("N: %d\n", n);
}
</pre></div>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"print_number"</span> <span class="keyword">:int</span> 123456</span>)</span>
  -| N: 123456
 ⇒ NIL
</pre></div>

<p>Или, эквивалентный:
</p>
<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"print_number"</span> <span class="keyword">:int</span> 123456 <span class="keyword">:void</span></span>)</span>
  -| N: 123456
 ⇒ NIL
</pre></div>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"printf"</span> <span class="keyword">:string</span> <span class="paren2">(<span class="lisp-bg">format nil <span class="string">"%s: %d.~%"</span></span>)</span>
                         <span class="keyword">:string</span> <span class="string">"So long and thanks for all the fish"</span>
                         <span class="keyword">:int</span> 42 <span class="keyword">:int</span></span>)</span>
  -| So long and thanks for all the fish: 42.
 ⇒ 41
</pre></div>

<a name="See-Also-48"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcfun">defcfun</a> <br>
<a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a>
</p>

<hr>
<a name="foreign_002dfuncall_002dpointer"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dfuncall_002dvarargs" accesskey="n" rel="next">foreign-funcall-varargs</a>, Previous: <a href="#foreign_002dfuncall" accesskey="p" rel="prev">foreign-funcall</a>, Up: <a href="#Functions" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-funcall-pointer</h4>
<a name="foreign_002dfuncall_002dpointer-1"></a>
<h3 class="heading">foreign-funcall-pointer</h3>
<a name="Syntax-52"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dfuncall_002dpointer"></a>Macro: <strong>foreign-funcall-pointer</strong> <em>pointer options &amp;rest arguments⇒ return-value</em></dt>
</dl>

<p><var>arguments</var> ::= { <var>arg-type</var> <var>arg</var> }* [<var>return-type</var>] <br>
<var>options</var> ::= (&amp;key <var>convention</var>) <br>
</p>
<a name="Arguments-and-Values-51"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>pointer</var></dt>
<dd><p>A foreign pointer.
</p>
</dd>
<dt><var>arg-type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>arg</var></dt>
<dd><p>An argument of type <var>arg-type</var>.
</p>
</dd>
<dt><var>return-type</var></dt>
<dd><p>A foreign type, <code>:void</code> by default.
</p>
</dd>
<dt><var>return-value</var></dt>
<dd><p>A lisp object.
</p>
</dd>
<dt><var>convention</var></dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.
</p></dd>
</dl>

<a name="Description-52"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>foreign-funcall</code> является основным примитивом для вызова внешних
фукнций.
</p>
<p><em>Примечание: Возвращаемое значение foreign-funcall для функций с возвращаемым
типом :void по прежнему не определено.</em>
</p>
<a name="Implementation_002dspecific-Notes-3"></a>
<h4 class="subheading">Implementation-specific Notes</h4>
<ul>
<li> Corman Lisp does not support <code>foreign-funcall</code>. On
implementations that <strong>donât</strong> support <code>foreign-funcall</code>
<code>cffi-sys::no-foreign-funcall</code> will be present in
<code>*features*</code>. Note: in these Lisps you can still use the
<code>defcfun</code> interface.
</li></ul>

<a name="Examples-48"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall-pointer <span class="paren2">(<span class="lisp-bg">foreign-symbol-pointer <span class="string">"abs"</span></span>)</span> <span class="paren2">(<span class="lisp-bg"></span>)</span>
                                 <span class="keyword">:int</span> -42 <span class="keyword">:int</span></span>)</span>
 ⇒ 42
</pre></div>

<a name="See-Also-49"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcfun">defcfun</a> <br>
<a href="#foreign_002dfuncall">foreign-funcall</a>
</p>

<hr>
<a name="foreign_002dfuncall_002dvarargs"></a>
<div class="header">
<p>
Next: <a href="#foreign_002dfuncall_002dpointer_002dvarargs" accesskey="n" rel="next">foreign-funcall-pointer-varargs</a>, Previous: <a href="#foreign_002dfuncall_002dpointer" accesskey="p" rel="prev">foreign-funcall-pointer</a>, Up: <a href="#Functions" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-funcall-varargs</h4>
<a name="foreign_002dfuncall_002dvarargs-1"></a>
<h3 class="heading">foreign-funcall-varargs</h3>
<a name="Syntax-53"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dfuncall_002dvarargs"></a>Macro: <strong>foreign-funcall-varargs</strong> <em>name-and-options (fixed-arguments) &amp;rest arguments⇒ return-value</em></dt>
</dl>

<p><var>fixed-arguments</var> ::= { <var>arg-type</var> <var>arg</var> }* [<var>return-type</var>] <br>
<var>arguments</var> ::= { <var>arg-type</var> <var>arg</var> }* [<var>return-type</var>] <br>
<var>name-and-options</var> ::= <var>name</var> | (<var>name</var> &amp;key <var>library</var> <var>convention</var>) <br>
</p>
<a name="Arguments-and-Values-52"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>A Lisp string.
</p>
</dd>
<dt><var>arg-type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>arg</var></dt>
<dd><p>An argument of type <var>arg-type</var>.
</p>
</dd>
<dt><var>return-type</var></dt>
<dd><p>A foreign type, <code>:void</code> by default.
</p>
</dd>
<dt><var>return-value</var></dt>
<dd><p>A lisp object.
</p>
</dd>
<dt><var>library</var></dt>
<dd><p>A lisp symbol; not evaluated.
</p>
</dd>
<dt><var>convention</var></dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.
</p></dd>
</dl>

<a name="Description-53"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>foreign-funcall-varargs</code> является основным примитивом для вызова
внешних функций с переменным числом аргументов(variadic). Он ведет себя подобно
<code>foreign-funcall</code>, за исключением того что фиксированные аргументы(<code>fixed-arguments</code>)
отличаются от остальных аргументов.
</p>
<a name="Examples-49"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer-as-string</span></i> <span class="paren2">(<span class="lisp-bg">s 100</span>)</span>
          <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">mem-ref s <span class="keyword">:char</span></span>)</span> 0</span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall-varargs
           <span class="string">"sprintf"</span> <span class="paren3">(<span class="lisp-bg"><span class="keyword">:pointer</span> s <span class="keyword">:string</span></span>)</span> <span class="string">"%.2f"</span></span>)</span>
           <span class="keyword">:double</span> <span class="paren2">(<span class="lisp-bg">coerce pi 'double-float</span>)</span> <span class="keyword">:int</span></span>)</span>)
 ⇒ 3.14
</pre></div>

<hr>
<a name="foreign_002dfuncall_002dpointer_002dvarargs"></a>
<div class="header">
<p>
Next: <a href="#translate_002dcamelcase_002dname" accesskey="n" rel="next">translate-camelcase-name</a>, Previous: <a href="#foreign_002dfuncall_002dvarargs" accesskey="p" rel="prev">foreign-funcall-varargs</a>, Up: <a href="#Functions" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">foreign-funcall-pointer-varargs</h4>
<a name="foreign_002dfuncall_002dpointer_002dvarargs-1"></a>
<h3 class="heading">foreign-funcall-pointer-varargs</h3>
<a name="Syntax-54"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-foreign_002dfuncall_002dpointer_002dvarargs"></a>Macro: <strong>foreign-funcall-pointer-varargs</strong> <em>pointer options (fixed-arguments) &amp;rest arguments⇒ return-value</em></dt>
</dl>

<p><var>fixed-arguments</var> ::= { <var>arg-type</var> <var>arg</var> }* [<var>return-type</var>] <br>
<var>arguments</var> ::= { <var>arg-type</var> <var>arg</var> }* [<var>return-type</var>] <br>
<var>options</var> ::= (&amp;key <var>convention</var>) <br>
</p>
<a name="Arguments-and-Values-53"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>pointer</var></dt>
<dd><p>A foreign pointer.
</p>
</dd>
<dt><var>arg-type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>arg</var></dt>
<dd><p>An argument of type <var>arg-type</var>.
</p>
</dd>
<dt><var>return-type</var></dt>
<dd><p>A foreign type, <code>:void</code> by default.
</p>
</dd>
<dt><var>return-value</var></dt>
<dd><p>A lisp object.
</p>
</dd>
<dt><var>convention</var></dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.
</p></dd>
</dl>

<a name="Description-54"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>foreign-funcall-pointer-varargs</code> является основным 
примитивовом для вызова внешних функций с переменным числом аргументов. Он
ведет себя аналогично <code>foreign-funcall-pointer</code> за исключением
того, что <code>fixed-arguments</code> отличаются от остальных аргументов..
</p>
<a name="Examples-50"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer-as-string</span></i> <span class="paren2">(<span class="lisp-bg">s 100</span>)</span>
          <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">mem-ref s <span class="keyword">:char</span></span>)</span> 0</span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall-pointer-varargs
           <span class="paren3">(<span class="lisp-bg">foreign-symbol-pointer <span class="string">"sprintf"</span></span>)</span> <span class="paren3">(<span class="lisp-bg"></span>)</span> <span class="paren3">(<span class="lisp-bg"><span class="keyword">:pointer</span> s <span class="keyword">:string</span> <span class="string">"%.2f"</span></span>)</span>
           <span class="keyword">:double</span> <span class="paren3">(<span class="lisp-bg">coerce pi 'double-float</span>)</span> <span class="keyword">:int</span></span>)</span></span>)</span>
 ⇒ 3.14
</pre></div>

<hr>
<a name="translate_002dcamelcase_002dname"></a>
<div class="header">
<p>
Next: <a href="#translate_002dname_002dfrom_002dforeign" accesskey="n" rel="next">translate-name-from-foreign</a>, Previous: <a href="#foreign_002dfuncall_002dpointer_002dvarargs" accesskey="p" rel="prev">foreign-funcall-pointer-varargs</a>, Up: <a href="#Functions" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">translate-camelcase-name</h4>
<a name="translate_002dcamelcase_002dname-1"></a>
<h3 class="heading">translate-camelcase-name</h3>
<a name="Syntax-55"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-translate_002dcamelcase_002dname"></a>Function: <strong>translate-camelcase-name</strong> <em>name &amp;key upper-initial-p special-words⇒ return-value</em></dt>
</dl>

<a name="Arguments-and-Values-54"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>Either a symbol or a string.
</p>
</dd>
<dt><var>upper-initial-p</var></dt>
<dd><p>A generalized boolean.
</p>
</dd>
<dt><var>special words</var></dt>
<dd><p>A list of strings.
</p>
</dd>
<dt><var>return-value</var></dt>
<dd><p>If <var>name</var> is a symbol, this is a string, and vice versa.
</p></dd>
</dl>

<a name="Description-55"></a>
<h4 class="subheading">Description</h4>
<p><code>translate-camelcase-name</code> является вспомогательной
функцией для специализаций <code>translate-name-from-foreign</code> и
<code>translate-name-to-foreign</code>. Она обрабатывает общий
случай конвертации между внешними именами camelCase и именами lisp. 
<var>upper-initial-p</var> указывает, должна ли первая буква внешнего
имени быть в вернем регистре. <var>special-words</var> это список строк,
которые дожны рассматриваться атомарно при  преобразовании. Это список
чувствителен к регистру.
</p>
<a name="Examples-51"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name some-xml-function</span>)</span>
 ⇒ "someXmlFunction"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name some-xml-function <span class="keyword">:upper-initial-p</span> t</span>)</span>
 ⇒ "SomeXmlFunction"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name some-xml-function <span class="keyword">:special-words</span> '<span class="paren2">(<span class="lisp-bg"><span class="string">"XML"</span></span>)</span></span>)</span>
 ⇒ "someXMLFunction"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name <span class="string">"someXMLFunction"</span></span>)</span>
 ⇒ SOME-X-M-L-FUNCTION
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name <span class="string">"someXMLFunction"</span> <span class="keyword">:special-words</span> '<span class="paren2">(<span class="lisp-bg"><span class="string">"XML"</span></span>)</span></span>)</span>
 ⇒ SOME-XML-FUNCTION
</pre></div>

<a name="See-Also-50"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> <br>
<a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a> <br>
<a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>
</p>

<hr>
<a name="translate_002dname_002dfrom_002dforeign"></a>
<div class="header">
<p>
Next: <a href="#translate_002dname_002dto_002dforeign" accesskey="n" rel="next">translate-name-to-foreign</a>, Previous: <a href="#translate_002dcamelcase_002dname" accesskey="p" rel="prev">translate-camelcase-name</a>, Up: <a href="#Functions" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">translate-name-from-foreign</h4>
<a name="translate_002dname_002dfrom_002dforeign-1"></a>
<h3 class="heading">translate-name-from-foreign</h3>
<a name="Syntax-56"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-translate_002dname_002dfrom_002dforeign"></a>Function: <strong>translate-name-from-foreign</strong> <em>foreign-name package &amp;optional varp⇒ symbol</em></dt>
</dl>

<a name="Arguments-and-Values-55"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>foreign-name</var></dt>
<dd><p>A string denoting a foreign function.
</p>
</dd>
<dt><var>package</var></dt>
<dd><p>A Lisp package
</p>
</dd>
<dt><var>varp</var></dt>
<dd><p>A generalized boolean.
</p>
</dd>
<dt><var>symbol</var></dt>
<dd><p>The Lisp symbol to be used a function name.
</p></dd>
</dl>

<a name="Description-56"></a>
<h4 class="subheading">Description</h4>
<p><code>translate-name-from-foreign</code> используется <a href="#defcfun">defcfun</a> для
обработки преобразования внешних имен в имна lisp. По умолчанию, она преобразует
используя <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>. Однако, вы можете создать специализированные методы для этой функции,
чтобы преобразования более точно соответствовали соглашениям о
внешних именах во внешней библиотеке.
</p>
<p>Специализируйте <var>package</var> для нескольких пакетов. Это позволит
вам загружать библиотеки с различными соглашениями о преобразованиях имен.
</p>
<a name="Examples-52"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"someXmlFunction"</span> ...</span>)</span>
 ⇒ SOMEXMLFUNCTION
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-name-from-foreign <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">spec string</span>)</span>
                                                <span class="paren3">(<span class="lisp-bg">package <span class="paren4">(<span class="lisp-bg">eql <span class="special">*package*</span></span>)</span></span>)</span>
                                                &amp;optional varp</span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">name <span class="paren5">(<span class="lisp-bg">translate-camelcase-name spec</span>)</span></span>)</span></span>)</span>
            <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">if</span></i> varp <span class="paren4">(<span class="lisp-bg">intern <span class="paren5">(<span class="lisp-bg">format nil <span class="string">"*~a*"</span> name</span>)</span></span>)</span> name</span>)</span></span>)</span></span>)</span>
 ⇒ #&lt;STANDARD-METHOD TRANSLATE-NAME-FROM-FOREIGN <span class="paren1">(<span class="lisp-bg">STRING <span class="paren2">(<span class="lisp-bg">EQL #&lt;Package <span class="string">"SOME-PACKAGE"</span>&gt;</span>)</span></span>)</span>&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"someXmlFunction"</span> ...</span>)</span>
 ⇒ SOME-XML-FUNCTION
</pre></div>

<a name="See-Also-51"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcfun">defcfun</a> <br>
<a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a> <br>
<a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a> <br>
<a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>
</p>

<hr>
<a name="translate_002dname_002dto_002dforeign"></a>
<div class="header">
<p>
Next: <a href="#translate_002dunderscore_002dseparated_002dname" accesskey="n" rel="next">translate-underscore-separated-name</a>, Previous: <a href="#translate_002dname_002dfrom_002dforeign" accesskey="p" rel="prev">translate-name-from-foreign</a>, Up: <a href="#Functions" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">translate-name-to-foreign</h4>
<a name="translate_002dname_002dto_002dforeign-1"></a>
<h3 class="heading">translate-name-to-foreign</h3>
<a name="Syntax-57"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-translate_002dname_002dto_002dforeign"></a>Function: <strong>translate-name-to-foreign</strong> <em>lisp-name package &amp;optional varp⇒ string</em></dt>
</dl>

<a name="Arguments-and-Values-56"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>lisp-name</var></dt>
<dd><p>A symbol naming the Lisp function to be created.
</p>
</dd>
<dt><var>package</var></dt>
<dd><p>A Lisp package
</p>
</dd>
<dt><var>varp</var></dt>
<dd><p>A generalized boolean.
</p>
</dd>
<dt><var>string</var></dt>
<dd><p>The string representing the foreign function name.
</p></dd>
</dl>

<a name="Description-57"></a>
<h4 class="subheading">Description</h4>
<p><code>translate-name-to-foreign</code> используется в <a href="#defcfun">defcfun</a> для обработки
преобразования имен lisp во внешние имена. По умолчанию оно проводит преобразование
используя <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>. Однако, вы можете создать специализированныйе методы для этой функции, чтобы более точно соответствовать
соглашению об именах во внешней библиотеке.
</p>
<p>Специализируйте <var>package</var> на несколько пакетов. Это позволит другим пакетам загружать
библиотеки с различными соглашениями о преобрзовании имен.
</p>
<a name="Examples-53"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> some-xml-function ...</span>)</span>
 ⇒ "some_xml_function"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-name-to-foreign <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">spec symbol</span>)</span>
                                              <span class="paren3">(<span class="lisp-bg">package <span class="paren4">(<span class="lisp-bg">eql <span class="special">*package*</span></span>)</span></span>)</span>
                                              &amp;optional varp</span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">name <span class="paren5">(<span class="lisp-bg">translate-camelcase-name spec</span>)</span></span>)</span></span>)</span>
            <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">if</span></i> varp <span class="paren4">(<span class="lisp-bg">subseq name 1 <span class="paren5">(<span class="lisp-bg">1- <span class="paren6">(<span class="lisp-bg">length name</span>)</span></span>)</span></span>)</span> name</span>)</span></span>)</span></span>)</span>
 ⇒ #&lt;STANDARD-METHOD TRANSLATE-NAME-TO-FOREIGN <span class="paren1">(<span class="lisp-bg">STRING <span class="paren2">(<span class="lisp-bg">EQL #&lt;Package <span class="string">"SOME-PACKAGE"</span>&gt;</span>)</span></span>)</span>&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> some-xml-function ...</span>)</span>
 ⇒ "someXmlFunction"
</pre></div>

<a name="See-Also-52"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#defcfun">defcfun</a> <br>
<a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a> <br>
<a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> <br>
<a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>
</p>

<hr>
<a name="translate_002dunderscore_002dseparated_002dname"></a>
<div class="header">
<p>
Previous: <a href="#translate_002dname_002dto_002dforeign" accesskey="p" rel="prev">translate-name-to-foreign</a>, Up: <a href="#Functions" accesskey="u" rel="up">Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">translate-underscore-separated-name</h4>
<a name="translate_002dunderscore_002dseparated_002dname-1"></a>
<h3 class="heading">translate-underscore-separated-name</h3>
<a name="Syntax-58"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-translate_002dunderscore_002dseparated_002dname"></a>Function: <strong>translate-underscore-separated-name</strong> <em>name⇒ return-value</em></dt>
</dl>

<a name="Arguments-and-Values-57"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>Either a symbol or a string.
</p>
</dd>
<dt><var>return-value</var></dt>
<dd><p>If <var>name</var> is a symbol, this is a string, and vice versa.
</p></dd>
</dl>

<a name="Description-58"></a>
<h4 class="subheading">Description</h4>
<p><code>translate-underscore-separated-name</code> является вспомогательной функцией для
специализаций <a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> и
<a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a>. Она обрабатывает
общий случай преобразования между внешними именами разделенными подчеркиваниями и именами lisp.
</p>
<a name="Examples-54"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-underscore-separated-name some-xml-function</span>)</span>
 ⇒ "some_xml_function"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name <span class="string">"some_xml_function"</span></span>)</span>
 ⇒ SOME-XML-FUNCTION
</pre></div>

<a name="See-Also-53"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> <br>
<a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a> <br>
<a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a>
</p>

<hr>
<a name="Libraries"></a>
<div class="header">
<p>
Next: <a href="#Callbacks" accesskey="n" rel="next">Callbacks</a>, Previous: <a href="#Functions" accesskey="p" rel="prev">Functions</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Libraries-1"></a>
<h2 class="chapter">11 Библиотеки</h2>

<table class="menu" cellspacing="0" border="0">
<tbody><tr><td valign="top" align="left">• <a href="#Defining-a-library" accesskey="1">Defining a library</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Library-definition-style" accesskey="2">Library definition style</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">
Dictionary

</pre></th></tr><tr><td valign="top" align="left">• <a href="#close_002dforeign_002dlibrary" accesskey="3">close-foreign-library</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Close a foreign library.
</td></tr>
<tr><td valign="top" align="left">• <a href="#g_t_002adarwin_002dframework_002ddirectories_002a" accesskey="4">*darwin-framework-directories*</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Search path for Darwin frameworks.
</td></tr>
<tr><td valign="top" align="left">• <a href="#define_002dforeign_002dlibrary" accesskey="5">define-foreign-library</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Explain how to load a foreign library.
</td></tr>
<tr><td valign="top" align="left">• <a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a" accesskey="6">*foreign-library-directories*</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Search path for shared libraries.
</td></tr>
<tr><td valign="top" align="left">• <a href="#load_002dforeign_002dlibrary" accesskey="7">load-foreign-library</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Load a foreign library.
</td></tr>
<tr><td valign="top" align="left">• <a href="#load_002dforeign_002dlibrary_002derror" accesskey="8">load-foreign-library-error</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Signalled on failure of its namesake.
</td></tr>
<tr><td valign="top" align="left">• <a href="#use_002dforeign_002dlibrary" accesskey="9">use-foreign-library</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Load a foreign library when needed.
</td></tr>
</tbody></table>

<hr>
<a name="Defining-a-library"></a>
<div class="header">
<p>
Next: <a href="#Library-definition-style" accesskey="n" rel="next">Library definition style</a>, Previous: <a href="#Libraries" accesskey="p" rel="prev">Libraries</a>, Up: <a href="#Libraries" accesskey="u" rel="up">Libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Defining-a-library-1"></a>
<h3 class="section">11.1 Определение библиотеки</h3>

<p>Почти весь внешний код, к которому вы, возможно, захотите получить доступ,
существует в виде какой-то разделяемой(общей) библиотеки.  Знаение
 <em>разделяемая бибилиотека(shared library)</em> различается для
различных платформ, но для наших целей мы рассмотрим, что она включает 
<samp>.so</samp> файлы для <small>UNIX</small>, платформы для Darwin (и
произвдные, такие как Mac <acronym>OS X</acronym>), и <samp>.dll</samp> 
файлы в Windows.
</p>
<p>Внедрение одной из этих библиотек в образ Lisp обычно представляет
собой двух этапный процесс.
</p>
<ol>
<li> Описывается для <acronym>CFFI</acronym> как загрузить библиотеку
в будущем, в зависимости от платформы и других факторов, с помощью
формы верхнего уровня code>define-foreign-library</code>.

</li><li> Загрузите библиотеку определенную с помощью формы
<code>use-foreign-library</code> или с помощью вызов функции
<code>load-foreign-library</code>.
</li></ol>

<p>См. <a href="#Tutorial_002dLoading">Загрузка внешних библиотек</a>, для ознакомления с
примером работы двух вышеупомянутых шагов.
</p>

<hr>
<a name="Library-definition-style"></a>
<div class="header">
<p>
Next: <a href="#close_002dforeign_002dlibrary" accesskey="n" rel="next">close-foreign-library</a>, Previous: <a href="#Defining-a-library" accesskey="p" rel="prev">Defining a library</a>, Up: <a href="#Libraries" accesskey="u" rel="up">Libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Library-definition-style-1"></a>
<h3 class="section">11.2 Стиль определения библиотеки</h3>

<p>Глядя на определение библиотеки <code>libcurl</code>, представленное ранее, вы можете
спросить, почемы мы просто не сделали так:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-library</span></i> libcurl
    <span class="paren2">(<span class="lisp-bg">t <span class="paren3">(<span class="lisp-bg"><span class="keyword">:default</span> <span class="string">"libcurl"</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>На самом деле, это будет работать так же хорошо на компьютере на котором я
тестировал этот учебник. Однако есть несколько веских причин представить номер
текущей версии <samp>.so</samp>. А именно, <samp>.so</samp> без версии не
вклюается в пакет в большинстве систем <small>UNIX</small> вместе с реальной,
полностью версионной библиотекой; вместо этого, она(библиотека) включается в пакет
âdevelopmentâ вместе с заголовками Си и статическими библиотеками <samp>.a</samp>.
</p>
<p>Причина, по которой <acronym>CFFI</acronym> не пытается объяснить это, заключается
в значении номеров версий.  Полная обработка версий разделяемой библиотеки
выходит за рамки данного руководства; см. <a href="http://www.gnu.org/software/libtool/manual/http://www.gnu.org/software/libtool/manual.html#Versioning">Library
interface versions</a> in <cite><acronym>GNU</acronym> Libtool</cite>, для
получения полезной информации.  Учтите, что в наших целях, что несоответствие
между проверенной версией библиотеки и установленной версией библиотеки может
привести к неопределенному поведению.<a name="DOCF12" href="#FOOT12"><sup>12</sup></a>
</p>
<blockquote>
<p><strong>Примечание разработчика:</strong> <em>Может быть, некоторые здесь надо
сделать некоторые замечания о OS X, о которой я мало знаю.  âstephen</em>
</p></blockquote>

<hr>
<a name="close_002dforeign_002dlibrary"></a>
<div class="header">
<p>
Next: <a href="#g_t_002adarwin_002dframework_002ddirectories_002a" accesskey="n" rel="next">*darwin-framework-directories*</a>, Previous: <a href="#Library-definition-style" accesskey="p" rel="prev">Library definition style</a>, Up: <a href="#Libraries" accesskey="u" rel="up">Libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">close-foreign-library</h4>
<a name="close_002dforeign_002dlibrary-1"></a>
<h3 class="heading">close-foreign-library</h3>
<a name="Syntax-59"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-close_002dforeign_002dlibrary"></a>Function: <strong>close-foreign-library</strong> <em>library⇒ success</em></dt>
</dl>

<a name="Arguments-and-Values-58"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>library</var></dt>
<dd><p>A symbol or an instance of <code>foreign-library</code>.
</p>
</dd>
<dt><var>success</var></dt>
<dd><p>A Lisp boolean.
</p></dd>
</dl>

<a name="Description-59"></a>
<h4 class="subheading">Description</h4>

<p>Закрывает библиотеку(<var>library</var>), которая может быть
символом обозначающим библиотеку, определенную с помощью  
<code>define-foreign-library</code> или экземпляром <code>foreign-library</code>,
возвращаемым <code>load-foreign-library</code>.
</p>

<a name="See-Also-54"></a>
<h4 class="subheading">See Also</h4>

<p><a href="#define_002dforeign_002dlibrary">define-foreign-library</a> <br>
<a href="#load_002dforeign_002dlibrary">load-foreign-library</a> <br>
<a href="#use_002dforeign_002dlibrary">use-foreign-library</a>
</p>

<hr>
<a name="g_t_002adarwin_002dframework_002ddirectories_002a"></a>
<div class="header">
<p>
Next: <a href="#define_002dforeign_002dlibrary" accesskey="n" rel="next">define-foreign-library</a>, Previous: <a href="#close_002dforeign_002dlibrary" accesskey="p" rel="prev">close-foreign-library</a>, Up: <a href="#Libraries" accesskey="u" rel="up">Libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">*darwin-framework-directories*</h4>
<a name="g_t_002adarwin_002dframework_002ddirectories_002a-1"></a>
<h3 class="heading">*darwin-framework-directories*</h3>
<a name="Syntax-60"></a>
<h4 class="subheading">Syntax</h4>

<dl>
<dt><a name="index-_002adarwin_002dframework_002ddirectories_002a"></a>Special Variable: <strong>*darwin-framework-directories*</strong></dt>
</dl>

<a name="Value-type-1"></a>
<h4 class="subheading">Value type</h4>

<p>A list, in which each element is a string, a pathname, or a simple
Lisp expression.
</p>
<a name="Initial-value-1"></a>
<h4 class="subheading">Initial value</h4>

<p>A list containing the following, in order: an expression corresponding
to Darwin path <samp>~/Library/Frameworks/</samp>,
<code>#P"/Library/Frameworks/"</code>, and
<code>#P"/System/Library/Frameworks/"</code>.
</p>
<a name="Description-60"></a>
<h4 class="subheading">Description</h4>

<p>Значение âпростое выражение на Lispâ объясняется в
<a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a>.  
В отличии от этой переменной, это не запасной путь поиска; значение по умолчанию, описанное
выше, предназначено для обеспечения достаточно полного пуит поиска в системах Darwin.
</p>
<a name="Examples-55"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">lib <span class="paren4">(<span class="lisp-bg">load-foreign-library '<span class="paren5">(<span class="lisp-bg"><span class="keyword">:framework</span> <span class="string">"OpenGL"</span></span>)</span></span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-library-pathname lib</span>)</span></span>)</span>
 ⇒ #P"/System/Library/Frameworks/OpenGL.framework/OpenGL"
</pre></div>

<a name="See-also-1"></a>
<h4 class="subheading">See also</h4>

<p><a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a> <br>
<a href="#define_002dforeign_002dlibrary">define-foreign-library</a>
</p>

<hr>
<a name="define_002dforeign_002dlibrary"></a>
<div class="header">
<p>
Next: <a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a" accesskey="n" rel="next">*foreign-library-directories*</a>, Previous: <a href="#g_t_002adarwin_002dframework_002ddirectories_002a" accesskey="p" rel="prev">*darwin-framework-directories*</a>, Up: <a href="#Libraries" accesskey="u" rel="up">Libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">define-foreign-library</h4>
<a name="define_002dforeign_002dlibrary-1"></a>
<h3 class="heading">define-foreign-library</h3>

<a name="Syntax-61"></a>
<h4 class="subheading">Syntax</h4>

<dl>
<dt><a name="index-define_002dforeign_002dlibrary"></a>Macro: <strong>define-foreign-library</strong> <em>name-and-options { load-clause }*⇒ name</em></dt>
</dl>

<p>name-and-options ::= name | (name &amp;key convention search-path)
load-clause ::= (feature library &amp;key convention search-path)
</p>
<a name="Arguments-and-Values-59"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>A symbol.
</p>
</dd>
<dt><var>feature</var></dt>
<dd><p>A feature expression.
</p>
</dd>
<dt><var>library</var></dt>
<dd><p>A library designator.
</p>
</dd>
<dt><var>convention</var></dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>
</p>
</dd>
<dt><var>search-path</var></dt>
<dd><p>A path or list of paths where the library will be searched if not found in
system-global directories. Paths specified in a load clause take priority over
paths specified as library option, with *foreign-library-directories* having
lowest priority.
</p></dd>
</dl>

<a name="Description-61"></a>
<h4 class="subheading">Description</h4>

<p>Создает новый указатель библиотеки с именем <var>name</var>.  
<var>load-clause</var> описывают как загрузить этот указатель при передаче
в <code>load-foreign-library</code> или <code>use-foreign-library</code>.
</p>
<p>При попытке загрузить библиотеку <var>name</var>, соответствующая функция ищет
предложения <var>load-clause</var> по порядку, чтобы найти первое, где функция
<var>feature</var> вычисляется в true.  Это происходит в любой из следующих
ситуаций:
</p>
<ol>
<li> Если функция <var>feature</var> является символом, присутствующим в  <code>common-lisp:*features*</code>.

</li><li> Если <var>feature</var> является списком, в зависимости от ключевого слова <code>(first <var>feature</var>)</code>:

<dl compact="compact">
<dt><code>:and</code></dt>
<dd><p>Все выражения в <code>(rest <var>feature</var>)</code> должны быть true.
</p>
</dd>
<dt><code>:or</code></dt>
<dd><p>По крайней мере одно выражение из <code>(rest <var>feature</var>)</code> должно быть true.
</p>
</dd>
<dt><code>:not</code></dt>
<dd><p>Выражение <code>(second <var>feature</var>)</code> не равно true.
</p></dd>
</dl>

</li><li> Наконец, если <var>feature</var> равно <code>t</code>, это предложение <var>load-clause</var> 
выбирается без вариантов.
</li></ol>

<p>После нахождения первой истинной функции(<var>feature</var>), загрузчик
библиотеки загружает <var>library</var>.  Значение  âуказатель бибилиотеки(library designator)â
описано в <a href="#load_002dforeign_002dlibrary">load-foreign-library</a>.
</p>
<p>Функуции связанные с библиотекой, определенной с помощью
<code>define-foreign-library</code> (например через опцию <code>:library</code>
<code>defcfun</code>â, будут наследовать опции библиотеки.  
Приоритет следующий:
</p>
<ol>
<li> специализированные для <code>defcfun</code>/<code>foreign-funcall</code> опции;

</li><li> опции <var>load-clause</var>;

</li><li> глобальные опции библиотеки (аргумент <var>name-and-options</var>)
</li></ol>

<a name="Examples-56"></a>
<h4 class="subheading">Examples</h4>

<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>.
</p>

<a name="See-Also-55"></a>
<h4 class="subheading">See Also</h4>

<p><a href="#close_002dforeign_002dlibrary">close-foreign-library</a> <br>
<a href="#load_002dforeign_002dlibrary">load-foreign-library</a>
</p>

<hr>
<a name="g_t_002aforeign_002dlibrary_002ddirectories_002a"></a>
<div class="header">
<p>
Next: <a href="#load_002dforeign_002dlibrary" accesskey="n" rel="next">load-foreign-library</a>, Previous: <a href="#define_002dforeign_002dlibrary" accesskey="p" rel="prev">define-foreign-library</a>, Up: <a href="#Libraries" accesskey="u" rel="up">Libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">*foreign-library-directories*</h4>
<a name="g_t_002aforeign_002dlibrary_002ddirectories_002a-1"></a>
<h3 class="heading">*foreign-library-directories*</h3>
<a name="Syntax-62"></a>
<h4 class="subheading">Syntax</h4>

<dl>
<dt><a name="index-_002aforeign_002dlibrary_002ddirectories_002a"></a>Special Variable: <strong>*foreign-library-directories*</strong></dt>
</dl>

<a name="Value-type-2"></a>
<h4 class="subheading">Value type</h4>

<p>A list, in which each element is a string, a pathname, or a simple
Lisp expression.
</p>
<a name="Initial-value-2"></a>
<h4 class="subheading">Initial value</h4>

<p>The empty list.
</p>
<a name="Description-62"></a>
<h4 class="subheading">Description</h4>

<p>Вы не должны использовать эту переменную.
</p>
<p>Большинство, если не все, Lisp поддерживаемые <acronym>CFFI</acronym> имеют разумный
алгоритм поиска по умолчанию внешних библиотек.  Например, Lisp-ы  для
<small>UNIX</small> обычно вызывают
<a href="http://www.opengroup.org/onlinepubs/009695399/functions/dlopen.html"><code>dlopen(3)</code></a>, 
который в свою очередь просматривает каталоги системных библиотек.  Только в случае
неудачи <acronym>CFFI</acronym> ищет указанный файл библиотеки в этих каталогах и загружает
его оттуда, если он найден.
</p>
<p>Таким образом, предполагается, что это запасной вариант только для <acronym>CFFI</acronym>, для 
конфигурации поиска библиотек предоставляемых вашей операционной системой.  Например,
если вы распространяете внешнюю библиотеку вместе с вашим пакетом Lisp, вы можете добавить
каталог, содержащий библиотеку, в этот список и ожидать, что <acronym>CFFI</acronym> найдет её.
</p>
<p> <em>Простое Лисп выражение(simple Lisp expression)</em> предназначено для обеспечения
функциональнсти, обычно используемой в поиске путей, так же как 
<acronym>ASDF</acronym>âs<a name="DOCF13" href="#FOOT13"><sup>13</sup></a>, и определяется
рекурсивно следующим образом:<a name="DOCF14" href="#FOOT14"><sup>14</sup></a>
</p>
<ol>
<li> Список, чей â<samp>первый</samp>â элемент является обозначением функции, 
а выражение â<samp>rest</samp>â - это список простых выражений Lisp, которые должны
быть вычислены и переданы обозначенной функции.  Результатом является результат вызова фунции.

</li><li> Символ, разультатом которого является его значение.

</li><li> Все остальное вычисляющее себя.
</li></ol>

<p>Результа вычисления <em>простого выражения Lisp</em> должен дать
<em>указатель(designator)</em> для списка(<em>list</em>) указателей пути(<em>pathname designators</em>).
</p>
<p><strong>Замечание</strong>: в Common Lisp, <code>#p"/foo/bar"</code> обозначает файл
<em>bar</em> в каталоге <em>/foo</em>, тогда как <code>#p"/foo/bar/"</code> обозначает
каталог <em>/foo/bar</em>. Имейте в виду это, при настройке значения
<code>*foreign-library-directories*</code>.
</p>

<a name="Examples-57"></a>
<h4 class="subheading">Examples</h4>

<div class="example">
<pre class="example">$ ls
-| liblibli.so    libli.lisp
</pre></div>

<p>In <samp>libli.lisp</samp>:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">pushnew #P<span class="string">"/home/sirian/lisp/libli/"</span> <span class="special">*foreign-library-directories*</span>
           <span class="keyword">:test</span> #'equal</span>)</span>

  <span class="paren1">(<span class="lisp-bg">load-foreign-library '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:default</span> <span class="string">"liblibli"</span></span>)</span></span>)</span>
</pre></div>

<p>The following example would achieve the same effect:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">pushnew '<span class="paren2">(<span class="lisp-bg">merge-pathnames #p<span class="string">"lisp/libli/"</span> <span class="paren3">(<span class="lisp-bg">user-homedir-pathname</span>)</span></span>)</span>
            <span class="special">*foreign-library-directories*</span>
            <span class="keyword">:test</span> #'equal</span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg"><span class="paren2">(<span class="lisp-bg">MERGE-PATHNAMES #P<span class="string">"lisp/libli/"</span> <span class="paren3">(<span class="lisp-bg">USER-HOMEDIR-PATHNAME</span>)</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg">load-foreign-library '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:default</span> <span class="string">"liblibli"</span></span>)</span></span>)</span>
</pre></div>

<a name="See-also-2"></a>
<h4 class="subheading">See also</h4>

<p><a href="#g_t_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a> <br>
<a href="#define_002dforeign_002dlibrary">define-foreign-library</a>
</p>

<hr>
<a name="load_002dforeign_002dlibrary"></a>
<div class="header">
<p>
Next: <a href="#load_002dforeign_002dlibrary_002derror" accesskey="n" rel="next">load-foreign-library-error</a>, Previous: <a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a" accesskey="p" rel="prev">*foreign-library-directories*</a>, Up: <a href="#Libraries" accesskey="u" rel="up">Libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">load-foreign-library</h4>
<a name="load_002dforeign_002dlibrary-1"></a>
<h3 class="heading">load-foreign-library</h3>
<a name="Syntax-63"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-load_002dforeign_002dlibrary"></a>Function: <strong>load-foreign-library</strong> <em>library-designator⇒ library</em></dt>
</dl>

<a name="Arguments-and-Values-60"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>library-designator</var></dt>
<dd><p>A library designator.
</p>
</dd>
<dt><var>library-designator</var></dt>
<dd><p>An instance of <code>foreign-library</code>.
</p></dd>
</dl>

<a name="Description-63"></a>
<h4 class="subheading">Description</h4>

<p>Загружает библиотеку, указанную как <var>library-designator</var>. Указатель библиотеки(<em>library
designator</em>) определяется следующим образом:
</p>
<ol>
<li> Если символ, считается именем, определенным ранее с помощью
<code>define-foreign-library</code>.

</li><li> Если строка или путь, передается как строка имени(namestring) непосредственно
загрузчику реализации(лиспа) внешних библиотек.  Если это не помогло, ищет в
каталогах <code>*foreign-library-directories*</code> с помощью
<code>cl:probe-file</code>; если найден, абсолютный путь передается загрузчику реализации.

</li><li> Если список, значение зависит от <code>(first <var>library</var>)</code>:

<dl compact="compact">
<dt><code>:framework</code></dt>
<dd><p>Вторым элементом списка считается имя фреймворка Darwin, которое затем
ищется в <code>*darwin-framework-directories*</code>, и загружается когда
найдено.
</p>
</dd>
<dt><code>:or</code></dt>
<dd><p>Каждый оставшийся элемент списка, сам по себе является <em>обозначением библиотеки(library designator)</em>, загружается по порядку, пока один из них не будет завершен успешно.
</p>
</dd>
<dt><code>:default</code></dt>
<dd><p>В соответствии с соглашением о преобразовании имен платформы имя преобразуется 
в имя разделяемой библиотеки, и результирующая строка загружается как указатель библиотеки( <em>library
designator</em>).
Например, в  <small>UNIX</small>, к имени добавляется суффикс
<samp>.so</samp>.
</p></dd>
</dl>
</li></ol>

<p>Если библиотека уже загружена, она будет перезагружена.
</p>
<p>Если загрузка не удалась, выдается сигнал <code>load-foreign-library-error</code>.
</p>
<p><strong>Обратите внимание:</strong> для системных библиотек вам не нужно указывать
каталог, содержащий библиотеку.  Каждая операционная система имеет свое представление
о путях поиска по умолчанию, и вы должны полагаться на него, когда это разумно.
</p>
<a name="Implementation_002dspecific-Notes-4"></a>
<h4 class="subheading">Примечания специфичные для реализаций</h4>
<p>На платформах ECL, где его динамический FFI не поддерживается (например,
когда <code>:dffi</code> отсутствует в <code>*features*</code>),
<code>cffi:load-foreign-library</code> не работает, и вы должны использовать собственную 
ECLâ <code>ffi:load-foreign-library</code> с постоянным строковым аргументом.
</p>
<a name="Examples-58"></a>
<h4 class="subheading">Examples</h4>

<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>.
</p>
<a name="See-Also-56"></a>
<h4 class="subheading">See Also</h4>

<p><a href="#close_002dforeign_002dlibrary">close-foreign-library</a> <br>
<a href="#g_t_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a> <br>
<a href="#define_002dforeign_002dlibrary">define-foreign-library</a> <br>
<a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a> <br>
<a href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a> <br>
<a href="#use_002dforeign_002dlibrary">use-foreign-library</a>
</p>

<hr>
<a name="load_002dforeign_002dlibrary_002derror"></a>
<div class="header">
<p>
Next: <a href="#use_002dforeign_002dlibrary" accesskey="n" rel="next">use-foreign-library</a>, Previous: <a href="#load_002dforeign_002dlibrary" accesskey="p" rel="prev">load-foreign-library</a>, Up: <a href="#Libraries" accesskey="u" rel="up">Libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">load-foreign-library-error</h4>
<a name="load_002dforeign_002dlibrary_002derror-1"></a>
<h3 class="heading">load-foreign-library-error</h3>

<a name="Syntax-64"></a>
<h4 class="subheading">Syntax</h4>

<dl>
<dt><a name="index-load_002dforeign_002dlibrary_002derror"></a>Condition Type: <strong>load-foreign-library-error</strong></dt>
</dl>

<a name="Class-precedence-list"></a>
<h4 class="subheading">Class precedence list</h4>

<p><code>load-foreign-library-error</code>, <code>error</code>,
<code>serious-condition</code>, <code>condition</code>, <code>t</code>
</p>
<a name="Description-64"></a>
<h4 class="subheading">Description</h4>

<p>Сигнализирует, когда загрузку внешней библиотеки выполнить полностью не получилось.  
Точное значение варьируется в зависимости от реальных условий работы, но почти повсеместно
сообщени реализации об ошибке - бесполезно..
Тем не менее, <acronym>CFFI</acronym> предоставляет полезные перезагрузки <code>retry</code> и
<code>use-value</code>; вызовите <code>retry</code> чтобы попытаться снова загрузить
внешнюю библиотеку, или <code>use-value</code> для перезапуска попытки загрузки другого
обозначения внешней библиотеки.
</p>
<a name="See-also-3"></a>
<h4 class="subheading">See also</h4>

<p><a href="#load_002dforeign_002dlibrary">load-foreign-library</a>
</p>

<hr>
<a name="use_002dforeign_002dlibrary"></a>
<div class="header">
<p>
Previous: <a href="#load_002dforeign_002dlibrary_002derror" accesskey="p" rel="prev">load-foreign-library-error</a>, Up: <a href="#Libraries" accesskey="u" rel="up">Libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">use-foreign-library</h4>
<a name="use_002dforeign_002dlibrary-1"></a>
<h3 class="heading">use-foreign-library</h3>

<a name="Syntax-65"></a>
<h4 class="subheading">Syntax</h4>

<dl>
<dt><a name="index-use_002dforeign_002dlibrary"></a>Macro: <strong>use-foreign-library</strong> <em>name</em></dt>
</dl>

<a name="Arguments-and-values"></a>
<h4 class="subheading">Arguments and values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>A library designator; unevaluated.
</p></dd>
</dl>

<a name="Description-65"></a>
<h4 class="subheading">Description</h4>

<p>См. <a href="#load_002dforeign_002dlibrary">load-foreign-library</a>, чтобы узнать
значение âуказатель библиотеки(library designator)â.  Предполагается, что форма
верхнего уровня, идиоматически используемая после формы <code>define-foreign-library</code>
 для продолжения и загрузки библиотеки. Наконец, в реализациях, где обычного выполнения
недостаточно для загрузки внешней библиотеки, она загружается в нужное время.
<a name="DOCF15" href="#FOOT15"><sup>15</sup></a>
</p>

<a name="Examples-59"></a>
<h4 class="subheading">Examples</h4>

<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>.
</p>

<a name="See-also-4"></a>
<h4 class="subheading">See also</h4>

<p><a href="#load_002dforeign_002dlibrary">load-foreign-library</a>
</p>

<hr>
<a name="Callbacks"></a>
<div class="header">
<p>
Next: <a href="#The-Groveller" accesskey="n" rel="next">The Groveller</a>, Previous: <a href="#Libraries" accesskey="p" rel="prev">Libraries</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Callbacks-1"></a>
<h2 class="chapter">12 Обратные вызовы(Callbacks)</h2>

<table class="menu" cellspacing="0" border="0">
<tbody><tr><th colspan="3" valign="top" align="left"><pre class="menu-comment">Dictionary

</pre></th></tr><tr><td valign="top" align="left">• <a href="#callback" accesskey="1">callback</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#defcallback" accesskey="2">defcallback</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#get_002dcallback" accesskey="3">get-callback</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
</tbody></table>

<hr>
<a name="callback"></a>
<div class="header">
<p>
Next: <a href="#defcallback" accesskey="n" rel="next">defcallback</a>, Previous: <a href="#Callbacks" accesskey="p" rel="prev">Callbacks</a>, Up: <a href="#Callbacks" accesskey="u" rel="up">Callbacks</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">callback</h4>
<a name="callback-1"></a>
<h3 class="heading">callback</h3>
<a name="Syntax-66"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-callback"></a>Macro: <strong>callback</strong> <em>symbol⇒ pointer</em></dt>
</dl>

<a name="Arguments-and-Values-61"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>symbol</var></dt>
<dd><p>A symbol denoting a callback.
</p>
</dd>
<dt><var>pointer</var></dt>
<dt><var>new-value</var></dt>
<dd><p>A pointer.
</p></dd>
</dl>

<a name="Description-66"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>callback</code> аналогичен  специальному оператору в стандартном CL
 <code>function</code> и возвращает указатель на обратный вызов(callback),
обозначаемый символом <var>name</var>.
</p>
<a name="Examples-60"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcallback</span></i> sum <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">a <span class="keyword">:int</span></span>)</span> <span class="paren3">(<span class="lisp-bg">b <span class="keyword">:int</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">+ a b</span>)</span></span>)</span>
 ⇒ SUM
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">callback sum</span>)</span>
 ⇒ #&lt;A Mac Pointer #x102350&gt;
</pre></div>

<a name="See-Also-57"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#get_002dcallback">get-callback</a> <br>
<a href="#defcallback">defcallback</a>
</p>

<hr>
<a name="defcallback"></a>
<div class="header">
<p>
Next: <a href="#get_002dcallback" accesskey="n" rel="next">get-callback</a>, Previous: <a href="#callback" accesskey="p" rel="prev">callback</a>, Up: <a href="#Callbacks" accesskey="u" rel="up">Callbacks</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">defcallback</h4>
<a name="defcallback-1"></a>
<h3 class="heading">defcallback</h3>
<a name="Syntax-67"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-defcallback"></a>Macro: <strong>defcallback</strong> <em>name-and-options return-type arguments &amp;body body⇒ name</em></dt>
</dl>

<p>name-and-options ::= name | (name &amp;key convention)
arguments ::= ({ (arg-name arg-type) }*)
</p>
<a name="Arguments-and-Values-62"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>name</var></dt>
<dd><p>A symbol naming the callback created.
</p>
</dd>
<dt><var>return-type</var></dt>
<dd><p>The foreign type for the callbackâs return value.
</p>
</dd>
<dt><var>arg-name</var></dt>
<dd><p>A symbol.
</p>
</dd>
<dt><var>arg-type</var></dt>
<dd><p>A foreign type.
</p>
</dd>
<dt><var>convention</var></dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.
</p></dd>
</dl>

<a name="Description-67"></a>
<h4 class="subheading">Description</h4>
<p>Макрос <code>defcallback</code> определяет функцию Lisp, которую можно вызвать
из Си. Аргументы, передаваемые этой функции, будут преобразованы в соответствующее
представление Lisp, а её возвращаемое значение будет преобразовано в представление Си.
</p>
<p>Эта функция Lisp может быть доступна с помощью макроса <code>callback</code> или
функции <code>get-callback</code>.
</p>
<p><strong>Примечание о переносимости:</strong> <code>defcallback</code> не будет 
работать корректно на некоторых Лиспах, если это не будет формой верхнего уровня.
</p>
<a name="Examples-61"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"qsort"</span> <span class="keyword">:void</span>
    <span class="paren2">(<span class="lisp-bg">base <span class="keyword">:pointer</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">nmemb <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">size <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">fun-compar <span class="keyword">:pointer</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcallback</span></i> &lt; <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">a <span class="keyword">:pointer</span></span>)</span> <span class="paren3">(<span class="lisp-bg">b <span class="keyword">:pointer</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">x <span class="paren5">(<span class="lisp-bg">mem-ref a <span class="keyword">:int</span></span>)</span></span>)</span>
          <span class="paren4">(<span class="lisp-bg">y <span class="paren5">(<span class="lisp-bg">mem-ref b <span class="keyword">:int</span></span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">cond</span></i> <span class="paren4">(<span class="lisp-bg"><span class="paren5">(<span class="lisp-bg">&gt; x y</span>)</span> 1</span>)</span>
            <span class="paren4">(<span class="lisp-bg"><span class="paren5">(<span class="lisp-bg">&lt; x y</span>)</span> -1</span>)</span>
            <span class="paren4">(<span class="lisp-bg">t 0</span>)</span></span>)</span></span>)</span></span>)</span>

  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">array <span class="keyword">:int</span> 10</span>)</span>
          <span class="comment">;; Initialize array.
  </span>        <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 and n in '<span class="paren3">(<span class="lisp-bg">7 2 10 4 3 5 1 6 9 8</span>)</span>
                do <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span> n</span>)</span></span>)</span>
          <span class="comment">;; Sort it.
  </span>        <span class="paren2">(<span class="lisp-bg">qsort array 10 <span class="paren3">(<span class="lisp-bg">foreign-type-size <span class="keyword">:int</span></span>)</span> <span class="paren3">(<span class="lisp-bg">callback &lt;</span>)</span></span>)</span>
          <span class="comment">;; Return it as a list.
  </span>        <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 10
                collect <span class="paren3">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span></span>)</span></span>)</span>
 ⇒ <span class="paren1">(<span class="lisp-bg">1 2 3 4 5 6 7 8 9 10</span>)</span>
</pre></div>

<a name="See-Also-58"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#callback">callback</a> <br>
<a href="#get_002dcallback">get-callback</a>
</p>

<hr>
<a name="get_002dcallback"></a>
<div class="header">
<p>
Previous: <a href="#defcallback" accesskey="p" rel="prev">defcallback</a>, Up: <a href="#Callbacks" accesskey="u" rel="up">Callbacks</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="node-heading">get-callback</h4>
<a name="get_002dcallback-1"></a>
<h3 class="heading">get-callback</h3>
<a name="Syntax-68"></a>
<h4 class="subheading">Syntax</h4>
<dl>
<dt><a name="index-get_002dcallback"></a>Accessor: <strong>get-callback</strong> <em>symbol⇒ pointer</em></dt>
</dl>

<a name="Arguments-and-Values-63"></a>
<h4 class="subheading">Arguments and Values</h4>

<dl compact="compact">
<dt><var>symbol</var></dt>
<dd><p>A symbol denoting a callback.
</p>
</dd>
<dt><var>pointer</var></dt>
<dd><p>A pointer.
</p></dd>
</dl>

<a name="Description-68"></a>
<h4 class="subheading">Description</h4>
<p>Это функциональная версия макроса <code>callback</code>. Она возвращает
указатель на обратный вызов, обозначаемый соотвествующим <var>symbol</var>,
например, для передачи в качестве аргумента внешним функциям.
</p>
<a name="Examples-62"></a>
<h4 class="subheading">Examples</h4>

<div class="lisp">
<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcallback</span></i> sum <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">a <span class="keyword">:int</span></span>)</span> <span class="paren3">(<span class="lisp-bg">b <span class="keyword">:int</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">+ a b</span>)</span></span>)</span>
 ⇒ SUM
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">get-callback 'sum</span>)</span>
 ⇒ #&lt;A Mac Pointer #x102350&gt;
</pre></div>

<a name="See-Also-59"></a>
<h4 class="subheading">See Also</h4>
<p><a href="#callback">callback</a> <br>
<a href="#defcallback">defcallback</a>
</p>

<hr>
<a name="The-Groveller"></a>
<div class="header">
<p>
Next: <a href="#Limitations" accesskey="n" rel="next">Limitations</a>, Previous: <a href="#Callbacks" accesskey="p" rel="prev">Callbacks</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-Groveller-1"></a>
<h2 class="chapter">13 Groveller</h2>

<p><acronym>CFFI</acronym>-Grovel это инструмент, который облегчает написание
деклараций <acronym>CFFI</acronym> для библиотек, которые реализованы на Си.
То есть, он просматривает заголовочные файлы системы, получая информацию о
типах и структурах, поэтому вам не нужно этого делать.  Это особенно
важно для библиотек, которые по разному реализуются разными поставщиками,
такими как фунции <small>UNIX</small>/<small>POSIX</small>.  Декларации <acronym>CFFI</acronym>,
как правило, сильно отличаются от платформы к платформе, но информация, которую вы предоставляете
<acronym>CFFI</acronym>-Grovel одна и таже. Следовательно, требуется
гораздо меньше работы!
</p>
<p>Если вы используете <acronym>ASDF</acronym>, <acronym>CFFI</acronym>-Grovel интергрируется, так
что он будет запускаться автоматически при сборке(построении) вашей системы.  
Данная функциональность вдохновлена SB-Grovel, похожим пакетом разработанным для <acronym>SBCL</acronym>
проетов.
<acronym>CFFI</acronym>-Grovel может также использоваться без <acronym>ASDF</acronym>.
</p>
<table class="menu" cellspacing="0" border="0">
<tbody><tr><td valign="top" align="left">• <a href="#Groveller-Syntax" accesskey="1">Groveller Syntax</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Groveller-ASDF-Integration" accesskey="2">Groveller ASDF Integration</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Groveller-Implementation-Notes" accesskey="3">Groveller Implementation Notes</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
<tr><td valign="top" align="left">• <a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros" accesskey="4">Wrapper for Inline/Static Functions and Macros</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">
</td></tr>
</tbody></table>

<a name="Building-FFIs-with-CFFI_002dGrovel"></a>
<h3 class="section">13.1 Создание FFI с помощью CFFI-Grovel</h3>

<p><acronym>CFFI</acronym>-Grovel использует файл спецификаций (*.lisp) описывающий
фунции, которые необходимо извлечь(groveling).  Компилятор Си используется для
извлечения этих данных и записи файла Lisp (*.cffi.lisp), который содержит необходимые
определения <acronym>CFFI</acronym> для доступа к переменным, структурам, константам и
перечислениям, упомянутым в спецификации.
</p>

<p><acronym>CFFI</acronym>-Grovel предоставляет компонент <acronym>ASDF</acronym> для обработки
необходмых вызовов компилятора Си и управления файлами результата.
</p>

<table class="menu" cellspacing="0" border="0">
<tbody><tr><td valign="top" align="left">• <a href="#Groveller-Syntax" accesskey="1">Groveller Syntax</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Как должны выглядеть файлы grovel.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Groveller-ASDF-Integration" accesskey="2">Groveller ASDF Integration</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Компоненты ASDF для файлов.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Groveller-Implementation-Notes" accesskey="3">Groveller Implementation Notes</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Замечания по реализации.
</td></tr>
<tr><td valign="top" align="left">• <a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros" accesskey="4">Wrapper for Inline/Static Functions and Macros</a>:</td><td>&nbsp;&nbsp;</td><td valign="top" align="left">Обертка
</td></tr>
</tbody></table>

<hr>
<a name="Groveller-Syntax"></a>
<div class="header">
<p>
Next: <a href="#Groveller-ASDF-Integration" accesskey="n" rel="next">Groveller ASDF Integration</a>, Previous: <a href="#The-Groveller" accesskey="p" rel="prev">The Groveller</a>, Up: <a href="#The-Groveller" accesskey="u" rel="up">The Groveller</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Specification-File-Syntax"></a>
<h3 class="section">13.2 Синтаксис файла спецификации</h3>

<p>Файлы спецификации читаются обычным Lisp-ом, поэтому они имеют
синтаксис, очень похожий на обычный код Lisp.  В частности,
разделители-коментарии и макросы чтения будут работать как положено.
</p>
<p>Существуют несколько форм, распознаваемых <acronym>CFFI</acronym>-Grovel:
</p>
<dl>
<dt><a name="index-progn"></a>Форма Grovel: <strong>progn</strong> <em>&amp;rest forms</em></dt>
<dd>
<p>Обрабатывает список форм. Полезно для объединения нескольких форм. Например:
</p></dd></dl>

<div class="lisp">
<pre class="lisp">  #+freebsd
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
    <span class="paren2">(<span class="lisp-bg">constant <span class="paren3">(<span class="lisp-bg">ev-enable <span class="string">"EV_ENABLE"</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">constant <span class="paren3">(<span class="lisp-bg">ev-disable <span class="string">"EV_DISABLE"</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<dl>
<dt><a name="index-include"></a>Grovel Form: <strong>include</strong> <em>&amp;rest files</em></dt>
<dd>
<p>Включает указанные файлы (указываются как строки) в исходный код Си используемый для генерации.
</p></dd></dl>

<dl>
<dt><a name="index-in_002dpackage"></a>Grovel Form: <strong>in-package</strong> <em>symbol</em></dt>
<dd>
<p>Устанавливает пакет, который будет использоваться для окончательного вывода Lisp.
</p></dd></dl>

<dl>
<dt><a name="index-ctype"></a>Grovel Form: <strong>ctype</strong> <em>lisp-name size-designator</em></dt>
<dd>
<p>Определяет внешний тип <acronym>CFFI</acronym> для стороки указателя размера <var>size-designator</var>,
например <code>(ctype :pid "pid_t")</code>.
</p></dd></dl>

<dl>
<dt><a name="index-constant"></a>Grovel Form: <strong>constant</strong> <em>(lisp-name &amp;rest c-names) &amp;key type documentation optional</em></dt>
<dd>
<p>Ищет константу именуемую первой стокой <var>c-name</var>, которая известна
препроцессору Си и определяет ее как <var>lisp-name</var>.
</p>
<p>Аргумент ключевое слово <var>type</var> указвает как преобразовать константу:
либо <code>integer</code> (по умолчанию) или <code>double-float</code>. Если
<var>optional</var> равно true, ошибка не возникает, если все <var>c-names</var> 
неизвестны. Если <var>lisp-name</var> это ключевое слово, фактическая константа
будет символом с тем же самым именем, интернированным в текущем пакете.
</p></dd></dl>

<dl>
<dt><a name="index-feature"></a>Grovel Form: <strong>feature</strong> <em>lisp-feature-name c-name &amp;key feature-list</em></dt>
<dd>
<p>Добавляет <var>lisp-feature-name</var> в список  <var>feature-list</var> если строка <var>c-name</var>
известна препроцессору Си. <var>feature-list</var> по умолчанию равен
<code>cl:*features*</code>.
</p></dd></dl>

<dl>
<dt><a name="index-define"></a>Grovel Form: <strong>define</strong> <em>name &amp;optional value</em></dt>
<dd>
<p>Определяет дополнительный символ препроцессора Си, который полезен для изменения поведения
включенных системных заголовков.
</p></dd></dl>

<dl>
<dt><a name="index-cc_002dflags"></a>Grovel Form: <strong>cc-flags</strong> <em>&amp;rest flags</em></dt>
<dd>
<p>Добавляет <var>cc-flags</var> к аргументам командной строки, используемым для
вызова компилятора Си.
</p></dd></dl>

<dl>
<dt><a name="index-pkg_002dconfig_002dcflags"></a>Grovel Form: <strong>pkg-config-cflags</strong> <em>pkg &amp;key optional</em></dt>
<dd>
<p>Добавляет <var>pkg</var> к аргументам командной сторки для внешней программы
<code>pkg-config</code> и запускает ее, чтобы получить соответствующие флаги
используемые для вызов компилятора Си. Этот синтаксис может испольоваться вместо жесткого
задания путей с использованием <code>cc-flags</code>, и гарантирует, что включаемые флаги
будут правильно добавлены в соранную систему. Предполагается, что <code>pkg-config</code> 
инсталирован и работает.  <var>pkg</var> это строка, которая идентифицирует установленный
пакет <code>pkg-config</code>. См. руководство pkg-config для более подробной информации.
Если <var>optional</var> равно true, сбой выполнения <code>pkg-config</code> не
прерывает компиляцию.
</p></dd></dl>

<dl>
<dt><a name="index-cstruct"></a>Grovel Form: <strong>cstruct</strong> <em>lisp-name c-name slots</em></dt>
<dd>
<p>Определялет внешнюю структуру <acronym>CFFI</acronym> с указаннием данных слотов.  Слоты имеют
форму <code>(lisp-name c-name &amp;key type count (signed t))</code>.
</p></dd></dl>

<dl>
<dt><a name="index-cunion"></a>Grovel Form: <strong>cunion</strong> <em>lisp-name c-name slots</em></dt>
<dd>
<p>Идентично <code>cstruct</code>, но определяет внешнее объединение <acronym>CFFI</acronym>.
</p></dd></dl>

<dl>
<dt><a name="index-cstruct_002dand_002dclass"></a>Grovel Form: <strong>cstruct-and-class</strong> <em>c-name slots</em></dt>
<dd>
<p>Определяет внешнюю структуру <acronym>CFFI</acronym> , как <code>cstruct</code> и определяет
класс <acronym>CLOS</acronym>, который будет использоваться с ней.  Это полезно для сопоставления
внешних структур с кодом прикладного уровня, который не должен беспокоиться о проблемах распределения
памяти.
</p></dd></dl>

<dl>
<dt><a name="index-cvar"></a>Grovel Form: <strong>cvar</strong> <em>namespec type &amp;key read-only</em></dt>
<dd>
<p>Определяет внешнюю переменную указанного типа, даже если эта переменная
потецниально является псевдопеременной препроцессора Си.  например
<code>(cvar ("errno" errno) errno-values)</code>, предполагая, что errno-values
является перечислением( enum) или эквивалентно типу <code>:int</code>.
</p>
<p> <var>namespec</var> похож, на тот, который используется в <a href="#defcvar">defcvar</a>.
</p></dd></dl>

<dl>
<dt><a name="index-cenum"></a>Grovel Form: <strong>cenum</strong> <em>name-and-opts &amp;rest elements</em></dt>
<dd>
<p>Определяет истинное перечисление Си(enum), с элементами указыанными как <code>((lisp-name
&amp;rest c-names) &amp;key optional documentation)</code>.
<var>name-and-opts</var> может быть либо символом в качестве имени, или списком
<code>(name &amp;key base-type define-constants)</code>. Если <var>define-constants</var>
не равно null, константа Lisp будет определена для каждого члена перечисления.
</p></dd></dl>

<dl>
<dt><a name="index-constantenum"></a>Grovel Form: <strong>constantenum</strong> <em>name-and-opts &amp;rest elements</em></dt>
<dd>
<p>Определяет перечисление констант прероцессора, с элементами указанными как 
<code>((lisp-name &amp;rest c-names) &amp;key optional
documentation)</code>.
<var>name-and-opts</var> может быть либо символом в качестве имени, или списком
<code>(name &amp;key base-type define-constants)</code>. Если <var>define-constants</var>
не равно null, констатка Lisp будет определена для каждого члена перечисления.
</p>
<p>В этом примере <code>:af-inet</code> для представления значения
<code>AF_INET</code> или <code>PF_INET</code>, в зависимости от того, какое
препроцессор первым.  Аналогично для <code>:af-packet</code>, но об ошибке не
будет сообщено, если платформа не поддерживает ни <code>AF_PACKET</code>, ни
<code>PF_PACKET</code>.
</p></dd></dl>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">constantenum address-family
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:af-inet</span> <span class="string">"AF_INET"</span> <span class="string">"PF_INET"</span></span>)</span>
     <span class="keyword">:documentation</span> <span class="string">"IPv4 Protocol family"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:af-local</span> <span class="string">"AF_UNIX"</span> <span class="string">"AF_LOCAL"</span> <span class="string">"PF_UNIX"</span> <span class="string">"PF_LOCAL"</span></span>)</span>
     <span class="keyword">:documentation</span> <span class="string">"File domain sockets"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:af-inet6</span> <span class="string">"AF_INET6"</span> <span class="string">"PF_INET6"</span></span>)</span>
     <span class="keyword">:documentation</span> <span class="string">"IPv6 Protocol family"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:af-packet</span> <span class="string">"AF_PACKET"</span> <span class="string">"PF_PACKET"</span></span>)</span>
     <span class="keyword">:documentation</span> <span class="string">"Raw packet access"</span>
     <span class="keyword">:optional</span> t</span>)</span></span>)</span>
</pre></div>

<dl>
<dt><a name="index-bitfield"></a>Grovel Form: <strong>bitfield</strong> <em>name-and-opts &amp;rest elements</em></dt>
<dd>
<p>Определяет битовое поле(bitfield) с элементами указанными как <code>((lisp-name &amp;rest
c-names) &amp;key optional documentation)</code>.  <var>name-and-opts</var> может быть либо
символом в качестве имени, или списком <code>(name &amp;key base-type)</code>.  Например:
</p></dd></dl>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">bitfield flags-ctype
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:flag-a</span> <span class="string">"FLAG_A"</span></span>)</span>
      <span class="keyword">:documentation</span> <span class="string">"DOCU_A"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:flag-b</span> <span class="string">"FLAG_B"</span> <span class="string">"FLAG_B_ALT"</span></span>)</span>
      <span class="keyword">:documentation</span> <span class="string">"DOCU_B"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:flag-c</span> <span class="string">"FLAG_C"</span></span>)</span>
      <span class="keyword">:documentation</span> <span class="string">"DOCU_C"</span>
      <span class="keyword">:optional</span> t</span>)</span></span>)</span>
</pre></div>

<hr>
<a name="Groveller-ASDF-Integration"></a>
<div class="header">
<p>
Next: <a href="#Groveller-Implementation-Notes" accesskey="n" rel="next">Groveller Implementation Notes</a>, Previous: <a href="#Groveller-Syntax" accesskey="p" rel="prev">Groveller Syntax</a>, Up: <a href="#The-Groveller" accesskey="u" rel="up">The Groveller</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="ASDF-Integration"></a>
<h3 class="section">13.3 Интеграция с ASDF</h3>

<p>Пример программного проекта может содержать четыре файла; файл
<acronym>ASDF</acronym>, файл определения пакета, файл реализации, 
и файл спецификации <acronym>CFFI</acronym>-Grovel.
</p>
<p>Файл <acronym>ASDF</acronym> определяет систему и ее зависимости.
Обратите внимание на использование <code>eval-when</code> чтобы убедиться
в наличии <acronym>CFFI</acronym>-Grovel и использования <code>(cffi-grovel:grovel-file name &amp;key cc-flags)</code>
вместо <code>(:file name)</code>.
</p>
<p>Файл <samp>example-software.asd</samp> будет выглядеть так:
</p>
<div class="lisp">
<pre class="lisp">  <span class="comment">;;; CFFI-Grovel is needed for processing grovel-file components
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defsystem</span></i> <span class="string">"example-software"</span>
    <span class="keyword">:defsystem-depends-on</span> <span class="paren2">(<span class="lisp-bg"><span class="string">"cffi-grovel"</span></span>)</span>
    <span class="keyword">:depends-on</span> <span class="paren2">(<span class="lisp-bg"><span class="string">"cffi"</span></span>)</span>
    <span class="keyword">:serial</span> t
    <span class="keyword">:components</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:file</span> <span class="string">"package"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg"><span class="keyword">:cffi-grovel-file</span> <span class="string">"example-grovelling"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg"><span class="keyword">:cffi-wrapper-file</span> <span class="string">"example-wrappers"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg"><span class="keyword">:file</span> <span class="string">"example"</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<p>Файл <samp>package.lisp</samp> будет содержать одну или несколько форм
<code>defpackage</code>, чтобы удалить циклические зависимости и упростить
сборку прокета.  Обратите внимание, что вы можете использовать или не использовать
<code>:use</code> свой внутренний пакет.
</p>
<blockquote>
<p><strong>Примечание разработчкика:</strong> <em>обратите внимание, что не очень хорошая
идея использовать <code>:use</code> когда имена могут конфликтовать, скажем с символами CL.
Или вы можете использовать <code>uiop:define-package</code> и его опцию <code>:mix</code>.</em>
</p></blockquote>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defpackage</span></i> <span class="keyword">#:example-internal</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:use</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:nicknames</span> <span class="keyword">#:exampleint</span></span>)</span></span>)</span>

  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defpackage</span></i> <span class="keyword">#:example-software</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:export</span> ...</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:use</span> <span class="keyword">#:cl</span> <span class="keyword">#:cffi</span> <span class="keyword">#:exampleint</span></span>)</span></span>)</span>
</pre></div>

<p>Внутренний пакет создается выводом кода Lisp из программы Си, написанной 
<acronym>CFFI</acronym>-Grovel; если ваш файл спецификации -
<samp>exampleint.lisp</samp>, файл <samp>exampleint.cffi.lisp</samp> будет содержать
определения <acronym>CFFI</acronym> необходимые для остальной части вашего проекта.
См. <a href="#Groveller-Syntax">Синтаксис Groveller</a>.
</p>
<hr>
<a name="Groveller-Implementation-Notes"></a>
<div class="header">
<p>
Next: <a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros" accesskey="n" rel="next">Wrapper for Inline/Static Functions and Macros</a>, Previous: <a href="#Groveller-ASDF-Integration" accesskey="p" rel="prev">Groveller ASDF Integration</a>, Up: <a href="#The-Groveller" accesskey="u" rel="up">The Groveller</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Implementation-Notes"></a>
<h3 class="section">13.4 Заметки для реализации</h3>

<p><acronym>CFFI</acronym>-Grovel генерирует множество файлов, которые 
не только зависят от архитектуры, но также зависят от реализации и 
не должны распространятся.
ASDF сгенерирует эти файлы в своем выходном кеше;
если вы создаете множество архитектур (например с домашними каталогами NFS/AFS) 
или реализаций, крайне важно избегать колизий, чтобы сохранить это кеш в каталоге,
зависящем от реализации (как это и есть по умолчанию).
</p>
<p>Для <code>foo-internal.lisp</code>, все полученные <code>foo-internal.c</code>,
<code>foo-internal</code>, и <code>foo-internal.cffi.lisp</code> зависят от
платформы, либо из-за возможных макросов чтения в foo-internal.lisp, либо из за
различных окружений Си в хост-системе.  По этой причине, бесполезно распространять
каки-либо из этих файлов; конечным пользователям, создающим программное обесечение
на основе <acronym>CFFI</acronym>-Grovel, в любом случае потребуется
<code>cffi</code>-Grovel.
</p>
<blockquote>
<p><strong>Примечание разработчика:</strong> <em>на данный момент, после нескольких экспериментов
с <small>CLISP</small> не имеющем long-long, кажется уместно утверждать, что сгенерированные файлы
<code>.c</code> зависят от архитектуры и операционной системы, но не зависят от реализаций lisp.
Таким образом, один и тотже файл <code>.c</code>  (и тот же файл <code>.grovel-tmp.lisp</code>) 
будет доступен для всех реализаций, работающих в данной системе.</em>
</p></blockquote>

<hr>
<a name="Wrapper-for-Inline_002fStatic-Functions-and-Macros"></a>
<div class="header">
<p>
Previous: <a href="#Groveller-Implementation-Notes" accesskey="p" rel="prev">Groveller Implementation Notes</a>, Up: <a href="#The-Groveller" accesskey="u" rel="up">The Groveller</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Wrapper-for-Inline_002fStatic-Functions-and-Macros-1"></a>
<h3 class="section">13.5 Wrapper(Обертка) для встраиваемых/статических(Inline/Static) функций и макросов</h3>

<p>В разделяемой библиотеке, информация о статических и разделяемых функциях
и макросах уже удалена во время компиляции.  Файл Wrapper(обертка)
позволяет написать невстроенную(uninlined) функцию, обертывающую
вызов к ним.
</p>
<p>Компиляция/загрузка файла оберток(wrapper)  происходит следующим образом: 
в отличиии от groveller, который генерирует Си код и файлы lisp содержащие
определения cffi, он генерирует Си код, компилирует его как разделяемую библиотеку,
загружает библиотеку, генерирует определения cffi (как лисп код) и затем
загружает код lisp.
</p>
<p>Он имеет интеграцию asdf похожую на groveller. 
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defsystem</span></i> <span class="string">"example-software"</span>
    <span class="keyword">:defsystem-depends-on</span> <span class="paren2">(<span class="lisp-bg"><span class="string">"cffi-grovel"</span></span>)</span>
    <span class="keyword">:depends-on</span> <span class="paren2">(<span class="lisp-bg"><span class="string">"cffi"</span></span>)</span>
    <span class="keyword">:serial</span> t
    <span class="keyword">:components</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:file</span> <span class="string">"package"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg"><span class="keyword">:cffi-grovel-file</span> <span class="string">"example-grovelling"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg"><span class="keyword">:cffi-wrapper-file</span> <span class="string">"example-wrappers"</span></span>)</span>  <span class="comment">;; &lt;&lt;--- this part
  </span>   <span class="paren3">(<span class="lisp-bg"><span class="keyword">:file</span> <span class="string">"example"</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<dl>
<dt><a name="index-defwrapper"></a>Wrapper Form: <strong>defwrapper</strong> <em>name-and-options return-type &amp;rest args</em></dt>
</dl>

<div class="example">
<pre class="example">static inline int foo(int i) {
  return 1+i;
};
#define bar(i) (1+(i))
</pre></div>

<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">in-package <span class="keyword">:mypackage</span></span>)</span>
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defwrapper</span></i> <span class="paren2">(<span class="lisp-bg"><span class="string">"foo"</span> foo</span>)</span> <span class="keyword">:int</span>
    <span class="paren2">(<span class="lisp-bg">i <span class="keyword">:int</span></span>)</span></span>)</span>
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defwrapper</span></i> <span class="paren2">(<span class="lisp-bg"><span class="string">"bar"</span> bar</span>)</span> <span class="keyword">:int</span>
    <span class="paren2">(<span class="lisp-bg">i <span class="keyword">:int</span></span>)</span></span>)</span>
</pre></div>

<p>Другие файлы похожи на файлы grovel.
</p>
<dl>
<dt><a name="index-progn-1"></a>Wrapper Form: <strong>progn</strong> <em>&amp;rest forms</em></dt>
<dd>
<p>Обрабатывает список форм. Полезно для объединения нескольких форм.
Например:
</p></dd></dl>

<div class="lisp">
<pre class="lisp">  #+freebsd
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
    <span class="paren2">(<span class="lisp-bg">constant <span class="paren3">(<span class="lisp-bg">ev-enable <span class="string">"EV_ENABLE"</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">constant <span class="paren3">(<span class="lisp-bg">ev-disable <span class="string">"EV_DISABLE"</span></span>)</span></span>)</span></span>)</span>
</pre></div>

<dl>
<dt><a name="index-include-1"></a>Wrapper Form: <strong>include</strong> <em>&amp;rest files</em></dt>
<dd>
<p>Включает указанные файлы (указанные как строки) в генерируемый Си код.
</p></dd></dl>

<dl>
<dt><a name="index-in_002dpackage-1"></a>Wrapper Form: <strong>in-package</strong> <em>symbol</em></dt>
<dd>
<p>Устанавливает пакет, который будет использоваться для окончательного вывода Лисп.
</p></dd></dl>

<dl>
<dt><a name="index-flags"></a>Wrapper Form: <strong>flags</strong> <em>&amp;rest flags</em></dt>
<dd>
<p>Добавляет <var>cc-flags</var> к аргументам командной строки, используемым для вызова компилятора Си.
</p></dd></dl>

<dl>
<dt><a name="index-proclaim"></a>Wrapper Form: <strong>proclaim</strong> <em>&amp;rest proclaimations</em></dt>
</dl>
<dl>
<dt><a name="index-declaim"></a>Wrapper Form: <strong>declaim</strong> <em>&amp;rest declaimations</em></dt>
</dl>

<hr>
<a name="Static-Linking"></a>
<div class="header">
<p>
Next: <a href="#Limitations" accesskey="n" rel="next">Limitations</a>, Previous: <a href="#The-Groveller" accesskey="p" rel="prev">The Groveller</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Static-Linking-1"></a>
<h2 class="chapter">14 Статическое связывание</h2>

<p>На достаточно свежих версиях поддерживаемых реализаций (в настоящее время,
GNU CLISP 2.49, CMUCL 2015-11, и SBCL 1.2.17), и с достаточно недавним 
ASDF (3.1.2 или выше), вы можете создавать статически связанные исполняемые
образ Lisp, который включает в себя все расширения Си
(обертки и любые другие объекты, выводимые <code>compile-op</code>),
а также ваш код Lisp или исполняемый файл отдельного приложения.
Это облегчает доставку вашего кода в виде одного файла.
</p>
<p>Чтобы выгрузить статически связанный исполняемый образ, используйте:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">asdf:load-system <span class="keyword">:cffi-grovel</span></span>)</span>
  <span class="paren1">(<span class="lisp-bg">asdf:operate <span class="keyword">:static-image-op</span> <span class="keyword">:example-software</span></span>)</span>
</pre></div>

<p>Чтобы выгрузить статически связанное исполняемое автономное приложение, используйте:
</p>
<div class="lisp">
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">asdf:load-system <span class="keyword">:cffi-grovel</span></span>)</span>
  <span class="paren1">(<span class="lisp-bg">asdf:operate <span class="keyword">:static-program-op</span> <span class="keyword">:example-software</span></span>)</span>
</pre></div>

<p>См. <a href="https://common-lisp.net/project/asdf/"> руководство по ASDF</a> для 
ознакомления с документацией о <code>image-op</code> и <code>program-op</code>,
которые являются родительскими классами операций, которые ведут себя аналогично, за
исключением того, что они не связывают статический код Си.
</p>
<blockquote>
<p><strong>Примечание разработчика:</strong> <em>Существует также операция <code>:static-runtime-op</code> для
создания  только статически связанной среды выполнения, но по общему признанию она не очень 
полезна, за исплючением промежуточного шага в направлении создания
<code>:static-image-op</code> или <code>:static-program-op</code>.</em>
</p></blockquote>

<hr>
<a name="Limitations"></a>
<div class="header">
<p>
Next: <a href="#Platform_002dspecific-features" accesskey="n" rel="next">Platform-specific features</a>, Previous: <a href="#The-Groveller" accesskey="p" rel="prev">The Groveller</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Limitations-2"></a>
<h2 class="chapter">15 Ограничения</h2>

<p>Это ограничение <acronym>CFFI</acronym>â для всех платформ; 
для получения информации о неисправностях на конкретных реализациях
см.<a href="#Implementation-Support">Поддерживаемые реализации</a>.
</p>
<ul>
<li> Учебное пособие включает в себя трактовку основного, непреодолимого
ограничения <acronym>CFFI</acronym>, или любого другого <acronym>FFI</acronym>: 
абстракции, обычно используемые Си, недостаточно выразительны.
См. <a href="#Tutorial_002dAbstraction">Нарушение абстракции</a>, для более
подробной информации.

</li></ul>

<hr>
<a name="Platform_002dspecific-features"></a>
<div class="header">
<p>
Next: <a href="#Glossary" accesskey="n" rel="next">Glossary</a>, Previous: <a href="#Limitations" accesskey="p" rel="prev">Limitations</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Platform_002dspecific-features-1"></a>
<h2 class="appendix">Appendix A Platform-specific features</h2>

<p>Whenever a backend doesnât support one of <acronym>CFFI</acronym>âs features, a
specific symbol is pushed onto <code>common-lisp:*features*</code>.  The
meanings of these symbols follow.
</p>
<dl compact="compact">
<dt><var>cffi-sys::flat-namespace</var></dt>
<dd><p>This Lisp has a flat namespace for foreign symbols meaning that you
wonât be able to load two different libraries with homograph functions
and successfully differentiate them through the <code>:library</code>
option to <code>defcfun</code>, <code>defcvar</code>, etcâ¦
</p>
</dd>
<dt><var>cffi-sys::no-foreign-funcall</var></dt>
<dd><p>The macro <code>foreign-funcall</code> is <strong>not</strong> available.  On such
platforms, the only way to call a foreign function is through
<code>defcfun</code>.  See <a href="#foreign_002dfuncall">foreign-funcall</a>, and <a href="#defcfun">defcfun</a>.
</p>
</dd>
<dt><var>cffi-sys::no-long-long</var></dt>
<dd><p>The C <code>long long</code> type is <strong>not</strong> available as a foreign
type.
</p>
<p>However, on such platforms <acronym>CFFI</acronym> provides its own implementation of
the <code>long long</code> type for all of operations in chapters
<a href="#Foreign-Types">Foreign Types</a>, <a href="#Pointers">Pointers</a> and <a href="#Variables">Variables</a>. The
functionality described in <a href="#Functions">Functions</a> and <a href="#Callbacks">Callbacks</a> will
not be available.
</p>
<p>32-bit Lispworks 5.0+ is an exception. In addition to the <acronym>CFFI</acronym>
implementation described above, Lispworks itself implements the
<code>long long</code> type for <a href="#Functions">Functions</a>. <a href="#Callbacks">Callbacks</a> are still
missing <code>long long</code> support, though.
</p>
</dd>
<dt><var>cffi-sys::no-stdcall</var></dt>
<dd><p>This Lisp doesnât support the <code>stdcall</code> calling convention.  Note
that it only makes sense to support <code>stdcall</code> on (32-bit) x86
platforms.
</p>
</dd>
</dl>

<hr>
<a name="Glossary"></a>
<div class="header">
<p>
Next: <a href="#Comprehensive-Index" accesskey="n" rel="next">Comprehensive Index</a>, Previous: <a href="#Platform_002dspecific-features" accesskey="p" rel="prev">Platform-specific features</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Glossary-1"></a>
<h2 class="appendix">Appendix B Словарь</h2>

<dl compact="compact">
<dt><em>aggregate type</em></dt>
<dd><p>Тип <acronym>CFFI</acronym> для данных Си, пределенных как организованные данные простых
типов; в структурах и объединениях, котоыре сами являются агрегатными типами, они пердставляют
занчения.
</p>
</dd>
<dt><em>foreign value</em></dt>
<dd><p>Имеет два значения; в произвольном контексте, только одно имеет смысл.
</p>
<p>При использовании преобразователей, внешнее значение - это значение низкого
уровня Lisp, полученное из объекта, переданного в <code>translate-to-foreign</code>
(см. <a href="#translate_002dto_002dforeign">translate-to-foreign</a>).  Это значение
должно быть числом Lisp или указателем (удовлетворяющим <code>pointerp</code>), и его
можно рассматривать как любой обычный объект Lisp; оно только завершает
преобразование в настоящее внешнее значение при передаче через низкоуровневый код в
реализацию Lisp, такой как вызывающая сторона внешней функции или косвенная адресация
памяти в сочетании с перемещанием данных.
</p>
<p>В других контекстах это относится к значению доступному для Си, но к которому можно
получить доступ только через функции <acronym>CFFI</acronym>.  Самое близкое, что вы
можете получить к такому внешнему значению, через объект указатель Lisp, который сам
по себе считается внешним значением только в предыдущем смысле.
</p>
</dd>
<dt><em>simple type</em></dt>
<dd><p>Тип <acronym>CFFI</acronym>, который в конечном итоге представляется как встроенный
тип; <acronym>CFFI</acronym> предоставляет только дополнительную семантику для Lisp, которая
невидима для Си кода или данных.
</p></dd>
</dl>

<hr>
<a name="Comprehensive-Index"></a>
<div class="header">
<p>
Previous: <a href="#Glossary" accesskey="p" rel="prev">Glossary</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Comprehensive-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Index"></a>
<h2 class="unnumbered">Index</h2>
<table><tbody><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Comprehensive-Index_cp_symbol-1"><b>:</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-W"><b>W</b></a>
 &nbsp; 
</td></tr></tbody></table>
<table class="index-cp" border="0">
<tbody><tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_symbol-1">:</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003abool"><code>:bool</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Types">Other Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aboolean"><code>:boolean</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Types">Other Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003achar"><code>:char</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003adouble"><code>:double</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003afloat"><code>:float</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aint"><code>:int</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aint16"><code>:int16</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aint32"><code>:int32</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aint64"><code>:int64</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aint8"><code>:int8</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003allong"><code>:llong</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003along"><code>:long</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003along_002ddouble"><code>:long-double</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003along_002dlong"><code>:long-long</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003apointer"><code>:pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003ashort"><code>:short</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003astring"><code>:string</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Types">Other Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003astring_002bptr"><code>:string+ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Types">Other Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003auchar"><code>:uchar</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003auint"><code>:uint</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003auint16"><code>:uint16</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003auint32"><code>:uint32</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003auint64"><code>:uint64</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003auint8"><code>:uint8</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aullong"><code>:ullong</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aulong"><code>:ulong</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aunsigned_002dchar"><code>:unsigned-char</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aunsigned_002dint"><code>:unsigned-int</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aunsigned_002dlong"><code>:unsigned-long</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aunsigned_002dlong_002dlong"><code>:unsigned-long-long</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aunsigned_002dshort"><code>:unsigned-short</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003aushort"><code>:ushort</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003avoid"><code>:void</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Built_002dIn-Types">Built-In Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003awrapper"><code>:wrapper</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Types">Other Types</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-abstraction-breaking">abstraction breaking</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-abstractions-in-C">abstractions in C</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-advantages-of-FFI">advantages of <acronym>FFI</acronym></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-B">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-benefits-of-FFI">benefits of <acronym>FFI</acronym></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bitfield"><code>bitfield</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-breaking-the-abstraction">breaking the abstraction</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-C-abstractions">C abstractions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-callback"><code>callback</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#callback">callback</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-callback-definition">callback definition</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dCallbacks">Tutorial-Callbacks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-calling-foreign-functions">calling foreign functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dInitializing">Tutorial-Initializing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cc_002dflags"><code>cc-flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cenum"><code>cenum</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-close_002dforeign_002dlibrary"><code>close-foreign-library</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#close_002dforeign_002dlibrary">close-foreign-library</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-compiler-macros-for-type-translation">compiler macros for type translation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Optimizing-Type-Translators">Optimizing Type Translators</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-constant"><code>constant</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-constantenum"><code>constantenum</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-convert_002dfrom_002dforeign"><code>convert-from-foreign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#convert_002dfrom_002dforeign">convert-from-foreign</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-convert_002dto_002dforeign"><code>convert-to-foreign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#convert_002dto_002dforeign">convert-to-foreign</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cstruct"><code>cstruct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cstruct_002dand_002dclass"><code>cstruct-and-class</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ctype"><code>ctype</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cunion"><code>cunion</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cURL">c<acronym>URL</acronym></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dGetting-a-URL">Tutorial-Getting a URL</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cvar"><code>cvar</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-data-in-Lisp-and-C">data in Lisp and C</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dTypes">Tutorial-Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-declaim"><code>declaim</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros">Wrapper for Inline/Static Functions and Macros</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defbitfield"><code>defbitfield</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#defbitfield">defbitfield</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defcallback"><code>defcallback</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#defcallback">defcallback</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defcenum"><code>defcenum</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#defcenum">defcenum</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defcfun"><code>defcfun</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#defcfun">defcfun</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defcstruct"><code>defcstruct</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#defcstruct">defcstruct</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defctype"><code>defctype</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#defctype">defctype</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defcunion"><code>defcunion</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#defcunion">defcunion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defcvar"><code>defcvar</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#defcvar">defcvar</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-define"><code>define</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-define_002dforeign_002dlibrary"><code>define-foreign-library</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#define_002dforeign_002dlibrary">define-foreign-library</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-define_002dforeign_002dtype"><code>define-foreign-type</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#define_002dforeign_002dtype">define-foreign-type</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-define_002dparse_002dmethod"><code>define-parse-method</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#define_002dparse_002dmethod">define-parse-method</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defining-callbacks">defining callbacks</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dCallbacks">Tutorial-Callbacks</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defining-type_002dtranslation-compiler-macros">defining type-translation compiler macros</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Optimizing-Type-Translators">Optimizing Type Translators</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defwrapper"><code>defwrapper</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros">Wrapper for Inline/Static Functions and Macros</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dynamic-extent">dynamic extent</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dMemory">Tutorial-Memory</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-E">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-enumeration_002c-C">enumeration, C</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002deasy_005fsetopt">Tutorial-easy_setopt</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-feature"><code>feature</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FILE_002a-and-streams"><small>FILE</small>* and streams</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flags"><code>flags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros">Wrapper for Inline/Static Functions and Macros</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign-arguments">foreign arguments</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002deasy_005fsetopt">Tutorial-easy_setopt</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign-functions-and-data">foreign functions and data</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial">Tutorial</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign-library-load">foreign library load</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dLoading">Tutorial-Loading</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign-values-with-dynamic-extent">foreign values with dynamic extent</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dMemory">Tutorial-Memory</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dalloc"><code>foreign-alloc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dalloc">foreign-alloc</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dbitfield_002dsymbols"><code>foreign-bitfield-symbols</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dbitfield_002dvalue"><code>foreign-bitfield-value</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002denum_002dkeyword"><code>foreign-enum-keyword</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002denum_002dvalue"><code>foreign-enum-value</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002denum_002dvalue">foreign-enum-value</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dfree"><code>foreign-free</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dfree">foreign-free</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dfuncall"><code>foreign-funcall</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dfuncall">foreign-funcall</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dfuncall_002dpointer"><code>foreign-funcall-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dfuncall_002dpointer_002dvarargs"><code>foreign-funcall-pointer-varargs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dfuncall_002dpointer_002dvarargs">foreign-funcall-pointer-varargs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dfuncall_002dvarargs"><code>foreign-funcall-varargs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dfuncall_002dvarargs">foreign-funcall-varargs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dpointer"><code>foreign-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Basic-Pointer-Operations">Basic Pointer Operations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dslot_002dnames"><code>foreign-slot-names</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dslot_002dnames">foreign-slot-names</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dslot_002doffset"><code>foreign-slot-offset</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dslot_002doffset">foreign-slot-offset</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dslot_002dpointer"><code>foreign-slot-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dslot_002dvalue"><code>foreign-slot-value</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dslot_002dvalue">foreign-slot-value</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dstring_002dalloc"><code>foreign-string-alloc</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dstring_002dfree"><code>foreign-string-free</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dstring_002dfree">foreign-string-free</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dstring_002dto_002dlisp"><code>foreign-string-to-lisp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dsymbol_002dpointer"><code>foreign-symbol-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dsymbol_002dpointer">foreign-symbol-pointer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dtype_002dalignment"><code>foreign-type-alignment</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dtype_002dalignment">foreign-type-alignment</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign_002dtype_002dsize"><code>foreign-type-size</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#foreign_002dtype_002dsize">foreign-type-size</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-free_002dconverted_002dobject"><code>free-converted-object</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#free_002dconverted_002dobject">free-converted-object</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-free_002dtranslated_002dobject"><code>free-translated-object</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#free_002dtranslated_002dobject">free-translated-object</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-function-definition">function definition</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dInitializing">Tutorial-Initializing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-get_002dcallback"><code>get-callback</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#get_002dcallback">get-callback</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-get_002dvar_002dpointer"><code>get-var-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#get_002dvar_002dpointer">get-var-pointer</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-I">I</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-in_002dpackage"><code>in-package</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in_002dpackage-1"><code>in-package</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros">Wrapper for Inline/Static Functions and Macros</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-inc_002dpointer"><code>inc-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#inc_002dpointer">inc-pointer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-incf_002dpointer"><code>incf-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#incf_002dpointer">incf-pointer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-include"><code>include</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-include-1"><code>include</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros">Wrapper for Inline/Static Functions and Macros</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-library_002c-foreign">library, foreign</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dLoading">Tutorial-Loading</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-limitations-of-type-translators">limitations of type translators</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dTypes">Tutorial-Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lisp_002dstring_002dto_002dforeign"><code>lisp-string-to-foreign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lispy-C-functions">Lispy C functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dLisp-easy_005fsetopt">Tutorial-Lisp easy_setopt</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-load_002dforeign_002dlibrary"><code>load-foreign-library</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#load_002dforeign_002dlibrary">load-foreign-library</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-load_002dforeign_002dlibrary_002derror"><code>load-foreign-library-error</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loading-CFFI">loading <acronym>CFFI</acronym></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dLoading">Tutorial-Loading</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-looks-like-it-worked">looks like it worked</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dInitializing">Tutorial-Initializing</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002dpointer"><code>make-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#make_002dpointer">make-pointer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mem_002daptr"><code>mem-aptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#mem_002daptr">mem-aptr</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mem_002daref"><code>mem-aref</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#mem_002daref">mem-aref</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mem_002dref"><code>mem-ref</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#mem_002dref">mem-ref</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-minimal-bindings">minimal bindings</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-N">N</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-null_002dpointer"><code>null-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#null_002dpointer">null-pointer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null_002dpointer_002dp"><code>null-pointer-p</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#null_002dpointer_002dp">null-pointer-p</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Perl">Perl</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pkg_002dconfig_002dcflags"><code>pkg-config-cflags</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pointer_002daddress"><code>pointer-address</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pointer_002daddress">pointer-address</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pointer_002deq"><code>pointer-eq</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pointer_002deq">pointer-eq</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pointerp"><code>pointerp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#pointerp">pointerp</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pointers-in-Lisp">pointers in Lisp</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dInitializing">Tutorial-Initializing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-premature-deallocation">premature deallocation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dMemory">Tutorial-Memory</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-proclaim"><code>proclaim</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros">Wrapper for Inline/Static Functions and Macros</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-progn"><code>progn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Groveller-Syntax">Groveller Syntax</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-progn-1"><code>progn</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Wrapper-for-Inline_002fStatic-Functions-and-Macros">Wrapper for Inline/Static Functions and Macros</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Python">Python</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-requiring-CFFI">requiring <acronym>CFFI</acronym></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dLoading">Tutorial-Loading</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-SLIME"><acronym>SLIME</acronym></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-streams-and-C">streams and C</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-strings">strings</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dMemory">Tutorial-Memory</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SWIG"><acronym>SWIG</acronym></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-translate_002dcamelcase_002dname"><code>translate-camelcase-name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translate_002dfrom_002dforeign"><code>translate-from-foreign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#translate_002dfrom_002dforeign">translate-from-foreign</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translate_002dinto_002dforeign_002dmemory"><code>translate-into-foreign-memory</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translate_002dname_002dfrom_002dforeign"><code>translate-name-from-foreign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translate_002dname_002dto_002dforeign"><code>translate-name-to-foreign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translate_002dto_002dforeign"><code>translate-to-foreign</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#translate_002dto_002dforeign">translate-to-foreign</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translate_002dunderscore_002dseparated_002dname"><code>translate-underscore-separated-name</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-translating-types">translating types</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dTypes">Tutorial-Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tutorial_002c-CFFI">tutorial, <acronym>CFFI</acronym></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial">Tutorial</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-type-definition">type definition</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dTypes">Tutorial-Types</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-type-translators_002c-optimizing">type translators, optimizing</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Optimizing-Type-Translators">Optimizing Type Translators</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-U">U</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-use_002dforeign_002dlibrary"><code>use-foreign-library</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#use_002dforeign_002dlibrary">use-foreign-library</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-varargs">varargs</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002deasy_005fsetopt">Tutorial-easy_setopt</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Comprehensive-Index_cp_letter-W">W</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-with_002dforeign_002dobject"><code>with-foreign-object</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#with_002dforeign_002dobject">with-foreign-object</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-with_002dforeign_002dobjects"><code>with-foreign-objects</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#with_002dforeign_002dobject">with-foreign-object</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-with_002dforeign_002dpointer"><code>with-foreign-pointer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#with_002dforeign_002dpointer">with-foreign-pointer</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-with_002dforeign_002dpointer_002das_002dstring"><code>with-foreign-pointer-as-string</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-with_002dforeign_002dslots"><code>with-foreign-slots</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#with_002dforeign_002dslots">with-foreign-slots</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-with_002dforeign_002dstring"><code>with-foreign-string</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#with_002dforeign_002dstring">with-foreign-string</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-with_002dforeign_002dstrings"><code>with-foreign-strings</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#with_002dforeign_002dstring">with-foreign-string</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-workaround-for-C">workaround for C</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tutorial_002dComparison">Tutorial-Comparison</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</tbody></table>
<table><tbody><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Comprehensive-Index_cp_symbol-1"><b>:</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Comprehensive-Index_cp_letter-W"><b>W</b></a>
 &nbsp; 
</td></tr></tbody></table>

<div class="footnote">
<hr>
<h4 class="footnotes-heading">Примечания</h4>

<h3><a name="FOOT1" href="#DOCF1">(1)</a></h3>
<p>Следует признать, что это сложная проблема, и мы рекомендуем вам оставить этот текст,
пока вы не ознакомитесь с принципами работы <acronym>CFFI</acronym>.</p>
<h3><a name="FOOT2" href="#DOCF2">(2)</a></h3>
<p>Это не относится к структурам, чье содержимое должно быть частью интерфайся
публичной библиотеки. В этих случаях всегда предпочтительнее чисто структурное
определение Lisp. Фактически, многие предпочитают оставаться в  Lisp и в любом
случае нарушать инекпсуляцию, возлагая бремя правильного определения интерфейса
библиотеки на саму библиотеку.</p>
<h3><a name="FOOT3" href="#DOCF3">(3)</a></h3>
<p>В частности,
<acronym>UFFI</acronym>, более старая <acronym>FFI</acronym>, которая использует несколько
иной подход по сравнению с  <acronym>CFFI</acronym>.  Я считаю что в наши дни (December
2005) <acronym>CFFI</acronym> более мобильна и активно развивается, хотя и на настолько 
зрела.  Похоже, что в свободном сообществе <small>UNIX</small> Common Lisp существует 
консенсус в отношении того, что <acronym>CFFI</acronym> предпочтительнее для новых разработок,
хотя испольование <acronym>UFFI</acronym>, вероятно, будет продолжаться довольно долго, поскольку
многие проекты уже используют его.  <acronym>CFFI</acronym> включает пакет <code>UFFI-COMPAT</code> 
для полной совместимости с  <acronym>UFFI</acronym>.</p>
<h3><a name="FOOT4" href="#DOCF4">(4)</a></h3>
<p>This isnât entirely true; some Lisps
donât support <code>foreign-funcall</code>, so <code>defcfun</code> is implemented
without it.  <code>defcfun</code> may also perform optimizations that
<code>foreign-funcall</code> cannot.</p>
<h3><a name="FOOT5" href="#DOCF5">(5)</a></h3>
<p>Another possibility is to allow the caller to
specify the desired C type of the third argument.  This is essentially
what happens in a call to the function written in C.</p>
<h3><a name="FOOT6" href="#DOCF6">(6)</a></h3>
<p>See <a href="http://www.gnu.org/software/libc/manual/html_mono/http://www.gnu.org/software/libc/manual/html_mono/libc.html#Other-Kinds-of-Streams">Other Kinds of Streams</a> in <cite>GNU C Library
Reference</cite>, for a <acronym>GNU</acronym>-only way to extend the <code>FILE*</code>
type.  You could use this to convert Lisp streams to the needed C
data.  This would be quite involved and far outside the scope of this
tutorial.</p>
<h3><a name="FOOT7" href="#DOCF7">(7)</a></h3>
<p>â<i>But I thought Lisp was supposed to protect
me from all that buggy C crap!</i>â  Before asking a question like that,
remember that you are a stranger in a foreign land, whose residents
have a completely different set of values.</p>
<h3><a name="FOOT8" href="#DOCF8">(8)</a></h3>
<p>There are advantages and
disadvantages to each approach; I chose to <code>(setf
symbol-function)</code> earlier because it entailed generating fewer magic
function names.</p>
<h3><a name="FOOT9" href="#DOCF9">(9)</a></h3>
<p>Unfortunately, we canât protect against
<em>all</em> non-local exits, such as <code>return</code>s and <code>throw</code>s,
because <code>unwind-protect</code> cannot be used to âshort-circuitâ a
non-local exit in Common Lisp, due to proposal <code>minimal</code> in
<a href="http://www.lisp.org/HyperSpec/Issues/iss152-writeup.html"><acronym>ANSI</acronym> issue <small>EXIT-EXTENT</small></a>.  Furthermore, binding an
<code>error</code> handler prevents higher-up code from invoking restarts
that may be provided under the callbackâs dynamic context.  Such is
the way of compromise.</p>
<h3><a name="FOOT10" href="#DOCF10">(10)</a></h3>
<p>It might be better to return
<code>(values)</code> than <code>:curle-ok</code> in real code, but this is good
for illustration.</p>
<h3><a name="FOOT11" href="#DOCF11">(11)</a></h3>
<p>The
definition of <em>memory</em> includes the <acronym>CPU</acronym> registers.</p>
<h3><a name="FOOT12" href="#DOCF12">(12)</a></h3>
<p>Windows programmers may chafe at adding a
<small>UNIX</small>-specific clause to <code>define-foreign-library</code>.  Instead,
ask why the Windows solution to library incompatibility is âinclude
your own version of every library you use with every programâ.</p>
<h3><a name="FOOT13" href="#DOCF13">(13)</a></h3>
<p>See <a href="https://common-lisp.net/project/cffi/manual/asdf.html#Using-asdf-to-load-systems">Using asdf to load systems</a> in <cite>asdf: another system definition facility</cite>, for information on
<code>asdf:*central-registry*</code>.</p>
<h3><a name="FOOT14" href="#DOCF14">(14)</a></h3>
<p>See <code>mini-eval</code> in <samp>libraries.lisp</samp> for
the source of this definition.  As is always the case with a Lisp
<code>eval</code>, itâs easier to understand the Lisp definition than the
english.</p>
<h3><a name="FOOT15" href="#DOCF15">(15)</a></h3>
<p>Namely, <acronym>CMUCL</acronym>.  See
<code>use-foreign-library</code> in <samp>libraries.lisp</samp> for details.</p>
</div>
<hr>

</body></html>